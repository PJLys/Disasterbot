
LinebotOef1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000fd6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000076  00802000  00000fd6  0000106a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000842  00802076  00802076  000010e0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000010e0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001110  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002a8  00000000  00000000  00001150  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000679d  00000000  00000000  000013f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003426  00000000  00000000  00007b95  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002189  00000000  00000000  0000afbb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000082c  00000000  00000000  0000d144  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000318c  00000000  00000000  0000d970  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002ccf  00000000  00000000  00010afc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002b0  00000000  00000000  000137cb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 04 01 	jmp	0x208	; 0x208 <__ctors_end>
   4:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
   8:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
   c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  10:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  14:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  18:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  1c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  20:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  24:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  28:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  2c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  30:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  34:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  38:	0c 94 9b 03 	jmp	0x736	; 0x736 <__vector_14>
  3c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  40:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  44:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  48:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  4c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  50:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  54:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  58:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  5c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  60:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  64:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  68:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  6c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  70:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  74:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  78:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  7c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  80:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  84:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  88:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  8c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  90:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  94:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  98:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  9c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  a0:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  a4:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  a8:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  ac:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  b0:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  b4:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  b8:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  bc:	0c 94 fd 03 	jmp	0x7fa	; 0x7fa <__vector_47>
  c0:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  c4:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  c8:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  cc:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  d0:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  d4:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  d8:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  dc:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  e0:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  e4:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  e8:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  ec:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  f0:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  f4:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  f8:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
  fc:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 100:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 104:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 108:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 10c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 110:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 114:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 118:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 11c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 120:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 124:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 128:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 12c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 130:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 134:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 138:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 13c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 140:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 144:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 148:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 14c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 150:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 154:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 158:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 15c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 160:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 164:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 168:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 16c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 170:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 174:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 178:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 17c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 180:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 184:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 188:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 18c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 190:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 194:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 198:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 19c:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1a0:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1a4:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1a8:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1ac:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1b0:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1b4:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1b8:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1bc:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1c0:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1c4:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1c8:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1cc:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1d0:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1d4:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1d8:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1dc:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1e0:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1e4:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1e8:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1ec:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1f0:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1f4:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>
 1f8:	0c 94 25 01 	jmp	0x24a	; 0x24a <__bad_interrupt>

000001fc <__trampolines_start>:
 1fc:	0c 94 33 04 	jmp	0x866	; 0x866 <prvIdleTask>
 200:	0c 94 4f 01 	jmp	0x29e	; 0x29e <stdio_getchar>
 204:	0c 94 42 01 	jmp	0x284	; 0x284 <stdio_putchar>

00000208 <__ctors_end>:
 208:	11 24       	eor	r1, r1
 20a:	1f be       	out	0x3f, r1	; 63
 20c:	cf ef       	ldi	r28, 0xFF	; 255
 20e:	cd bf       	out	0x3d, r28	; 61
 210:	df e9       	ldi	r29, 0x9F	; 159
 212:	de bf       	out	0x3e, r29	; 62
 214:	00 e0       	ldi	r16, 0x00	; 0
 216:	0c bf       	out	0x3c, r16	; 60

00000218 <__do_copy_data>:
 218:	10 e2       	ldi	r17, 0x20	; 32
 21a:	a0 e0       	ldi	r26, 0x00	; 0
 21c:	b0 e2       	ldi	r27, 0x20	; 32
 21e:	e6 ed       	ldi	r30, 0xD6	; 214
 220:	ff e0       	ldi	r31, 0x0F	; 15
 222:	00 e0       	ldi	r16, 0x00	; 0
 224:	0b bf       	out	0x3b, r16	; 59
 226:	02 c0       	rjmp	.+4      	; 0x22c <__do_copy_data+0x14>
 228:	07 90       	elpm	r0, Z+
 22a:	0d 92       	st	X+, r0
 22c:	a6 37       	cpi	r26, 0x76	; 118
 22e:	b1 07       	cpc	r27, r17
 230:	d9 f7       	brne	.-10     	; 0x228 <__do_copy_data+0x10>

00000232 <__do_clear_bss>:
 232:	28 e2       	ldi	r18, 0x28	; 40
 234:	a6 e7       	ldi	r26, 0x76	; 118
 236:	b0 e2       	ldi	r27, 0x20	; 32
 238:	01 c0       	rjmp	.+2      	; 0x23c <.do_clear_bss_start>

0000023a <.do_clear_bss_loop>:
 23a:	1d 92       	st	X+, r1

0000023c <.do_clear_bss_start>:
 23c:	a8 3b       	cpi	r26, 0xB8	; 184
 23e:	b2 07       	cpc	r27, r18
 240:	e1 f7       	brne	.-8      	; 0x23a <.do_clear_bss_loop>
 242:	0e 94 8f 07 	call	0xf1e	; 0xf1e <main>
 246:	0c 94 e9 07 	jmp	0xfd2	; 0xfd2 <_exit>

0000024a <__bad_interrupt>:
 24a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000024e <SysClkXtal>:
    // Clock setup          
    if (F_XTAL<400E3) return -1; //Invalid frequency
    if (F_XTAL<=2E6) OSC.XOSCCTRL=0b00001011; //Select <2 Mhz XTAL osc, max startup time
    else if(F_XTAL<=9E6) OSC.XOSCCTRL=0b01001011; //Select <2 Mhz XTAL osc, max startup time 
    else if(F_XTAL<=12E6) OSC.XOSCCTRL=0b10001011; //Select <2 Mhz XTAL osc, max startup time 
    else if(F_XTAL<=16E6) OSC.XOSCCTRL=0b11001011; //Select <2 Mhz XTAL osc, max startup time 
 24e:	8b ec       	ldi	r24, 0xCB	; 203
 250:	80 93 52 00 	sts	0x0052, r24	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>
    else return -1; //Invalid frequency
    OSC.CTRL=0b01000; //Enable oscillator
 254:	88 e0       	ldi	r24, 0x08	; 8
 256:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
    
	//Wait until XTAL osc is ready
    while (!(OSC.STATUS&0b1000)); 
 25a:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
 25e:	83 ff       	sbrs	r24, 3
 260:	fc cf       	rjmp	.-8      	; 0x25a <SysClkXtal+0xc>
	{
		//Configure PLL
		Mult=F_CPU/F_XTAL;
		if (Mult>31) return -1; //Invalid frequency; too high
		if (F_XTAL * (uint32_t) Mult !=F_CPU) return -1; //Only supports whole dividers
		OSC.PLLCTRL=0b11000000 | (Mult);
 262:	82 ec       	ldi	r24, 0xC2	; 194
 264:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
		OSC.CTRL=0b00011000; //Enable PLL
 268:	88 e1       	ldi	r24, 0x18	; 24
 26a:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
		
		//Wait until PLL is ready
		while (!(OSC.STATUS & 0b00010000));
 26e:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
 272:	84 ff       	sbrs	r24, 4
 274:	fc cf       	rjmp	.-8      	; 0x26e <SysClkXtal+0x20>
		
		//Select PLL as system CLK source
		CCP=0xd8;
 276:	88 ed       	ldi	r24, 0xD8	; 216
 278:	84 bf       	out	0x34, r24	; 52
		CLK.CTRL=0b100;
 27a:	84 e0       	ldi	r24, 0x04	; 4
 27c:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
	}
	return 0;
}
 280:	80 e0       	ldi	r24, 0x00	; 0
 282:	08 95       	ret

00000284 <stdio_putchar>:
}


static int stdio_putchar(char c, FILE * stream)
{
	USART.DATA = c;
 284:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
	while (!(USART.STATUS & 0b01000000));
 288:	e0 ea       	ldi	r30, 0xA0	; 160
 28a:	f9 e0       	ldi	r31, 0x09	; 9
 28c:	81 81       	ldd	r24, Z+1	; 0x01
 28e:	86 ff       	sbrs	r24, 6
 290:	fd cf       	rjmp	.-6      	; 0x28c <stdio_putchar+0x8>
	USART.STATUS=0b01000000;
 292:	80 e4       	ldi	r24, 0x40	; 64
 294:	80 93 a1 09 	sts	0x09A1, r24	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
	return 0;
}
 298:	80 e0       	ldi	r24, 0x00	; 0
 29a:	90 e0       	ldi	r25, 0x00	; 0
 29c:	08 95       	ret

0000029e <stdio_getchar>:
	
static int stdio_getchar(FILE *stream)
{
	while (!(USART.STATUS & 0b10000000));
 29e:	e0 ea       	ldi	r30, 0xA0	; 160
 2a0:	f9 e0       	ldi	r31, 0x09	; 9
 2a2:	81 81       	ldd	r24, Z+1	; 0x01
 2a4:	88 23       	and	r24, r24
 2a6:	ec f7       	brge	.-6      	; 0x2a2 <stdio_getchar+0x4>
	return USART.DATA;
 2a8:	80 91 a0 09 	lds	r24, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
}
 2ac:	90 e0       	ldi	r25, 0x00	; 0
 2ae:	08 95       	ret

000002b0 <USARTInit>:
static int stdio_getchar(FILE *stream);
static FILE UsartStdio = FDEV_SETUP_STREAM(stdio_putchar, stdio_getchar,_FDEV_SETUP_WRITE);

void USARTInit(void)
{
	USART_PORT.DIRSET=0b00001000;	
 2b0:	e0 e6       	ldi	r30, 0x60	; 96
 2b2:	f6 e0       	ldi	r31, 0x06	; 6
 2b4:	88 e0       	ldi	r24, 0x08	; 8
 2b6:	81 83       	std	Z+1, r24	; 0x01
	USART_PORT.DIRCLR=0b00000100;
 2b8:	84 e0       	ldi	r24, 0x04	; 4
 2ba:	82 83       	std	Z+2, r24	; 0x02
	
	USART.CTRLA=0b00000000;
 2bc:	e0 ea       	ldi	r30, 0xA0	; 160
 2be:	f9 e0       	ldi	r31, 0x09	; 9
 2c0:	13 82       	std	Z+3, r1	; 0x03
	USART.CTRLB=0b00011000;
 2c2:	88 e1       	ldi	r24, 0x18	; 24
 2c4:	84 83       	std	Z+4, r24	; 0x04
	USART.CTRLC=0b00000011;
 2c6:	83 e0       	ldi	r24, 0x03	; 3
 2c8:	85 83       	std	Z+5, r24	; 0x05
	
	USART.BAUDCTRLA=0xE5; //BSEL=3301, BSCALE=-5 19200 baud
 2ca:	85 ee       	ldi	r24, 0xE5	; 229
 2cc:	86 83       	std	Z+6, r24	; 0x06
	USART.BAUDCTRLB=0xBC; 
 2ce:	8c eb       	ldi	r24, 0xBC	; 188
 2d0:	87 83       	std	Z+7, r24	; 0x07
	
	stdout=&UsartStdio;
 2d2:	e2 eb       	ldi	r30, 0xB2	; 178
 2d4:	f8 e2       	ldi	r31, 0x28	; 40
 2d6:	80 e0       	ldi	r24, 0x00	; 0
 2d8:	90 e2       	ldi	r25, 0x20	; 32
 2da:	82 83       	std	Z+2, r24	; 0x02
 2dc:	93 83       	std	Z+3, r25	; 0x03
	stdin=&UsartStdio;
 2de:	80 83       	st	Z, r24
 2e0:	91 83       	std	Z+1, r25	; 0x01
 2e2:	08 95       	ret

000002e4 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 2e4:	0f 93       	push	r16
 2e6:	1f 93       	push	r17
 2e8:	cf 93       	push	r28
 2ea:	df 93       	push	r29
 2ec:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
 2ee:	0e 94 ae 05 	call	0xb5c	; 0xb5c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 2f2:	80 91 76 20 	lds	r24, 0x2076	; 0x802076 <__data_end>
 2f6:	81 11       	cpse	r24, r1
 2f8:	1d c0       	rjmp	.+58     	; 0x334 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 2fa:	eb e7       	ldi	r30, 0x7B	; 123
 2fc:	f0 e2       	ldi	r31, 0x20	; 32
 2fe:	80 e8       	ldi	r24, 0x80	; 128
 300:	90 e2       	ldi	r25, 0x20	; 32
 302:	80 83       	st	Z, r24
 304:	91 83       	std	Z+1, r25	; 0x01
	xStart.xBlockSize = ( size_t ) 0;
 306:	12 82       	std	Z+2, r1	; 0x02
 308:	13 82       	std	Z+3, r1	; 0x03

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
 30a:	e7 e7       	ldi	r30, 0x77	; 119
 30c:	f0 e2       	ldi	r31, 0x20	; 32
 30e:	8f ec       	ldi	r24, 0xCF	; 207
 310:	97 e0       	ldi	r25, 0x07	; 7
 312:	82 83       	std	Z+2, r24	; 0x02
 314:	93 83       	std	Z+3, r25	; 0x03
	xEnd.pxNextFreeBlock = NULL;
 316:	10 82       	st	Z, r1
 318:	11 82       	std	Z+1, r1	; 0x01

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
 31a:	af e7       	ldi	r26, 0x7F	; 127
 31c:	b0 e2       	ldi	r27, 0x20	; 32
 31e:	13 96       	adiw	r26, 0x03	; 3
 320:	8d 93       	st	X+, r24
 322:	9c 93       	st	X, r25
 324:	14 97       	sbiw	r26, 0x04	; 4
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
 326:	11 96       	adiw	r26, 0x01	; 1
 328:	ed 93       	st	X+, r30
 32a:	fc 93       	st	X, r31
 32c:	12 97       	sbiw	r26, 0x02	; 2
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
 32e:	81 e0       	ldi	r24, 0x01	; 1
 330:	80 93 76 20 	sts	0x2076, r24	; 0x802076 <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 334:	20 97       	sbiw	r28, 0x00	; 0
 336:	09 f4       	brne	.+2      	; 0x33a <pvPortMalloc+0x56>
 338:	6b c0       	rjmp	.+214    	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
		{
			xWantedSize += heapSTRUCT_SIZE;
 33a:	9e 01       	movw	r18, r28
 33c:	2c 5f       	subi	r18, 0xFC	; 252
 33e:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
 340:	23 96       	adiw	r28, 0x03	; 3
 342:	ce 3c       	cpi	r28, 0xCE	; 206
 344:	d7 40       	sbci	r29, 0x07	; 7
 346:	08 f0       	brcs	.+2      	; 0x34a <pvPortMalloc+0x66>
 348:	60 c0       	rjmp	.+192    	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
 34a:	e0 91 7b 20 	lds	r30, 0x207B	; 0x80207b <xStart>
 34e:	f0 91 7c 20 	lds	r31, 0x207C	; 0x80207c <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 352:	ab e7       	ldi	r26, 0x7B	; 123
 354:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 356:	02 c0       	rjmp	.+4      	; 0x35c <pvPortMalloc+0x78>
 358:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
 35a:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 35c:	82 81       	ldd	r24, Z+2	; 0x02
 35e:	93 81       	ldd	r25, Z+3	; 0x03
 360:	82 17       	cp	r24, r18
 362:	93 07       	cpc	r25, r19
 364:	20 f4       	brcc	.+8      	; 0x36e <pvPortMalloc+0x8a>
 366:	80 81       	ld	r24, Z
 368:	91 81       	ldd	r25, Z+1	; 0x01
 36a:	00 97       	sbiw	r24, 0x00	; 0
 36c:	a9 f7       	brne	.-22     	; 0x358 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 36e:	c0 e2       	ldi	r28, 0x20	; 32
 370:	e7 37       	cpi	r30, 0x77	; 119
 372:	fc 07       	cpc	r31, r28
 374:	09 f4       	brne	.+2      	; 0x378 <pvPortMalloc+0x94>
 376:	49 c0       	rjmp	.+146    	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 378:	cd 91       	ld	r28, X+
 37a:	dc 91       	ld	r29, X
 37c:	11 97       	sbiw	r26, 0x01	; 1
 37e:	8e 01       	movw	r16, r28
 380:	0c 5f       	subi	r16, 0xFC	; 252
 382:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 384:	80 81       	ld	r24, Z
 386:	91 81       	ldd	r25, Z+1	; 0x01
 388:	8d 93       	st	X+, r24
 38a:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 38c:	82 81       	ldd	r24, Z+2	; 0x02
 38e:	93 81       	ldd	r25, Z+3	; 0x03
 390:	82 1b       	sub	r24, r18
 392:	93 0b       	sbc	r25, r19
 394:	89 30       	cpi	r24, 0x09	; 9
 396:	91 05       	cpc	r25, r1
 398:	10 f1       	brcs	.+68     	; 0x3de <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 39a:	bf 01       	movw	r22, r30
 39c:	62 0f       	add	r22, r18
 39e:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 3a0:	db 01       	movw	r26, r22
 3a2:	12 96       	adiw	r26, 0x02	; 2
 3a4:	8d 93       	st	X+, r24
 3a6:	9c 93       	st	X, r25
 3a8:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
 3aa:	22 83       	std	Z+2, r18	; 0x02
 3ac:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 3ae:	12 96       	adiw	r26, 0x02	; 2
 3b0:	4d 91       	ld	r20, X+
 3b2:	5c 91       	ld	r21, X
 3b4:	13 97       	sbiw	r26, 0x03	; 3
 3b6:	8b e7       	ldi	r24, 0x7B	; 123
 3b8:	90 e2       	ldi	r25, 0x20	; 32
 3ba:	01 c0       	rjmp	.+2      	; 0x3be <pvPortMalloc+0xda>
 3bc:	cd 01       	movw	r24, r26
 3be:	ec 01       	movw	r28, r24
 3c0:	a8 81       	ld	r26, Y
 3c2:	b9 81       	ldd	r27, Y+1	; 0x01
 3c4:	12 96       	adiw	r26, 0x02	; 2
 3c6:	2d 91       	ld	r18, X+
 3c8:	3c 91       	ld	r19, X
 3ca:	13 97       	sbiw	r26, 0x03	; 3
 3cc:	24 17       	cp	r18, r20
 3ce:	35 07       	cpc	r19, r21
 3d0:	a8 f3       	brcs	.-22     	; 0x3bc <pvPortMalloc+0xd8>
 3d2:	eb 01       	movw	r28, r22
 3d4:	a8 83       	st	Y, r26
 3d6:	b9 83       	std	Y+1, r27	; 0x01
 3d8:	dc 01       	movw	r26, r24
 3da:	6d 93       	st	X+, r22
 3dc:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 3de:	80 91 0e 20 	lds	r24, 0x200E	; 0x80200e <xFreeBytesRemaining>
 3e2:	90 91 0f 20 	lds	r25, 0x200F	; 0x80200f <xFreeBytesRemaining+0x1>
 3e6:	22 81       	ldd	r18, Z+2	; 0x02
 3e8:	33 81       	ldd	r19, Z+3	; 0x03
 3ea:	82 1b       	sub	r24, r18
 3ec:	93 0b       	sbc	r25, r19
 3ee:	80 93 0e 20 	sts	0x200E, r24	; 0x80200e <xFreeBytesRemaining>
 3f2:	90 93 0f 20 	sts	0x200F, r25	; 0x80200f <xFreeBytesRemaining+0x1>
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 3f6:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
 3fa:	01 15       	cp	r16, r1
 3fc:	11 05       	cpc	r17, r1
 3fe:	59 f4       	brne	.+22     	; 0x416 <__LOCK_REGION_LENGTH__+0x16>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
 400:	0e 94 9f 07 	call	0xf3e	; 0xf3e <vApplicationMallocFailedHook>
 404:	00 e0       	ldi	r16, 0x00	; 0
 406:	10 e0       	ldi	r17, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
 408:	06 c0       	rjmp	.+12     	; 0x416 <__LOCK_REGION_LENGTH__+0x16>
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 40a:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <xTaskResumeAll>
 40e:	f8 cf       	rjmp	.-16     	; 0x400 <__LOCK_REGION_LENGTH__>
 410:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <xTaskResumeAll>
 414:	f5 cf       	rjmp	.-22     	; 0x400 <__LOCK_REGION_LENGTH__>
		}
	}
	#endif

	return pvReturn;
}
 416:	c8 01       	movw	r24, r16
 418:	df 91       	pop	r29
 41a:	cf 91       	pop	r28
 41c:	1f 91       	pop	r17
 41e:	0f 91       	pop	r16
 420:	08 95       	ret

00000422 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 422:	0f 93       	push	r16
 424:	1f 93       	push	r17
 426:	cf 93       	push	r28
 428:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
 42a:	00 97       	sbiw	r24, 0x00	; 0
 42c:	41 f1       	breq	.+80     	; 0x47e <vPortFree+0x5c>
 42e:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 430:	8c 01       	movw	r16, r24
 432:	04 50       	subi	r16, 0x04	; 4
 434:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
 436:	0e 94 ae 05 	call	0xb5c	; 0xb5c <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 43a:	f8 01       	movw	r30, r16
 43c:	42 81       	ldd	r20, Z+2	; 0x02
 43e:	53 81       	ldd	r21, Z+3	; 0x03
 440:	ab e7       	ldi	r26, 0x7B	; 123
 442:	b0 e2       	ldi	r27, 0x20	; 32
 444:	01 c0       	rjmp	.+2      	; 0x448 <vPortFree+0x26>
 446:	df 01       	movw	r26, r30
 448:	ed 91       	ld	r30, X+
 44a:	fc 91       	ld	r31, X
 44c:	11 97       	sbiw	r26, 0x01	; 1
 44e:	22 81       	ldd	r18, Z+2	; 0x02
 450:	33 81       	ldd	r19, Z+3	; 0x03
 452:	24 17       	cp	r18, r20
 454:	35 07       	cpc	r19, r21
 456:	b8 f3       	brcs	.-18     	; 0x446 <vPortFree+0x24>
 458:	24 97       	sbiw	r28, 0x04	; 4
 45a:	e8 83       	st	Y, r30
 45c:	f9 83       	std	Y+1, r31	; 0x01
 45e:	0d 93       	st	X+, r16
 460:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
 462:	20 91 0e 20 	lds	r18, 0x200E	; 0x80200e <xFreeBytesRemaining>
 466:	30 91 0f 20 	lds	r19, 0x200F	; 0x80200f <xFreeBytesRemaining+0x1>
 46a:	8a 81       	ldd	r24, Y+2	; 0x02
 46c:	9b 81       	ldd	r25, Y+3	; 0x03
 46e:	82 0f       	add	r24, r18
 470:	93 1f       	adc	r25, r19
 472:	80 93 0e 20 	sts	0x200E, r24	; 0x80200e <xFreeBytesRemaining>
 476:	90 93 0f 20 	sts	0x200F, r25	; 0x80200f <xFreeBytesRemaining+0x1>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
 47a:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <xTaskResumeAll>
	}
}
 47e:	df 91       	pop	r29
 480:	cf 91       	pop	r28
 482:	1f 91       	pop	r17
 484:	0f 91       	pop	r16
 486:	08 95       	ret

00000488 <vListInitialise>:
	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
}
 488:	fc 01       	movw	r30, r24
 48a:	03 96       	adiw	r24, 0x03	; 3
 48c:	81 83       	std	Z+1, r24	; 0x01
 48e:	92 83       	std	Z+2, r25	; 0x02
 490:	2f ef       	ldi	r18, 0xFF	; 255
 492:	3f ef       	ldi	r19, 0xFF	; 255
 494:	23 83       	std	Z+3, r18	; 0x03
 496:	34 83       	std	Z+4, r19	; 0x04
 498:	85 83       	std	Z+5, r24	; 0x05
 49a:	96 83       	std	Z+6, r25	; 0x06
 49c:	87 83       	std	Z+7, r24	; 0x07
 49e:	90 87       	std	Z+8, r25	; 0x08
 4a0:	10 82       	st	Z, r1
 4a2:	08 95       	ret

000004a4 <vListInitialiseItem>:
 4a4:	fc 01       	movw	r30, r24
 4a6:	10 86       	std	Z+8, r1	; 0x08
 4a8:	11 86       	std	Z+9, r1	; 0x09
 4aa:	08 95       	ret

000004ac <vListInsertEnd>:
 4ac:	cf 93       	push	r28
 4ae:	df 93       	push	r29
 4b0:	9c 01       	movw	r18, r24
 4b2:	fb 01       	movw	r30, r22
 4b4:	dc 01       	movw	r26, r24
 4b6:	11 96       	adiw	r26, 0x01	; 1
 4b8:	cd 91       	ld	r28, X+
 4ba:	dc 91       	ld	r29, X
 4bc:	12 97       	sbiw	r26, 0x02	; 2
 4be:	c2 83       	std	Z+2, r28	; 0x02
 4c0:	d3 83       	std	Z+3, r29	; 0x03
 4c2:	8c 81       	ldd	r24, Y+4	; 0x04
 4c4:	9d 81       	ldd	r25, Y+5	; 0x05
 4c6:	84 83       	std	Z+4, r24	; 0x04
 4c8:	95 83       	std	Z+5, r25	; 0x05
 4ca:	8c 81       	ldd	r24, Y+4	; 0x04
 4cc:	9d 81       	ldd	r25, Y+5	; 0x05
 4ce:	dc 01       	movw	r26, r24
 4d0:	12 96       	adiw	r26, 0x02	; 2
 4d2:	6d 93       	st	X+, r22
 4d4:	7c 93       	st	X, r23
 4d6:	13 97       	sbiw	r26, 0x03	; 3
 4d8:	6c 83       	std	Y+4, r22	; 0x04
 4da:	7d 83       	std	Y+5, r23	; 0x05
 4dc:	20 87       	std	Z+8, r18	; 0x08
 4de:	31 87       	std	Z+9, r19	; 0x09
 4e0:	f9 01       	movw	r30, r18
 4e2:	80 81       	ld	r24, Z
 4e4:	8f 5f       	subi	r24, 0xFF	; 255
 4e6:	80 83       	st	Z, r24
 4e8:	df 91       	pop	r29
 4ea:	cf 91       	pop	r28
 4ec:	08 95       	ret

000004ee <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 4ee:	cf 93       	push	r28
 4f0:	df 93       	push	r29
 4f2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 4f4:	a0 85       	ldd	r26, Z+8	; 0x08
 4f6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 4f8:	c2 81       	ldd	r28, Z+2	; 0x02
 4fa:	d3 81       	ldd	r29, Z+3	; 0x03
 4fc:	84 81       	ldd	r24, Z+4	; 0x04
 4fe:	95 81       	ldd	r25, Z+5	; 0x05
 500:	8c 83       	std	Y+4, r24	; 0x04
 502:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 504:	c4 81       	ldd	r28, Z+4	; 0x04
 506:	d5 81       	ldd	r29, Z+5	; 0x05
 508:	82 81       	ldd	r24, Z+2	; 0x02
 50a:	93 81       	ldd	r25, Z+3	; 0x03
 50c:	8a 83       	std	Y+2, r24	; 0x02
 50e:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 510:	11 96       	adiw	r26, 0x01	; 1
 512:	8d 91       	ld	r24, X+
 514:	9c 91       	ld	r25, X
 516:	12 97       	sbiw	r26, 0x02	; 2
 518:	e8 17       	cp	r30, r24
 51a:	f9 07       	cpc	r31, r25
 51c:	31 f4       	brne	.+12     	; 0x52a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 51e:	84 81       	ldd	r24, Z+4	; 0x04
 520:	95 81       	ldd	r25, Z+5	; 0x05
 522:	11 96       	adiw	r26, 0x01	; 1
 524:	8d 93       	st	X+, r24
 526:	9c 93       	st	X, r25
 528:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 52a:	10 86       	std	Z+8, r1	; 0x08
 52c:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
 52e:	8c 91       	ld	r24, X
 530:	81 50       	subi	r24, 0x01	; 1
 532:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
 534:	8c 91       	ld	r24, X
}
 536:	df 91       	pop	r29
 538:	cf 91       	pop	r28
 53a:	08 95       	ret

0000053c <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 53c:	31 e1       	ldi	r19, 0x11	; 17
 53e:	fc 01       	movw	r30, r24
 540:	30 83       	st	Z, r19
 542:	31 97       	sbiw	r30, 0x01	; 1
 544:	22 e2       	ldi	r18, 0x22	; 34
 546:	20 83       	st	Z, r18
 548:	31 97       	sbiw	r30, 0x01	; 1
 54a:	a3 e3       	ldi	r26, 0x33	; 51
 54c:	a0 83       	st	Z, r26
 54e:	31 97       	sbiw	r30, 0x01	; 1
 550:	60 83       	st	Z, r22
 552:	31 97       	sbiw	r30, 0x01	; 1
 554:	70 83       	st	Z, r23
 556:	31 97       	sbiw	r30, 0x01	; 1
 558:	10 82       	st	Z, r1
 55a:	31 97       	sbiw	r30, 0x01	; 1
 55c:	10 82       	st	Z, r1
 55e:	31 97       	sbiw	r30, 0x01	; 1
 560:	60 e8       	ldi	r22, 0x80	; 128
 562:	60 83       	st	Z, r22
 564:	31 97       	sbiw	r30, 0x01	; 1
 566:	10 82       	st	Z, r1
 568:	31 97       	sbiw	r30, 0x01	; 1
 56a:	62 e0       	ldi	r22, 0x02	; 2
 56c:	60 83       	st	Z, r22
 56e:	31 97       	sbiw	r30, 0x01	; 1
 570:	63 e0       	ldi	r22, 0x03	; 3
 572:	60 83       	st	Z, r22
 574:	31 97       	sbiw	r30, 0x01	; 1
 576:	64 e0       	ldi	r22, 0x04	; 4
 578:	60 83       	st	Z, r22
 57a:	31 97       	sbiw	r30, 0x01	; 1
 57c:	65 e0       	ldi	r22, 0x05	; 5
 57e:	60 83       	st	Z, r22
 580:	31 97       	sbiw	r30, 0x01	; 1
 582:	66 e0       	ldi	r22, 0x06	; 6
 584:	60 83       	st	Z, r22
 586:	31 97       	sbiw	r30, 0x01	; 1
 588:	67 e0       	ldi	r22, 0x07	; 7
 58a:	60 83       	st	Z, r22
 58c:	31 97       	sbiw	r30, 0x01	; 1
 58e:	68 e0       	ldi	r22, 0x08	; 8
 590:	60 83       	st	Z, r22
 592:	31 97       	sbiw	r30, 0x01	; 1
 594:	69 e0       	ldi	r22, 0x09	; 9
 596:	60 83       	st	Z, r22
 598:	31 97       	sbiw	r30, 0x01	; 1
 59a:	60 e1       	ldi	r22, 0x10	; 16
 59c:	60 83       	st	Z, r22
 59e:	31 97       	sbiw	r30, 0x01	; 1
 5a0:	30 83       	st	Z, r19
 5a2:	31 97       	sbiw	r30, 0x01	; 1
 5a4:	32 e1       	ldi	r19, 0x12	; 18
 5a6:	30 83       	st	Z, r19
 5a8:	31 97       	sbiw	r30, 0x01	; 1
 5aa:	33 e1       	ldi	r19, 0x13	; 19
 5ac:	30 83       	st	Z, r19
 5ae:	31 97       	sbiw	r30, 0x01	; 1
 5b0:	34 e1       	ldi	r19, 0x14	; 20
 5b2:	30 83       	st	Z, r19
 5b4:	31 97       	sbiw	r30, 0x01	; 1
 5b6:	35 e1       	ldi	r19, 0x15	; 21
 5b8:	30 83       	st	Z, r19
 5ba:	31 97       	sbiw	r30, 0x01	; 1
 5bc:	36 e1       	ldi	r19, 0x16	; 22
 5be:	30 83       	st	Z, r19
 5c0:	31 97       	sbiw	r30, 0x01	; 1
 5c2:	37 e1       	ldi	r19, 0x17	; 23
 5c4:	30 83       	st	Z, r19
 5c6:	31 97       	sbiw	r30, 0x01	; 1
 5c8:	38 e1       	ldi	r19, 0x18	; 24
 5ca:	30 83       	st	Z, r19
 5cc:	31 97       	sbiw	r30, 0x01	; 1
 5ce:	39 e1       	ldi	r19, 0x19	; 25
 5d0:	30 83       	st	Z, r19
 5d2:	31 97       	sbiw	r30, 0x01	; 1
 5d4:	30 e2       	ldi	r19, 0x20	; 32
 5d6:	30 83       	st	Z, r19
 5d8:	31 97       	sbiw	r30, 0x01	; 1
 5da:	31 e2       	ldi	r19, 0x21	; 33
 5dc:	30 83       	st	Z, r19
 5de:	31 97       	sbiw	r30, 0x01	; 1
 5e0:	20 83       	st	Z, r18
 5e2:	31 97       	sbiw	r30, 0x01	; 1
 5e4:	23 e2       	ldi	r18, 0x23	; 35
 5e6:	20 83       	st	Z, r18
 5e8:	31 97       	sbiw	r30, 0x01	; 1
 5ea:	40 83       	st	Z, r20
 5ec:	31 97       	sbiw	r30, 0x01	; 1
 5ee:	50 83       	st	Z, r21
 5f0:	31 97       	sbiw	r30, 0x01	; 1
 5f2:	26 e2       	ldi	r18, 0x26	; 38
 5f4:	20 83       	st	Z, r18
 5f6:	31 97       	sbiw	r30, 0x01	; 1
 5f8:	27 e2       	ldi	r18, 0x27	; 39
 5fa:	20 83       	st	Z, r18
 5fc:	31 97       	sbiw	r30, 0x01	; 1
 5fe:	28 e2       	ldi	r18, 0x28	; 40
 600:	20 83       	st	Z, r18
 602:	31 97       	sbiw	r30, 0x01	; 1
 604:	29 e2       	ldi	r18, 0x29	; 41
 606:	20 83       	st	Z, r18
 608:	31 97       	sbiw	r30, 0x01	; 1
 60a:	20 e3       	ldi	r18, 0x30	; 48
 60c:	20 83       	st	Z, r18
 60e:	31 97       	sbiw	r30, 0x01	; 1
 610:	21 e3       	ldi	r18, 0x31	; 49
 612:	20 83       	st	Z, r18
 614:	87 97       	sbiw	r24, 0x27	; 39
 616:	08 95       	ret

00000618 <xPortStartScheduler>:
 618:	e0 e0       	ldi	r30, 0x00	; 0
 61a:	f8 e0       	ldi	r31, 0x08	; 8
 61c:	81 e0       	ldi	r24, 0x01	; 1
 61e:	80 83       	st	Z, r24
 620:	86 83       	std	Z+6, r24	; 0x06
 622:	80 e0       	ldi	r24, 0x00	; 0
 624:	9d e7       	ldi	r25, 0x7D	; 125
 626:	86 a3       	std	Z+38, r24	; 0x26
 628:	97 a3       	std	Z+39, r25	; 0x27
 62a:	a0 91 ae 28 	lds	r26, 0x28AE	; 0x8028ae <pxCurrentTCB>
 62e:	b0 91 af 28 	lds	r27, 0x28AF	; 0x8028af <pxCurrentTCB+0x1>
 632:	cd 91       	ld	r28, X+
 634:	cd bf       	out	0x3d, r28	; 61
 636:	dd 91       	ld	r29, X+
 638:	de bf       	out	0x3e, r29	; 62
 63a:	ff 91       	pop	r31
 63c:	ef 91       	pop	r30
 63e:	df 91       	pop	r29
 640:	cf 91       	pop	r28
 642:	bf 91       	pop	r27
 644:	af 91       	pop	r26
 646:	9f 91       	pop	r25
 648:	8f 91       	pop	r24
 64a:	7f 91       	pop	r23
 64c:	6f 91       	pop	r22
 64e:	5f 91       	pop	r21
 650:	4f 91       	pop	r20
 652:	3f 91       	pop	r19
 654:	2f 91       	pop	r18
 656:	1f 91       	pop	r17
 658:	0f 91       	pop	r16
 65a:	ff 90       	pop	r15
 65c:	ef 90       	pop	r14
 65e:	df 90       	pop	r13
 660:	cf 90       	pop	r12
 662:	bf 90       	pop	r11
 664:	af 90       	pop	r10
 666:	9f 90       	pop	r9
 668:	8f 90       	pop	r8
 66a:	7f 90       	pop	r7
 66c:	6f 90       	pop	r6
 66e:	5f 90       	pop	r5
 670:	4f 90       	pop	r4
 672:	3f 90       	pop	r3
 674:	2f 90       	pop	r2
 676:	1f 90       	pop	r1
 678:	0f 90       	pop	r0
 67a:	0f be       	out	0x3f, r0	; 63
 67c:	0f 90       	pop	r0
 67e:	08 95       	ret
 680:	81 e0       	ldi	r24, 0x01	; 1
 682:	08 95       	ret

00000684 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 684:	0f 92       	push	r0
 686:	0f b6       	in	r0, 0x3f	; 63
 688:	f8 94       	cli
 68a:	0f 92       	push	r0
 68c:	1f 92       	push	r1
 68e:	11 24       	eor	r1, r1
 690:	2f 92       	push	r2
 692:	3f 92       	push	r3
 694:	4f 92       	push	r4
 696:	5f 92       	push	r5
 698:	6f 92       	push	r6
 69a:	7f 92       	push	r7
 69c:	8f 92       	push	r8
 69e:	9f 92       	push	r9
 6a0:	af 92       	push	r10
 6a2:	bf 92       	push	r11
 6a4:	cf 92       	push	r12
 6a6:	df 92       	push	r13
 6a8:	ef 92       	push	r14
 6aa:	ff 92       	push	r15
 6ac:	0f 93       	push	r16
 6ae:	1f 93       	push	r17
 6b0:	2f 93       	push	r18
 6b2:	3f 93       	push	r19
 6b4:	4f 93       	push	r20
 6b6:	5f 93       	push	r21
 6b8:	6f 93       	push	r22
 6ba:	7f 93       	push	r23
 6bc:	8f 93       	push	r24
 6be:	9f 93       	push	r25
 6c0:	af 93       	push	r26
 6c2:	bf 93       	push	r27
 6c4:	cf 93       	push	r28
 6c6:	df 93       	push	r29
 6c8:	ef 93       	push	r30
 6ca:	ff 93       	push	r31
 6cc:	a0 91 ae 28 	lds	r26, 0x28AE	; 0x8028ae <pxCurrentTCB>
 6d0:	b0 91 af 28 	lds	r27, 0x28AF	; 0x8028af <pxCurrentTCB+0x1>
 6d4:	0d b6       	in	r0, 0x3d	; 61
 6d6:	0d 92       	st	X+, r0
 6d8:	0e b6       	in	r0, 0x3e	; 62
 6da:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 6dc:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 6e0:	a0 91 ae 28 	lds	r26, 0x28AE	; 0x8028ae <pxCurrentTCB>
 6e4:	b0 91 af 28 	lds	r27, 0x28AF	; 0x8028af <pxCurrentTCB+0x1>
 6e8:	cd 91       	ld	r28, X+
 6ea:	cd bf       	out	0x3d, r28	; 61
 6ec:	dd 91       	ld	r29, X+
 6ee:	de bf       	out	0x3e, r29	; 62
 6f0:	ff 91       	pop	r31
 6f2:	ef 91       	pop	r30
 6f4:	df 91       	pop	r29
 6f6:	cf 91       	pop	r28
 6f8:	bf 91       	pop	r27
 6fa:	af 91       	pop	r26
 6fc:	9f 91       	pop	r25
 6fe:	8f 91       	pop	r24
 700:	7f 91       	pop	r23
 702:	6f 91       	pop	r22
 704:	5f 91       	pop	r21
 706:	4f 91       	pop	r20
 708:	3f 91       	pop	r19
 70a:	2f 91       	pop	r18
 70c:	1f 91       	pop	r17
 70e:	0f 91       	pop	r16
 710:	ff 90       	pop	r15
 712:	ef 90       	pop	r14
 714:	df 90       	pop	r13
 716:	cf 90       	pop	r12
 718:	bf 90       	pop	r11
 71a:	af 90       	pop	r10
 71c:	9f 90       	pop	r9
 71e:	8f 90       	pop	r8
 720:	7f 90       	pop	r7
 722:	6f 90       	pop	r6
 724:	5f 90       	pop	r5
 726:	4f 90       	pop	r4
 728:	3f 90       	pop	r3
 72a:	2f 90       	pop	r2
 72c:	1f 90       	pop	r1
 72e:	0f 90       	pop	r0
 730:	0f be       	out	0x3f, r0	; 63
 732:	0f 90       	pop	r0

	asm volatile ( "ret" );
 734:	08 95       	ret

00000736 <__vector_14>:
	 * the context is saved at the start of the ISR.  The tick
	 * count is incremented after the context is saved.
	 */	
	ISR(TCC0_OVF_vect,ISR_NAKED)
	{
		portSAVE_CONTEXT();
 736:	0f 92       	push	r0
 738:	0f b6       	in	r0, 0x3f	; 63
 73a:	f8 94       	cli
 73c:	0f 92       	push	r0
 73e:	1f 92       	push	r1
 740:	11 24       	eor	r1, r1
 742:	2f 92       	push	r2
 744:	3f 92       	push	r3
 746:	4f 92       	push	r4
 748:	5f 92       	push	r5
 74a:	6f 92       	push	r6
 74c:	7f 92       	push	r7
 74e:	8f 92       	push	r8
 750:	9f 92       	push	r9
 752:	af 92       	push	r10
 754:	bf 92       	push	r11
 756:	cf 92       	push	r12
 758:	df 92       	push	r13
 75a:	ef 92       	push	r14
 75c:	ff 92       	push	r15
 75e:	0f 93       	push	r16
 760:	1f 93       	push	r17
 762:	2f 93       	push	r18
 764:	3f 93       	push	r19
 766:	4f 93       	push	r20
 768:	5f 93       	push	r21
 76a:	6f 93       	push	r22
 76c:	7f 93       	push	r23
 76e:	8f 93       	push	r24
 770:	9f 93       	push	r25
 772:	af 93       	push	r26
 774:	bf 93       	push	r27
 776:	cf 93       	push	r28
 778:	df 93       	push	r29
 77a:	ef 93       	push	r30
 77c:	ff 93       	push	r31
 77e:	a0 91 ae 28 	lds	r26, 0x28AE	; 0x8028ae <pxCurrentTCB>
 782:	b0 91 af 28 	lds	r27, 0x28AF	; 0x8028af <pxCurrentTCB+0x1>
 786:	0d b6       	in	r0, 0x3d	; 61
 788:	0d 92       	st	X+, r0
 78a:	0e b6       	in	r0, 0x3e	; 62
 78c:	0d 92       	st	X+, r0
		xTaskIncrementTick();
 78e:	0e 94 b4 05 	call	0xb68	; 0xb68 <xTaskIncrementTick>
		vTaskSwitchContext();
 792:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <vTaskSwitchContext>
		portRESTORE_CONTEXT();
 796:	a0 91 ae 28 	lds	r26, 0x28AE	; 0x8028ae <pxCurrentTCB>
 79a:	b0 91 af 28 	lds	r27, 0x28AF	; 0x8028af <pxCurrentTCB+0x1>
 79e:	cd 91       	ld	r28, X+
 7a0:	cd bf       	out	0x3d, r28	; 61
 7a2:	dd 91       	ld	r29, X+
 7a4:	de bf       	out	0x3e, r29	; 62
 7a6:	ff 91       	pop	r31
 7a8:	ef 91       	pop	r30
 7aa:	df 91       	pop	r29
 7ac:	cf 91       	pop	r28
 7ae:	bf 91       	pop	r27
 7b0:	af 91       	pop	r26
 7b2:	9f 91       	pop	r25
 7b4:	8f 91       	pop	r24
 7b6:	7f 91       	pop	r23
 7b8:	6f 91       	pop	r22
 7ba:	5f 91       	pop	r21
 7bc:	4f 91       	pop	r20
 7be:	3f 91       	pop	r19
 7c0:	2f 91       	pop	r18
 7c2:	1f 91       	pop	r17
 7c4:	0f 91       	pop	r16
 7c6:	ff 90       	pop	r15
 7c8:	ef 90       	pop	r14
 7ca:	df 90       	pop	r13
 7cc:	cf 90       	pop	r12
 7ce:	bf 90       	pop	r11
 7d0:	af 90       	pop	r10
 7d2:	9f 90       	pop	r9
 7d4:	8f 90       	pop	r8
 7d6:	7f 90       	pop	r7
 7d8:	6f 90       	pop	r6
 7da:	5f 90       	pop	r5
 7dc:	4f 90       	pop	r4
 7de:	3f 90       	pop	r3
 7e0:	2f 90       	pop	r2
 7e2:	1f 90       	pop	r1
 7e4:	0f 90       	pop	r0
 7e6:	0f be       	out	0x3f, r0	; 63
 7e8:	0f 90       	pop	r0
		asm volatile ( "reti" );
 7ea:	18 95       	reti

000007ec <vConfigureTimerForRunTimeStats>:
volatile uint16_t StatsTimer;

void vConfigureTimerForRunTimeStats(void)
{
	//TCE0 is used as stats timer
	TCE0.CTRLA=0b0111; //DIV1024	
 7ec:	e0 e0       	ldi	r30, 0x00	; 0
 7ee:	fa e0       	ldi	r31, 0x0A	; 10
 7f0:	87 e0       	ldi	r24, 0x07	; 7
 7f2:	80 83       	st	Z, r24
	TCE0.INTCTRLA=0b00000001; //OVF priority LOW
 7f4:	81 e0       	ldi	r24, 0x01	; 1
 7f6:	86 83       	std	Z+6, r24	; 0x06
 7f8:	08 95       	ret

000007fa <__vector_47>:
}

ISR(TCE0_OVF_vect)
{
 7fa:	1f 92       	push	r1
 7fc:	0f 92       	push	r0
 7fe:	0f b6       	in	r0, 0x3f	; 63
 800:	0f 92       	push	r0
 802:	11 24       	eor	r1, r1
 804:	8f 93       	push	r24
 806:	9f 93       	push	r25
	StatsTimer++;
 808:	80 91 b0 28 	lds	r24, 0x28B0	; 0x8028b0 <StatsTimer>
 80c:	90 91 b1 28 	lds	r25, 0x28B1	; 0x8028b1 <StatsTimer+0x1>
 810:	01 96       	adiw	r24, 0x01	; 1
 812:	80 93 b0 28 	sts	0x28B0, r24	; 0x8028b0 <StatsTimer>
 816:	90 93 b1 28 	sts	0x28B1, r25	; 0x8028b1 <StatsTimer+0x1>
}
 81a:	9f 91       	pop	r25
 81c:	8f 91       	pop	r24
 81e:	0f 90       	pop	r0
 820:	0f be       	out	0x3f, r0	; 63
 822:	0f 90       	pop	r0
 824:	1f 90       	pop	r1
 826:	18 95       	reti

00000828 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 828:	e0 91 76 28 	lds	r30, 0x2876	; 0x802876 <pxDelayedTaskList>
 82c:	f0 91 77 28 	lds	r31, 0x2877	; 0x802877 <pxDelayedTaskList+0x1>
 830:	80 81       	ld	r24, Z
 832:	81 11       	cpse	r24, r1
 834:	07 c0       	rjmp	.+14     	; 0x844 <prvResetNextTaskUnblockTime+0x1c>
 836:	8f ef       	ldi	r24, 0xFF	; 255
 838:	9f ef       	ldi	r25, 0xFF	; 255
 83a:	80 93 56 28 	sts	0x2856, r24	; 0x802856 <xNextTaskUnblockTime>
 83e:	90 93 57 28 	sts	0x2857, r25	; 0x802857 <xNextTaskUnblockTime+0x1>
 842:	08 95       	ret
 844:	e0 91 76 28 	lds	r30, 0x2876	; 0x802876 <pxDelayedTaskList>
 848:	f0 91 77 28 	lds	r31, 0x2877	; 0x802877 <pxDelayedTaskList+0x1>
 84c:	05 80       	ldd	r0, Z+5	; 0x05
 84e:	f6 81       	ldd	r31, Z+6	; 0x06
 850:	e0 2d       	mov	r30, r0
 852:	06 80       	ldd	r0, Z+6	; 0x06
 854:	f7 81       	ldd	r31, Z+7	; 0x07
 856:	e0 2d       	mov	r30, r0
 858:	82 81       	ldd	r24, Z+2	; 0x02
 85a:	93 81       	ldd	r25, Z+3	; 0x03
 85c:	80 93 56 28 	sts	0x2856, r24	; 0x802856 <xNextTaskUnblockTime>
 860:	90 93 57 28 	sts	0x2857, r25	; 0x802857 <xNextTaskUnblockTime+0x1>
 864:	08 95       	ret

00000866 <prvIdleTask>:
 866:	02 e6       	ldi	r16, 0x62	; 98
 868:	18 e2       	ldi	r17, 0x28	; 40
 86a:	0f 2e       	mov	r0, r31
 86c:	fa e8       	ldi	r31, 0x8A	; 138
 86e:	ef 2e       	mov	r14, r31
 870:	f8 e2       	ldi	r31, 0x28	; 40
 872:	ff 2e       	mov	r15, r31
 874:	f0 2d       	mov	r31, r0
 876:	80 91 61 28 	lds	r24, 0x2861	; 0x802861 <uxDeletedTasksWaitingCleanUp>
 87a:	88 23       	and	r24, r24
 87c:	29 f1       	breq	.+74     	; 0x8c8 <prvIdleTask+0x62>
 87e:	0f b6       	in	r0, 0x3f	; 63
 880:	f8 94       	cli
 882:	0f 92       	push	r0
 884:	d8 01       	movw	r26, r16
 886:	15 96       	adiw	r26, 0x05	; 5
 888:	ed 91       	ld	r30, X+
 88a:	fc 91       	ld	r31, X
 88c:	16 97       	sbiw	r26, 0x06	; 6
 88e:	c6 81       	ldd	r28, Z+6	; 0x06
 890:	d7 81       	ldd	r29, Z+7	; 0x07
 892:	ce 01       	movw	r24, r28
 894:	02 96       	adiw	r24, 0x02	; 2
 896:	0e 94 77 02 	call	0x4ee	; 0x4ee <uxListRemove>
 89a:	80 91 60 28 	lds	r24, 0x2860	; 0x802860 <uxCurrentNumberOfTasks>
 89e:	81 50       	subi	r24, 0x01	; 1
 8a0:	80 93 60 28 	sts	0x2860, r24	; 0x802860 <uxCurrentNumberOfTasks>
 8a4:	80 91 61 28 	lds	r24, 0x2861	; 0x802861 <uxDeletedTasksWaitingCleanUp>
 8a8:	81 50       	subi	r24, 0x01	; 1
 8aa:	80 93 61 28 	sts	0x2861, r24	; 0x802861 <uxDeletedTasksWaitingCleanUp>
 8ae:	0f 90       	pop	r0
 8b0:	0f be       	out	0x3f, r0	; 63
 8b2:	8f 89       	ldd	r24, Y+23	; 0x17
 8b4:	98 8d       	ldd	r25, Y+24	; 0x18
 8b6:	0e 94 11 02 	call	0x422	; 0x422 <vPortFree>
 8ba:	ce 01       	movw	r24, r28
 8bc:	0e 94 11 02 	call	0x422	; 0x422 <vPortFree>
 8c0:	80 91 61 28 	lds	r24, 0x2861	; 0x802861 <uxDeletedTasksWaitingCleanUp>
 8c4:	81 11       	cpse	r24, r1
 8c6:	db cf       	rjmp	.-74     	; 0x87e <prvIdleTask+0x18>
 8c8:	f7 01       	movw	r30, r14
 8ca:	80 81       	ld	r24, Z
 8cc:	82 30       	cpi	r24, 0x02	; 2
 8ce:	10 f0       	brcs	.+4      	; 0x8d4 <prvIdleTask+0x6e>
 8d0:	0e 94 42 03 	call	0x684	; 0x684 <vPortYield>
 8d4:	0e 94 a4 07 	call	0xf48	; 0xf48 <vApplicationIdleHook>
 8d8:	ce cf       	rjmp	.-100    	; 0x876 <prvIdleTask+0x10>

000008da <xTaskCreate>:
 8da:	4f 92       	push	r4
 8dc:	5f 92       	push	r5
 8de:	6f 92       	push	r6
 8e0:	7f 92       	push	r7
 8e2:	8f 92       	push	r8
 8e4:	9f 92       	push	r9
 8e6:	af 92       	push	r10
 8e8:	bf 92       	push	r11
 8ea:	cf 92       	push	r12
 8ec:	df 92       	push	r13
 8ee:	ef 92       	push	r14
 8f0:	ff 92       	push	r15
 8f2:	0f 93       	push	r16
 8f4:	cf 93       	push	r28
 8f6:	df 93       	push	r29
 8f8:	4c 01       	movw	r8, r24
 8fa:	6b 01       	movw	r12, r22
 8fc:	5a 01       	movw	r10, r20
 8fe:	29 01       	movw	r4, r18
 900:	ca 01       	movw	r24, r20
 902:	0e 94 72 01 	call	0x2e4	; 0x2e4 <pvPortMalloc>
 906:	3c 01       	movw	r6, r24
 908:	89 2b       	or	r24, r25
 90a:	09 f4       	brne	.+2      	; 0x90e <xTaskCreate+0x34>
 90c:	ea c0       	rjmp	.+468    	; 0xae2 <xTaskCreate+0x208>
 90e:	8c e2       	ldi	r24, 0x2C	; 44
 910:	90 e0       	ldi	r25, 0x00	; 0
 912:	0e 94 72 01 	call	0x2e4	; 0x2e4 <pvPortMalloc>
 916:	ec 01       	movw	r28, r24
 918:	89 2b       	or	r24, r25
 91a:	b1 f0       	breq	.+44     	; 0x948 <xTaskCreate+0x6e>
 91c:	6f 8a       	std	Y+23, r6	; 0x17
 91e:	78 8e       	std	Y+24, r7	; 0x18
 920:	a5 01       	movw	r20, r10
 922:	65 ea       	ldi	r22, 0xA5	; 165
 924:	70 e0       	ldi	r23, 0x00	; 0
 926:	c3 01       	movw	r24, r6
 928:	0e 94 b2 07 	call	0xf64	; 0xf64 <memset>
 92c:	81 e0       	ldi	r24, 0x01	; 1
 92e:	a8 1a       	sub	r10, r24
 930:	b1 08       	sbc	r11, r1
 932:	8f 89       	ldd	r24, Y+23	; 0x17
 934:	98 8d       	ldd	r25, Y+24	; 0x18
 936:	a8 0e       	add	r10, r24
 938:	b9 1e       	adc	r11, r25
 93a:	d6 01       	movw	r26, r12
 93c:	8c 91       	ld	r24, X
 93e:	89 8f       	std	Y+25, r24	; 0x19
 940:	8c 91       	ld	r24, X
 942:	81 11       	cpse	r24, r1
 944:	05 c0       	rjmp	.+10     	; 0x950 <xTaskCreate+0x76>
 946:	18 c0       	rjmp	.+48     	; 0x978 <xTaskCreate+0x9e>
 948:	c3 01       	movw	r24, r6
 94a:	0e 94 11 02 	call	0x422	; 0x422 <vPortFree>
 94e:	c9 c0       	rjmp	.+402    	; 0xae2 <xTaskCreate+0x208>
 950:	ae 01       	movw	r20, r28
 952:	46 5e       	subi	r20, 0xE6	; 230
 954:	5f 4f       	sbci	r21, 0xFF	; 255
 956:	f6 01       	movw	r30, r12
 958:	31 96       	adiw	r30, 0x01	; 1
 95a:	b8 e0       	ldi	r27, 0x08	; 8
 95c:	cb 0e       	add	r12, r27
 95e:	d1 1c       	adc	r13, r1
 960:	cf 01       	movw	r24, r30
 962:	21 91       	ld	r18, Z+
 964:	da 01       	movw	r26, r20
 966:	2d 93       	st	X+, r18
 968:	ad 01       	movw	r20, r26
 96a:	dc 01       	movw	r26, r24
 96c:	8c 91       	ld	r24, X
 96e:	88 23       	and	r24, r24
 970:	19 f0       	breq	.+6      	; 0x978 <xTaskCreate+0x9e>
 972:	ec 15       	cp	r30, r12
 974:	fd 05       	cpc	r31, r13
 976:	a1 f7       	brne	.-24     	; 0x960 <xTaskCreate+0x86>
 978:	18 a2       	std	Y+32, r1	; 0x20
 97a:	04 30       	cpi	r16, 0x04	; 4
 97c:	08 f0       	brcs	.+2      	; 0x980 <xTaskCreate+0xa6>
 97e:	03 e0       	ldi	r16, 0x03	; 3
 980:	0e 8b       	std	Y+22, r16	; 0x16
 982:	6e 01       	movw	r12, r28
 984:	b2 e0       	ldi	r27, 0x02	; 2
 986:	cb 0e       	add	r12, r27
 988:	d1 1c       	adc	r13, r1
 98a:	c6 01       	movw	r24, r12
 98c:	0e 94 52 02 	call	0x4a4	; 0x4a4 <vListInitialiseItem>
 990:	ce 01       	movw	r24, r28
 992:	0c 96       	adiw	r24, 0x0c	; 12
 994:	0e 94 52 02 	call	0x4a4	; 0x4a4 <vListInitialiseItem>
 998:	c8 87       	std	Y+8, r28	; 0x08
 99a:	d9 87       	std	Y+9, r29	; 0x09
 99c:	84 e0       	ldi	r24, 0x04	; 4
 99e:	90 e0       	ldi	r25, 0x00	; 0
 9a0:	80 1b       	sub	r24, r16
 9a2:	91 09       	sbc	r25, r1
 9a4:	8c 87       	std	Y+12, r24	; 0x0c
 9a6:	9d 87       	std	Y+13, r25	; 0x0d
 9a8:	ca 8b       	std	Y+18, r28	; 0x12
 9aa:	db 8b       	std	Y+19, r29	; 0x13
 9ac:	1b a2       	std	Y+35, r1	; 0x23
 9ae:	1c a2       	std	Y+36, r1	; 0x24
 9b0:	1d a2       	std	Y+37, r1	; 0x25
 9b2:	1e a2       	std	Y+38, r1	; 0x26
 9b4:	1f a2       	std	Y+39, r1	; 0x27
 9b6:	18 a6       	std	Y+40, r1	; 0x28
 9b8:	19 a6       	std	Y+41, r1	; 0x29
 9ba:	1a a6       	std	Y+42, r1	; 0x2a
 9bc:	1b a6       	std	Y+43, r1	; 0x2b
 9be:	a2 01       	movw	r20, r4
 9c0:	b4 01       	movw	r22, r8
 9c2:	c5 01       	movw	r24, r10
 9c4:	0e 94 9e 02 	call	0x53c	; 0x53c <pxPortInitialiseStack>
 9c8:	88 83       	st	Y, r24
 9ca:	99 83       	std	Y+1, r25	; 0x01
 9cc:	e1 14       	cp	r14, r1
 9ce:	f1 04       	cpc	r15, r1
 9d0:	19 f0       	breq	.+6      	; 0x9d8 <xTaskCreate+0xfe>
 9d2:	f7 01       	movw	r30, r14
 9d4:	c0 83       	st	Z, r28
 9d6:	d1 83       	std	Z+1, r29	; 0x01
 9d8:	0f b6       	in	r0, 0x3f	; 63
 9da:	f8 94       	cli
 9dc:	0f 92       	push	r0
 9de:	80 91 60 28 	lds	r24, 0x2860	; 0x802860 <uxCurrentNumberOfTasks>
 9e2:	8f 5f       	subi	r24, 0xFF	; 255
 9e4:	80 93 60 28 	sts	0x2860, r24	; 0x802860 <uxCurrentNumberOfTasks>
 9e8:	80 91 ae 28 	lds	r24, 0x28AE	; 0x8028ae <pxCurrentTCB>
 9ec:	90 91 af 28 	lds	r25, 0x28AF	; 0x8028af <pxCurrentTCB+0x1>
 9f0:	89 2b       	or	r24, r25
 9f2:	a9 f5       	brne	.+106    	; 0xa5e <xTaskCreate+0x184>
 9f4:	c0 93 ae 28 	sts	0x28AE, r28	; 0x8028ae <pxCurrentTCB>
 9f8:	d0 93 af 28 	sts	0x28AF, r29	; 0x8028af <pxCurrentTCB+0x1>
 9fc:	80 91 60 28 	lds	r24, 0x2860	; 0x802860 <uxCurrentNumberOfTasks>
 a00:	81 30       	cpi	r24, 0x01	; 1
 a02:	e9 f5       	brne	.+122    	; 0xa7e <xTaskCreate+0x1a4>
 a04:	8a e8       	ldi	r24, 0x8A	; 138
 a06:	98 e2       	ldi	r25, 0x28	; 40
 a08:	0e 94 44 02 	call	0x488	; 0x488 <vListInitialise>
 a0c:	83 e9       	ldi	r24, 0x93	; 147
 a0e:	98 e2       	ldi	r25, 0x28	; 40
 a10:	0e 94 44 02 	call	0x488	; 0x488 <vListInitialise>
 a14:	8c e9       	ldi	r24, 0x9C	; 156
 a16:	98 e2       	ldi	r25, 0x28	; 40
 a18:	0e 94 44 02 	call	0x488	; 0x488 <vListInitialise>
 a1c:	85 ea       	ldi	r24, 0xA5	; 165
 a1e:	98 e2       	ldi	r25, 0x28	; 40
 a20:	0e 94 44 02 	call	0x488	; 0x488 <vListInitialise>
 a24:	81 e8       	ldi	r24, 0x81	; 129
 a26:	98 e2       	ldi	r25, 0x28	; 40
 a28:	0e 94 44 02 	call	0x488	; 0x488 <vListInitialise>
 a2c:	88 e7       	ldi	r24, 0x78	; 120
 a2e:	98 e2       	ldi	r25, 0x28	; 40
 a30:	0e 94 44 02 	call	0x488	; 0x488 <vListInitialise>
 a34:	8b e6       	ldi	r24, 0x6B	; 107
 a36:	98 e2       	ldi	r25, 0x28	; 40
 a38:	0e 94 44 02 	call	0x488	; 0x488 <vListInitialise>
 a3c:	82 e6       	ldi	r24, 0x62	; 98
 a3e:	98 e2       	ldi	r25, 0x28	; 40
 a40:	0e 94 44 02 	call	0x488	; 0x488 <vListInitialise>
 a44:	81 e8       	ldi	r24, 0x81	; 129
 a46:	98 e2       	ldi	r25, 0x28	; 40
 a48:	80 93 76 28 	sts	0x2876, r24	; 0x802876 <pxDelayedTaskList>
 a4c:	90 93 77 28 	sts	0x2877, r25	; 0x802877 <pxDelayedTaskList+0x1>
 a50:	88 e7       	ldi	r24, 0x78	; 120
 a52:	98 e2       	ldi	r25, 0x28	; 40
 a54:	80 93 74 28 	sts	0x2874, r24	; 0x802874 <pxOverflowDelayedTaskList>
 a58:	90 93 75 28 	sts	0x2875, r25	; 0x802875 <pxOverflowDelayedTaskList+0x1>
 a5c:	10 c0       	rjmp	.+32     	; 0xa7e <xTaskCreate+0x1a4>
 a5e:	80 91 5c 28 	lds	r24, 0x285C	; 0x80285c <xSchedulerRunning>
 a62:	81 11       	cpse	r24, r1
 a64:	0c c0       	rjmp	.+24     	; 0xa7e <xTaskCreate+0x1a4>
 a66:	e0 91 ae 28 	lds	r30, 0x28AE	; 0x8028ae <pxCurrentTCB>
 a6a:	f0 91 af 28 	lds	r31, 0x28AF	; 0x8028af <pxCurrentTCB+0x1>
 a6e:	96 89       	ldd	r25, Z+22	; 0x16
 a70:	8e 89       	ldd	r24, Y+22	; 0x16
 a72:	89 17       	cp	r24, r25
 a74:	20 f0       	brcs	.+8      	; 0xa7e <xTaskCreate+0x1a4>
 a76:	c0 93 ae 28 	sts	0x28AE, r28	; 0x8028ae <pxCurrentTCB>
 a7a:	d0 93 af 28 	sts	0x28AF, r29	; 0x8028af <pxCurrentTCB+0x1>
 a7e:	80 91 58 28 	lds	r24, 0x2858	; 0x802858 <uxTaskNumber>
 a82:	8f 5f       	subi	r24, 0xFF	; 255
 a84:	80 93 58 28 	sts	0x2858, r24	; 0x802858 <uxTaskNumber>
 a88:	89 a3       	std	Y+33, r24	; 0x21
 a8a:	8e 89       	ldd	r24, Y+22	; 0x16
 a8c:	90 91 5d 28 	lds	r25, 0x285D	; 0x80285d <uxTopReadyPriority>
 a90:	98 17       	cp	r25, r24
 a92:	10 f4       	brcc	.+4      	; 0xa98 <xTaskCreate+0x1be>
 a94:	80 93 5d 28 	sts	0x285D, r24	; 0x80285d <uxTopReadyPriority>
 a98:	90 e0       	ldi	r25, 0x00	; 0
 a9a:	9c 01       	movw	r18, r24
 a9c:	22 0f       	add	r18, r18
 a9e:	33 1f       	adc	r19, r19
 aa0:	22 0f       	add	r18, r18
 aa2:	33 1f       	adc	r19, r19
 aa4:	22 0f       	add	r18, r18
 aa6:	33 1f       	adc	r19, r19
 aa8:	82 0f       	add	r24, r18
 aaa:	93 1f       	adc	r25, r19
 aac:	b6 01       	movw	r22, r12
 aae:	86 57       	subi	r24, 0x76	; 118
 ab0:	97 4d       	sbci	r25, 0xD7	; 215
 ab2:	0e 94 56 02 	call	0x4ac	; 0x4ac <vListInsertEnd>
 ab6:	0f 90       	pop	r0
 ab8:	0f be       	out	0x3f, r0	; 63
 aba:	80 91 5c 28 	lds	r24, 0x285C	; 0x80285c <xSchedulerRunning>
 abe:	88 23       	and	r24, r24
 ac0:	61 f0       	breq	.+24     	; 0xada <xTaskCreate+0x200>
 ac2:	e0 91 ae 28 	lds	r30, 0x28AE	; 0x8028ae <pxCurrentTCB>
 ac6:	f0 91 af 28 	lds	r31, 0x28AF	; 0x8028af <pxCurrentTCB+0x1>
 aca:	96 89       	ldd	r25, Z+22	; 0x16
 acc:	8e 89       	ldd	r24, Y+22	; 0x16
 ace:	98 17       	cp	r25, r24
 ad0:	30 f4       	brcc	.+12     	; 0xade <xTaskCreate+0x204>
 ad2:	0e 94 42 03 	call	0x684	; 0x684 <vPortYield>
 ad6:	81 e0       	ldi	r24, 0x01	; 1
 ad8:	05 c0       	rjmp	.+10     	; 0xae4 <xTaskCreate+0x20a>
 ada:	81 e0       	ldi	r24, 0x01	; 1
 adc:	03 c0       	rjmp	.+6      	; 0xae4 <xTaskCreate+0x20a>
 ade:	81 e0       	ldi	r24, 0x01	; 1
 ae0:	01 c0       	rjmp	.+2      	; 0xae4 <xTaskCreate+0x20a>
 ae2:	8f ef       	ldi	r24, 0xFF	; 255
 ae4:	df 91       	pop	r29
 ae6:	cf 91       	pop	r28
 ae8:	0f 91       	pop	r16
 aea:	ff 90       	pop	r15
 aec:	ef 90       	pop	r14
 aee:	df 90       	pop	r13
 af0:	cf 90       	pop	r12
 af2:	bf 90       	pop	r11
 af4:	af 90       	pop	r10
 af6:	9f 90       	pop	r9
 af8:	8f 90       	pop	r8
 afa:	7f 90       	pop	r7
 afc:	6f 90       	pop	r6
 afe:	5f 90       	pop	r5
 b00:	4f 90       	pop	r4
 b02:	08 95       	ret

00000b04 <vTaskStartScheduler>:
 b04:	ef 92       	push	r14
 b06:	ff 92       	push	r15
 b08:	0f 93       	push	r16
 b0a:	0f 2e       	mov	r0, r31
 b0c:	f4 e5       	ldi	r31, 0x54	; 84
 b0e:	ef 2e       	mov	r14, r31
 b10:	f8 e2       	ldi	r31, 0x28	; 40
 b12:	ff 2e       	mov	r15, r31
 b14:	f0 2d       	mov	r31, r0
 b16:	00 e0       	ldi	r16, 0x00	; 0
 b18:	20 e0       	ldi	r18, 0x00	; 0
 b1a:	30 e0       	ldi	r19, 0x00	; 0
 b1c:	45 e5       	ldi	r20, 0x55	; 85
 b1e:	50 e0       	ldi	r21, 0x00	; 0
 b20:	60 e1       	ldi	r22, 0x10	; 16
 b22:	70 e2       	ldi	r23, 0x20	; 32
 b24:	83 e3       	ldi	r24, 0x33	; 51
 b26:	94 e0       	ldi	r25, 0x04	; 4
 b28:	0e 94 6d 04 	call	0x8da	; 0x8da <xTaskCreate>
 b2c:	81 30       	cpi	r24, 0x01	; 1
 b2e:	91 f4       	brne	.+36     	; 0xb54 <vTaskStartScheduler+0x50>
 b30:	f8 94       	cli
 b32:	8f ef       	ldi	r24, 0xFF	; 255
 b34:	9f ef       	ldi	r25, 0xFF	; 255
 b36:	80 93 56 28 	sts	0x2856, r24	; 0x802856 <xNextTaskUnblockTime>
 b3a:	90 93 57 28 	sts	0x2857, r25	; 0x802857 <xNextTaskUnblockTime+0x1>
 b3e:	81 e0       	ldi	r24, 0x01	; 1
 b40:	80 93 5c 28 	sts	0x285C, r24	; 0x80285c <xSchedulerRunning>
 b44:	10 92 5e 28 	sts	0x285E, r1	; 0x80285e <xTickCount>
 b48:	10 92 5f 28 	sts	0x285F, r1	; 0x80285f <xTickCount+0x1>
 b4c:	0e 94 f6 03 	call	0x7ec	; 0x7ec <vConfigureTimerForRunTimeStats>
 b50:	0e 94 0c 03 	call	0x618	; 0x618 <xPortStartScheduler>
 b54:	0f 91       	pop	r16
 b56:	ff 90       	pop	r15
 b58:	ef 90       	pop	r14
 b5a:	08 95       	ret

00000b5c <vTaskSuspendAll>:
 b5c:	80 91 53 28 	lds	r24, 0x2853	; 0x802853 <uxSchedulerSuspended>
 b60:	8f 5f       	subi	r24, 0xFF	; 255
 b62:	80 93 53 28 	sts	0x2853, r24	; 0x802853 <uxSchedulerSuspended>
 b66:	08 95       	ret

00000b68 <xTaskIncrementTick>:
 b68:	df 92       	push	r13
 b6a:	ef 92       	push	r14
 b6c:	ff 92       	push	r15
 b6e:	0f 93       	push	r16
 b70:	1f 93       	push	r17
 b72:	cf 93       	push	r28
 b74:	df 93       	push	r29
 b76:	80 91 53 28 	lds	r24, 0x2853	; 0x802853 <uxSchedulerSuspended>
 b7a:	81 11       	cpse	r24, r1
 b7c:	98 c0       	rjmp	.+304    	; 0xcae <xTaskIncrementTick+0x146>
 b7e:	e0 90 5e 28 	lds	r14, 0x285E	; 0x80285e <xTickCount>
 b82:	f0 90 5f 28 	lds	r15, 0x285F	; 0x80285f <xTickCount+0x1>
 b86:	8f ef       	ldi	r24, 0xFF	; 255
 b88:	e8 1a       	sub	r14, r24
 b8a:	f8 0a       	sbc	r15, r24
 b8c:	e0 92 5e 28 	sts	0x285E, r14	; 0x80285e <xTickCount>
 b90:	f0 92 5f 28 	sts	0x285F, r15	; 0x80285f <xTickCount+0x1>
 b94:	e1 14       	cp	r14, r1
 b96:	f1 04       	cpc	r15, r1
 b98:	b9 f4       	brne	.+46     	; 0xbc8 <xTaskIncrementTick+0x60>
 b9a:	80 91 76 28 	lds	r24, 0x2876	; 0x802876 <pxDelayedTaskList>
 b9e:	90 91 77 28 	lds	r25, 0x2877	; 0x802877 <pxDelayedTaskList+0x1>
 ba2:	20 91 74 28 	lds	r18, 0x2874	; 0x802874 <pxOverflowDelayedTaskList>
 ba6:	30 91 75 28 	lds	r19, 0x2875	; 0x802875 <pxOverflowDelayedTaskList+0x1>
 baa:	20 93 76 28 	sts	0x2876, r18	; 0x802876 <pxDelayedTaskList>
 bae:	30 93 77 28 	sts	0x2877, r19	; 0x802877 <pxDelayedTaskList+0x1>
 bb2:	80 93 74 28 	sts	0x2874, r24	; 0x802874 <pxOverflowDelayedTaskList>
 bb6:	90 93 75 28 	sts	0x2875, r25	; 0x802875 <pxOverflowDelayedTaskList+0x1>
 bba:	80 91 59 28 	lds	r24, 0x2859	; 0x802859 <xNumOfOverflows>
 bbe:	8f 5f       	subi	r24, 0xFF	; 255
 bc0:	80 93 59 28 	sts	0x2859, r24	; 0x802859 <xNumOfOverflows>
 bc4:	0e 94 14 04 	call	0x828	; 0x828 <prvResetNextTaskUnblockTime>
 bc8:	80 91 56 28 	lds	r24, 0x2856	; 0x802856 <xNextTaskUnblockTime>
 bcc:	90 91 57 28 	lds	r25, 0x2857	; 0x802857 <xNextTaskUnblockTime+0x1>
 bd0:	e8 16       	cp	r14, r24
 bd2:	f9 06       	cpc	r15, r25
 bd4:	10 f4       	brcc	.+4      	; 0xbda <xTaskIncrementTick+0x72>
 bd6:	d1 2c       	mov	r13, r1
 bd8:	52 c0       	rjmp	.+164    	; 0xc7e <xTaskIncrementTick+0x116>
 bda:	d1 2c       	mov	r13, r1
 bdc:	e0 91 76 28 	lds	r30, 0x2876	; 0x802876 <pxDelayedTaskList>
 be0:	f0 91 77 28 	lds	r31, 0x2877	; 0x802877 <pxDelayedTaskList+0x1>
 be4:	80 81       	ld	r24, Z
 be6:	81 11       	cpse	r24, r1
 be8:	07 c0       	rjmp	.+14     	; 0xbf8 <xTaskIncrementTick+0x90>
 bea:	8f ef       	ldi	r24, 0xFF	; 255
 bec:	9f ef       	ldi	r25, 0xFF	; 255
 bee:	80 93 56 28 	sts	0x2856, r24	; 0x802856 <xNextTaskUnblockTime>
 bf2:	90 93 57 28 	sts	0x2857, r25	; 0x802857 <xNextTaskUnblockTime+0x1>
 bf6:	43 c0       	rjmp	.+134    	; 0xc7e <xTaskIncrementTick+0x116>
 bf8:	e0 91 76 28 	lds	r30, 0x2876	; 0x802876 <pxDelayedTaskList>
 bfc:	f0 91 77 28 	lds	r31, 0x2877	; 0x802877 <pxDelayedTaskList+0x1>
 c00:	05 80       	ldd	r0, Z+5	; 0x05
 c02:	f6 81       	ldd	r31, Z+6	; 0x06
 c04:	e0 2d       	mov	r30, r0
 c06:	c6 81       	ldd	r28, Z+6	; 0x06
 c08:	d7 81       	ldd	r29, Z+7	; 0x07
 c0a:	8a 81       	ldd	r24, Y+2	; 0x02
 c0c:	9b 81       	ldd	r25, Y+3	; 0x03
 c0e:	e8 16       	cp	r14, r24
 c10:	f9 06       	cpc	r15, r25
 c12:	28 f4       	brcc	.+10     	; 0xc1e <xTaskIncrementTick+0xb6>
 c14:	80 93 56 28 	sts	0x2856, r24	; 0x802856 <xNextTaskUnblockTime>
 c18:	90 93 57 28 	sts	0x2857, r25	; 0x802857 <xNextTaskUnblockTime+0x1>
 c1c:	30 c0       	rjmp	.+96     	; 0xc7e <xTaskIncrementTick+0x116>
 c1e:	8e 01       	movw	r16, r28
 c20:	0e 5f       	subi	r16, 0xFE	; 254
 c22:	1f 4f       	sbci	r17, 0xFF	; 255
 c24:	c8 01       	movw	r24, r16
 c26:	0e 94 77 02 	call	0x4ee	; 0x4ee <uxListRemove>
 c2a:	8c 89       	ldd	r24, Y+20	; 0x14
 c2c:	9d 89       	ldd	r25, Y+21	; 0x15
 c2e:	89 2b       	or	r24, r25
 c30:	21 f0       	breq	.+8      	; 0xc3a <xTaskIncrementTick+0xd2>
 c32:	ce 01       	movw	r24, r28
 c34:	0c 96       	adiw	r24, 0x0c	; 12
 c36:	0e 94 77 02 	call	0x4ee	; 0x4ee <uxListRemove>
 c3a:	8e 89       	ldd	r24, Y+22	; 0x16
 c3c:	90 91 5d 28 	lds	r25, 0x285D	; 0x80285d <uxTopReadyPriority>
 c40:	98 17       	cp	r25, r24
 c42:	10 f4       	brcc	.+4      	; 0xc48 <xTaskIncrementTick+0xe0>
 c44:	80 93 5d 28 	sts	0x285D, r24	; 0x80285d <uxTopReadyPriority>
 c48:	90 e0       	ldi	r25, 0x00	; 0
 c4a:	9c 01       	movw	r18, r24
 c4c:	22 0f       	add	r18, r18
 c4e:	33 1f       	adc	r19, r19
 c50:	22 0f       	add	r18, r18
 c52:	33 1f       	adc	r19, r19
 c54:	22 0f       	add	r18, r18
 c56:	33 1f       	adc	r19, r19
 c58:	82 0f       	add	r24, r18
 c5a:	93 1f       	adc	r25, r19
 c5c:	b8 01       	movw	r22, r16
 c5e:	86 57       	subi	r24, 0x76	; 118
 c60:	97 4d       	sbci	r25, 0xD7	; 215
 c62:	0e 94 56 02 	call	0x4ac	; 0x4ac <vListInsertEnd>
 c66:	e0 91 ae 28 	lds	r30, 0x28AE	; 0x8028ae <pxCurrentTCB>
 c6a:	f0 91 af 28 	lds	r31, 0x28AF	; 0x8028af <pxCurrentTCB+0x1>
 c6e:	9e 89       	ldd	r25, Y+22	; 0x16
 c70:	86 89       	ldd	r24, Z+22	; 0x16
 c72:	98 17       	cp	r25, r24
 c74:	08 f4       	brcc	.+2      	; 0xc78 <xTaskIncrementTick+0x110>
 c76:	b2 cf       	rjmp	.-156    	; 0xbdc <xTaskIncrementTick+0x74>
 c78:	dd 24       	eor	r13, r13
 c7a:	d3 94       	inc	r13
 c7c:	af cf       	rjmp	.-162    	; 0xbdc <xTaskIncrementTick+0x74>
 c7e:	e0 91 ae 28 	lds	r30, 0x28AE	; 0x8028ae <pxCurrentTCB>
 c82:	f0 91 af 28 	lds	r31, 0x28AF	; 0x8028af <pxCurrentTCB+0x1>
 c86:	86 89       	ldd	r24, Z+22	; 0x16
 c88:	90 e0       	ldi	r25, 0x00	; 0
 c8a:	fc 01       	movw	r30, r24
 c8c:	ee 0f       	add	r30, r30
 c8e:	ff 1f       	adc	r31, r31
 c90:	ee 0f       	add	r30, r30
 c92:	ff 1f       	adc	r31, r31
 c94:	ee 0f       	add	r30, r30
 c96:	ff 1f       	adc	r31, r31
 c98:	8e 0f       	add	r24, r30
 c9a:	9f 1f       	adc	r25, r31
 c9c:	fc 01       	movw	r30, r24
 c9e:	e6 57       	subi	r30, 0x76	; 118
 ca0:	f7 4d       	sbci	r31, 0xD7	; 215
 ca2:	80 81       	ld	r24, Z
 ca4:	82 30       	cpi	r24, 0x02	; 2
 ca6:	48 f0       	brcs	.+18     	; 0xcba <xTaskIncrementTick+0x152>
 ca8:	dd 24       	eor	r13, r13
 caa:	d3 94       	inc	r13
 cac:	06 c0       	rjmp	.+12     	; 0xcba <xTaskIncrementTick+0x152>
 cae:	80 91 5b 28 	lds	r24, 0x285B	; 0x80285b <uxPendedTicks>
 cb2:	8f 5f       	subi	r24, 0xFF	; 255
 cb4:	80 93 5b 28 	sts	0x285B, r24	; 0x80285b <uxPendedTicks>
 cb8:	d1 2c       	mov	r13, r1
 cba:	80 91 5a 28 	lds	r24, 0x285A	; 0x80285a <xYieldPending>
 cbe:	88 23       	and	r24, r24
 cc0:	11 f0       	breq	.+4      	; 0xcc6 <xTaskIncrementTick+0x15e>
 cc2:	dd 24       	eor	r13, r13
 cc4:	d3 94       	inc	r13
 cc6:	8d 2d       	mov	r24, r13
 cc8:	df 91       	pop	r29
 cca:	cf 91       	pop	r28
 ccc:	1f 91       	pop	r17
 cce:	0f 91       	pop	r16
 cd0:	ff 90       	pop	r15
 cd2:	ef 90       	pop	r14
 cd4:	df 90       	pop	r13
 cd6:	08 95       	ret

00000cd8 <xTaskResumeAll>:
 cd8:	df 92       	push	r13
 cda:	ef 92       	push	r14
 cdc:	ff 92       	push	r15
 cde:	0f 93       	push	r16
 ce0:	1f 93       	push	r17
 ce2:	cf 93       	push	r28
 ce4:	df 93       	push	r29
 ce6:	0f b6       	in	r0, 0x3f	; 63
 ce8:	f8 94       	cli
 cea:	0f 92       	push	r0
 cec:	80 91 53 28 	lds	r24, 0x2853	; 0x802853 <uxSchedulerSuspended>
 cf0:	81 50       	subi	r24, 0x01	; 1
 cf2:	80 93 53 28 	sts	0x2853, r24	; 0x802853 <uxSchedulerSuspended>
 cf6:	80 91 53 28 	lds	r24, 0x2853	; 0x802853 <uxSchedulerSuspended>
 cfa:	81 11       	cpse	r24, r1
 cfc:	5f c0       	rjmp	.+190    	; 0xdbc <xTaskResumeAll+0xe4>
 cfe:	80 91 60 28 	lds	r24, 0x2860	; 0x802860 <uxCurrentNumberOfTasks>
 d02:	81 11       	cpse	r24, r1
 d04:	33 c0       	rjmp	.+102    	; 0xd6c <xTaskResumeAll+0x94>
 d06:	5d c0       	rjmp	.+186    	; 0xdc2 <xTaskResumeAll+0xea>
 d08:	d7 01       	movw	r26, r14
 d0a:	15 96       	adiw	r26, 0x05	; 5
 d0c:	ed 91       	ld	r30, X+
 d0e:	fc 91       	ld	r31, X
 d10:	16 97       	sbiw	r26, 0x06	; 6
 d12:	c6 81       	ldd	r28, Z+6	; 0x06
 d14:	d7 81       	ldd	r29, Z+7	; 0x07
 d16:	ce 01       	movw	r24, r28
 d18:	0c 96       	adiw	r24, 0x0c	; 12
 d1a:	0e 94 77 02 	call	0x4ee	; 0x4ee <uxListRemove>
 d1e:	8e 01       	movw	r16, r28
 d20:	0e 5f       	subi	r16, 0xFE	; 254
 d22:	1f 4f       	sbci	r17, 0xFF	; 255
 d24:	c8 01       	movw	r24, r16
 d26:	0e 94 77 02 	call	0x4ee	; 0x4ee <uxListRemove>
 d2a:	8e 89       	ldd	r24, Y+22	; 0x16
 d2c:	90 91 5d 28 	lds	r25, 0x285D	; 0x80285d <uxTopReadyPriority>
 d30:	98 17       	cp	r25, r24
 d32:	10 f4       	brcc	.+4      	; 0xd38 <xTaskResumeAll+0x60>
 d34:	80 93 5d 28 	sts	0x285D, r24	; 0x80285d <uxTopReadyPriority>
 d38:	90 e0       	ldi	r25, 0x00	; 0
 d3a:	9c 01       	movw	r18, r24
 d3c:	22 0f       	add	r18, r18
 d3e:	33 1f       	adc	r19, r19
 d40:	22 0f       	add	r18, r18
 d42:	33 1f       	adc	r19, r19
 d44:	22 0f       	add	r18, r18
 d46:	33 1f       	adc	r19, r19
 d48:	82 0f       	add	r24, r18
 d4a:	93 1f       	adc	r25, r19
 d4c:	b8 01       	movw	r22, r16
 d4e:	86 57       	subi	r24, 0x76	; 118
 d50:	97 4d       	sbci	r25, 0xD7	; 215
 d52:	0e 94 56 02 	call	0x4ac	; 0x4ac <vListInsertEnd>
 d56:	e0 91 ae 28 	lds	r30, 0x28AE	; 0x8028ae <pxCurrentTCB>
 d5a:	f0 91 af 28 	lds	r31, 0x28AF	; 0x8028af <pxCurrentTCB+0x1>
 d5e:	9e 89       	ldd	r25, Y+22	; 0x16
 d60:	86 89       	ldd	r24, Z+22	; 0x16
 d62:	98 17       	cp	r25, r24
 d64:	68 f0       	brcs	.+26     	; 0xd80 <xTaskResumeAll+0xa8>
 d66:	d0 92 5a 28 	sts	0x285A, r13	; 0x80285a <xYieldPending>
 d6a:	0a c0       	rjmp	.+20     	; 0xd80 <xTaskResumeAll+0xa8>
 d6c:	c0 e0       	ldi	r28, 0x00	; 0
 d6e:	d0 e0       	ldi	r29, 0x00	; 0
 d70:	0f 2e       	mov	r0, r31
 d72:	fb e6       	ldi	r31, 0x6B	; 107
 d74:	ef 2e       	mov	r14, r31
 d76:	f8 e2       	ldi	r31, 0x28	; 40
 d78:	ff 2e       	mov	r15, r31
 d7a:	f0 2d       	mov	r31, r0
 d7c:	dd 24       	eor	r13, r13
 d7e:	d3 94       	inc	r13
 d80:	f7 01       	movw	r30, r14
 d82:	80 81       	ld	r24, Z
 d84:	81 11       	cpse	r24, r1
 d86:	c0 cf       	rjmp	.-128    	; 0xd08 <xTaskResumeAll+0x30>
 d88:	cd 2b       	or	r28, r29
 d8a:	11 f0       	breq	.+4      	; 0xd90 <xTaskResumeAll+0xb8>
 d8c:	0e 94 14 04 	call	0x828	; 0x828 <prvResetNextTaskUnblockTime>
 d90:	c0 91 5b 28 	lds	r28, 0x285B	; 0x80285b <uxPendedTicks>
 d94:	cc 23       	and	r28, r28
 d96:	51 f0       	breq	.+20     	; 0xdac <xTaskResumeAll+0xd4>
 d98:	d1 e0       	ldi	r29, 0x01	; 1
 d9a:	0e 94 b4 05 	call	0xb68	; 0xb68 <xTaskIncrementTick>
 d9e:	81 11       	cpse	r24, r1
 da0:	d0 93 5a 28 	sts	0x285A, r29	; 0x80285a <xYieldPending>
 da4:	c1 50       	subi	r28, 0x01	; 1
 da6:	c9 f7       	brne	.-14     	; 0xd9a <xTaskResumeAll+0xc2>
 da8:	10 92 5b 28 	sts	0x285B, r1	; 0x80285b <uxPendedTicks>
 dac:	80 91 5a 28 	lds	r24, 0x285A	; 0x80285a <xYieldPending>
 db0:	88 23       	and	r24, r24
 db2:	31 f0       	breq	.+12     	; 0xdc0 <xTaskResumeAll+0xe8>
 db4:	0e 94 42 03 	call	0x684	; 0x684 <vPortYield>
 db8:	81 e0       	ldi	r24, 0x01	; 1
 dba:	03 c0       	rjmp	.+6      	; 0xdc2 <xTaskResumeAll+0xea>
 dbc:	80 e0       	ldi	r24, 0x00	; 0
 dbe:	01 c0       	rjmp	.+2      	; 0xdc2 <xTaskResumeAll+0xea>
 dc0:	80 e0       	ldi	r24, 0x00	; 0
 dc2:	0f 90       	pop	r0
 dc4:	0f be       	out	0x3f, r0	; 63
 dc6:	df 91       	pop	r29
 dc8:	cf 91       	pop	r28
 dca:	1f 91       	pop	r17
 dcc:	0f 91       	pop	r16
 dce:	ff 90       	pop	r15
 dd0:	ef 90       	pop	r14
 dd2:	df 90       	pop	r13
 dd4:	08 95       	ret

00000dd6 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 dd6:	0f 93       	push	r16
 dd8:	1f 93       	push	r17
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 dda:	80 91 53 28 	lds	r24, 0x2853	; 0x802853 <uxSchedulerSuspended>
 dde:	88 23       	and	r24, r24
 de0:	21 f0       	breq	.+8      	; 0xdea <vTaskSwitchContext+0x14>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 de2:	81 e0       	ldi	r24, 0x01	; 1
 de4:	80 93 5a 28 	sts	0x285A, r24	; 0x80285a <xYieldPending>
 de8:	97 c0       	rjmp	.+302    	; 0xf18 <vTaskSwitchContext+0x142>
	}
	else
	{
		xYieldPending = pdFALSE;
 dea:	10 92 5a 28 	sts	0x285A, r1	; 0x80285a <xYieldPending>
		#if ( configGENERATE_RUN_TIME_STATS == 1 )
		{
				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
				#else
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 dee:	80 91 b0 28 	lds	r24, 0x28B0	; 0x8028b0 <StatsTimer>
 df2:	90 91 b1 28 	lds	r25, 0x28B1	; 0x8028b1 <StatsTimer+0x1>
 df6:	20 91 20 0a 	lds	r18, 0x0A20	; 0x800a20 <__TEXT_REGION_LENGTH__+0x700a20>
 dfa:	30 91 21 0a 	lds	r19, 0x0A21	; 0x800a21 <__TEXT_REGION_LENGTH__+0x700a21>
 dfe:	a0 e0       	ldi	r26, 0x00	; 0
 e00:	b0 e0       	ldi	r27, 0x00	; 0
 e02:	dc 01       	movw	r26, r24
 e04:	99 27       	eor	r25, r25
 e06:	88 27       	eor	r24, r24
 e08:	82 0f       	add	r24, r18
 e0a:	93 1f       	adc	r25, r19
 e0c:	a1 1d       	adc	r26, r1
 e0e:	b1 1d       	adc	r27, r1
				stored in ulTaskSwitchedInTime.  Note that there is no overflow
				protection here so count values are only valid until the timer
				overflows.  The guard against negative values is to protect
				against suspect run time stat counter implementations - which
				are provided by the application, not the kernel. */
				if( ulTotalRunTime > ulTaskSwitchedInTime )
 e10:	00 91 4f 28 	lds	r16, 0x284F	; 0x80284f <ulTaskSwitchedInTime>
 e14:	10 91 50 28 	lds	r17, 0x2850	; 0x802850 <ulTaskSwitchedInTime+0x1>
 e18:	20 91 51 28 	lds	r18, 0x2851	; 0x802851 <ulTaskSwitchedInTime+0x2>
 e1c:	30 91 52 28 	lds	r19, 0x2852	; 0x802852 <ulTaskSwitchedInTime+0x3>
 e20:	08 17       	cp	r16, r24
 e22:	19 07       	cpc	r17, r25
 e24:	2a 07       	cpc	r18, r26
 e26:	3b 07       	cpc	r19, r27
 e28:	a0 f4       	brcc	.+40     	; 0xe52 <vTaskSwitchContext+0x7c>
				{
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
 e2a:	e0 91 ae 28 	lds	r30, 0x28AE	; 0x8028ae <pxCurrentTCB>
 e2e:	f0 91 af 28 	lds	r31, 0x28AF	; 0x8028af <pxCurrentTCB+0x1>
 e32:	43 a1       	ldd	r20, Z+35	; 0x23
 e34:	54 a1       	ldd	r21, Z+36	; 0x24
 e36:	65 a1       	ldd	r22, Z+37	; 0x25
 e38:	76 a1       	ldd	r23, Z+38	; 0x26
 e3a:	40 1b       	sub	r20, r16
 e3c:	51 0b       	sbc	r21, r17
 e3e:	62 0b       	sbc	r22, r18
 e40:	73 0b       	sbc	r23, r19
 e42:	48 0f       	add	r20, r24
 e44:	59 1f       	adc	r21, r25
 e46:	6a 1f       	adc	r22, r26
 e48:	7b 1f       	adc	r23, r27
 e4a:	43 a3       	std	Z+35, r20	; 0x23
 e4c:	54 a3       	std	Z+36, r21	; 0x24
 e4e:	65 a3       	std	Z+37, r22	; 0x25
 e50:	76 a3       	std	Z+38, r23	; 0x26
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				ulTaskSwitchedInTime = ulTotalRunTime;
 e52:	80 93 4f 28 	sts	0x284F, r24	; 0x80284f <ulTaskSwitchedInTime>
 e56:	90 93 50 28 	sts	0x2850, r25	; 0x802850 <ulTaskSwitchedInTime+0x1>
 e5a:	a0 93 51 28 	sts	0x2851, r26	; 0x802851 <ulTaskSwitchedInTime+0x2>
 e5e:	b0 93 52 28 	sts	0x2852, r27	; 0x802852 <ulTaskSwitchedInTime+0x3>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 e62:	20 91 5d 28 	lds	r18, 0x285D	; 0x80285d <uxTopReadyPriority>
 e66:	82 2f       	mov	r24, r18
 e68:	90 e0       	ldi	r25, 0x00	; 0
 e6a:	fc 01       	movw	r30, r24
 e6c:	ee 0f       	add	r30, r30
 e6e:	ff 1f       	adc	r31, r31
 e70:	ee 0f       	add	r30, r30
 e72:	ff 1f       	adc	r31, r31
 e74:	ee 0f       	add	r30, r30
 e76:	ff 1f       	adc	r31, r31
 e78:	e8 0f       	add	r30, r24
 e7a:	f9 1f       	adc	r31, r25
 e7c:	e6 57       	subi	r30, 0x76	; 118
 e7e:	f7 4d       	sbci	r31, 0xD7	; 215
 e80:	30 81       	ld	r19, Z
 e82:	31 11       	cpse	r19, r1
 e84:	11 c0       	rjmp	.+34     	; 0xea8 <vTaskSwitchContext+0xd2>
 e86:	21 50       	subi	r18, 0x01	; 1
 e88:	82 2f       	mov	r24, r18
 e8a:	90 e0       	ldi	r25, 0x00	; 0
 e8c:	fc 01       	movw	r30, r24
 e8e:	ee 0f       	add	r30, r30
 e90:	ff 1f       	adc	r31, r31
 e92:	ee 0f       	add	r30, r30
 e94:	ff 1f       	adc	r31, r31
 e96:	ee 0f       	add	r30, r30
 e98:	ff 1f       	adc	r31, r31
 e9a:	e8 0f       	add	r30, r24
 e9c:	f9 1f       	adc	r31, r25
 e9e:	e6 57       	subi	r30, 0x76	; 118
 ea0:	f7 4d       	sbci	r31, 0xD7	; 215
 ea2:	30 81       	ld	r19, Z
 ea4:	33 23       	and	r19, r19
 ea6:	79 f3       	breq	.-34     	; 0xe86 <vTaskSwitchContext+0xb0>
 ea8:	ac 01       	movw	r20, r24
 eaa:	44 0f       	add	r20, r20
 eac:	55 1f       	adc	r21, r21
 eae:	44 0f       	add	r20, r20
 eb0:	55 1f       	adc	r21, r21
 eb2:	44 0f       	add	r20, r20
 eb4:	55 1f       	adc	r21, r21
 eb6:	48 0f       	add	r20, r24
 eb8:	59 1f       	adc	r21, r25
 eba:	da 01       	movw	r26, r20
 ebc:	a6 57       	subi	r26, 0x76	; 118
 ebe:	b7 4d       	sbci	r27, 0xD7	; 215
 ec0:	11 96       	adiw	r26, 0x01	; 1
 ec2:	ed 91       	ld	r30, X+
 ec4:	fc 91       	ld	r31, X
 ec6:	12 97       	sbiw	r26, 0x02	; 2
 ec8:	02 80       	ldd	r0, Z+2	; 0x02
 eca:	f3 81       	ldd	r31, Z+3	; 0x03
 ecc:	e0 2d       	mov	r30, r0
 ece:	11 96       	adiw	r26, 0x01	; 1
 ed0:	ed 93       	st	X+, r30
 ed2:	fc 93       	st	X, r31
 ed4:	12 97       	sbiw	r26, 0x02	; 2
 ed6:	43 57       	subi	r20, 0x73	; 115
 ed8:	57 4d       	sbci	r21, 0xD7	; 215
 eda:	e4 17       	cp	r30, r20
 edc:	f5 07       	cpc	r31, r21
 ede:	29 f4       	brne	.+10     	; 0xeea <vTaskSwitchContext+0x114>
 ee0:	42 81       	ldd	r20, Z+2	; 0x02
 ee2:	53 81       	ldd	r21, Z+3	; 0x03
 ee4:	fd 01       	movw	r30, r26
 ee6:	41 83       	std	Z+1, r20	; 0x01
 ee8:	52 83       	std	Z+2, r21	; 0x02
 eea:	fc 01       	movw	r30, r24
 eec:	ee 0f       	add	r30, r30
 eee:	ff 1f       	adc	r31, r31
 ef0:	ee 0f       	add	r30, r30
 ef2:	ff 1f       	adc	r31, r31
 ef4:	ee 0f       	add	r30, r30
 ef6:	ff 1f       	adc	r31, r31
 ef8:	8e 0f       	add	r24, r30
 efa:	9f 1f       	adc	r25, r31
 efc:	fc 01       	movw	r30, r24
 efe:	e6 57       	subi	r30, 0x76	; 118
 f00:	f7 4d       	sbci	r31, 0xD7	; 215
 f02:	01 80       	ldd	r0, Z+1	; 0x01
 f04:	f2 81       	ldd	r31, Z+2	; 0x02
 f06:	e0 2d       	mov	r30, r0
 f08:	86 81       	ldd	r24, Z+6	; 0x06
 f0a:	97 81       	ldd	r25, Z+7	; 0x07
 f0c:	80 93 ae 28 	sts	0x28AE, r24	; 0x8028ae <pxCurrentTCB>
 f10:	90 93 af 28 	sts	0x28AF, r25	; 0x8028af <pxCurrentTCB+0x1>
 f14:	20 93 5d 28 	sts	0x285D, r18	; 0x80285d <uxTopReadyPriority>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 f18:	1f 91       	pop	r17
 f1a:	0f 91       	pop	r16
 f1c:	08 95       	ret

00000f1e <main>:
#include <stdio.h>


int main(void)
{
	SysClkXtal();			//Clock init
 f1e:	0e 94 27 01 	call	0x24e	; 0x24e <SysClkXtal>
	USARTInit();			//USART init and link to stdio
 f22:	0e 94 58 01 	call	0x2b0	; 0x2b0 <USARTInit>
	PMIC.CTRL=0b111;		//Enable interrupts
 f26:	87 e0       	ldi	r24, 0x07	; 7
 f28:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	
	
	//Init tasks
	//...
		
	printf ("Init complete\r\n");
 f2c:	8f e3       	ldi	r24, 0x3F	; 63
 f2e:	90 e2       	ldi	r25, 0x20	; 32
 f30:	0e 94 b9 07 	call	0xf72	; 0xf72 <puts>
	
	vTaskStartScheduler();	//Start scheduler loop
 f34:	0e 94 82 05 	call	0xb04	; 0xb04 <vTaskStartScheduler>

	return 0;
}
 f38:	80 e0       	ldi	r24, 0x00	; 0
 f3a:	90 e0       	ldi	r25, 0x00	; 0
 f3c:	08 95       	ret

00000f3e <vApplicationMallocFailedHook>:



void vApplicationMallocFailedHook(void)
{
	printf ("ERROR: memory allocation failed\r\n");
 f3e:	8e e4       	ldi	r24, 0x4E	; 78
 f40:	90 e2       	ldi	r25, 0x20	; 32
 f42:	0e 94 b9 07 	call	0xf72	; 0xf72 <puts>
 f46:	ff cf       	rjmp	.-2      	; 0xf46 <vApplicationMallocFailedHook+0x8>

00000f48 <vApplicationIdleHook>:
	while (1);
}

void vApplicationIdleHook( void )
{
	printf ("Idle\r\n");
 f48:	8f e6       	ldi	r24, 0x6F	; 111
 f4a:	90 e2       	ldi	r25, 0x20	; 32
 f4c:	0e 94 b9 07 	call	0xf72	; 0xf72 <puts>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 f50:	2f ef       	ldi	r18, 0xFF	; 255
 f52:	83 ed       	ldi	r24, 0xD3	; 211
 f54:	90 e3       	ldi	r25, 0x30	; 48
 f56:	21 50       	subi	r18, 0x01	; 1
 f58:	80 40       	sbci	r24, 0x00	; 0
 f5a:	90 40       	sbci	r25, 0x00	; 0
 f5c:	e1 f7       	brne	.-8      	; 0xf56 <vApplicationIdleHook+0xe>
 f5e:	00 c0       	rjmp	.+0      	; 0xf60 <vApplicationIdleHook+0x18>
 f60:	00 00       	nop
 f62:	08 95       	ret

00000f64 <memset>:
 f64:	dc 01       	movw	r26, r24
 f66:	01 c0       	rjmp	.+2      	; 0xf6a <memset+0x6>
 f68:	6d 93       	st	X+, r22
 f6a:	41 50       	subi	r20, 0x01	; 1
 f6c:	50 40       	sbci	r21, 0x00	; 0
 f6e:	e0 f7       	brcc	.-8      	; 0xf68 <memset+0x4>
 f70:	08 95       	ret

00000f72 <puts>:
 f72:	0f 93       	push	r16
 f74:	1f 93       	push	r17
 f76:	cf 93       	push	r28
 f78:	df 93       	push	r29
 f7a:	e0 91 b4 28 	lds	r30, 0x28B4	; 0x8028b4 <__iob+0x2>
 f7e:	f0 91 b5 28 	lds	r31, 0x28B5	; 0x8028b5 <__iob+0x3>
 f82:	23 81       	ldd	r18, Z+3	; 0x03
 f84:	21 ff       	sbrs	r18, 1
 f86:	1b c0       	rjmp	.+54     	; 0xfbe <puts+0x4c>
 f88:	8c 01       	movw	r16, r24
 f8a:	d0 e0       	ldi	r29, 0x00	; 0
 f8c:	c0 e0       	ldi	r28, 0x00	; 0
 f8e:	f8 01       	movw	r30, r16
 f90:	81 91       	ld	r24, Z+
 f92:	8f 01       	movw	r16, r30
 f94:	60 91 b4 28 	lds	r22, 0x28B4	; 0x8028b4 <__iob+0x2>
 f98:	70 91 b5 28 	lds	r23, 0x28B5	; 0x8028b5 <__iob+0x3>
 f9c:	db 01       	movw	r26, r22
 f9e:	18 96       	adiw	r26, 0x08	; 8
 fa0:	ed 91       	ld	r30, X+
 fa2:	fc 91       	ld	r31, X
 fa4:	19 97       	sbiw	r26, 0x09	; 9
 fa6:	88 23       	and	r24, r24
 fa8:	31 f0       	breq	.+12     	; 0xfb6 <puts+0x44>
 faa:	19 95       	eicall
 fac:	89 2b       	or	r24, r25
 fae:	79 f3       	breq	.-34     	; 0xf8e <puts+0x1c>
 fb0:	df ef       	ldi	r29, 0xFF	; 255
 fb2:	cf ef       	ldi	r28, 0xFF	; 255
 fb4:	ec cf       	rjmp	.-40     	; 0xf8e <puts+0x1c>
 fb6:	8a e0       	ldi	r24, 0x0A	; 10
 fb8:	19 95       	eicall
 fba:	89 2b       	or	r24, r25
 fbc:	19 f0       	breq	.+6      	; 0xfc4 <puts+0x52>
 fbe:	8f ef       	ldi	r24, 0xFF	; 255
 fc0:	9f ef       	ldi	r25, 0xFF	; 255
 fc2:	02 c0       	rjmp	.+4      	; 0xfc8 <puts+0x56>
 fc4:	8d 2f       	mov	r24, r29
 fc6:	9c 2f       	mov	r25, r28
 fc8:	df 91       	pop	r29
 fca:	cf 91       	pop	r28
 fcc:	1f 91       	pop	r17
 fce:	0f 91       	pop	r16
 fd0:	08 95       	ret

00000fd2 <_exit>:
 fd2:	f8 94       	cli

00000fd4 <__stop_program>:
 fd4:	ff cf       	rjmp	.-2      	; 0xfd4 <__stop_program>
