
LinebotFinal.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000574e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000003b0  00802000  0000574e  000057e2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00004508  008023b0  008023b0  00005b92  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00005b92  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00005bf0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007d8  00000000  00000000  00005c30  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000fb91  00000000  00000000  00006408  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004fee  00000000  00000000  00015f99  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006511  00000000  00000000  0001af87  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001c8c  00000000  00000000  00021498  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000449b  00000000  00000000  00023124  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000b484  00000000  00000000  000275bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000ac8  00000000  00000000  00032a43  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 8d 01 	jmp	0x31a	; 0x31a <__ctors_end>
       4:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
       8:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
       c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      10:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      14:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      18:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      1c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      20:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      24:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      28:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      2c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      30:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      34:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      38:	0c 94 a6 0f 	jmp	0x1f4c	; 0x1f4c <__vector_14>
      3c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      40:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      44:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      48:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      4c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      50:	0c 94 1a 10 	jmp	0x2034	; 0x2034 <__vector_20>
      54:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      58:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      5c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      60:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      64:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      68:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      6c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      70:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      74:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      78:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      7c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      80:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      84:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      88:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      8c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      90:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      94:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      98:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      9c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      a0:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      a4:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      a8:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      ac:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      b0:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      b4:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      b8:	0c 94 e8 0b 	jmp	0x17d0	; 0x17d0 <__vector_46>
      bc:	0c 94 06 05 	jmp	0xa0c	; 0xa0c <__vector_47>
      c0:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      c4:	0c 94 4d 05 	jmp	0xa9a	; 0xa9a <__vector_49>
      c8:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      cc:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      d0:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      d4:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      d8:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      dc:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      e0:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      e4:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      e8:	0c 94 e9 0c 	jmp	0x19d2	; 0x19d2 <__vector_58>
      ec:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      f0:	0c 94 9e 0c 	jmp	0x193c	; 0x193c <__vector_60>
      f4:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      f8:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
      fc:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     100:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     104:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     108:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     10c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     110:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     114:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     118:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     11c:	0c 94 23 02 	jmp	0x446	; 0x446 <__vector_71>
     120:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     124:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     128:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     12c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     130:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     134:	0c 94 50 04 	jmp	0x8a0	; 0x8a0 <__vector_77>
     138:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     13c:	0c 94 97 04 	jmp	0x92e	; 0x92e <__vector_79>
     140:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     144:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     148:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     14c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     150:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     154:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     158:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     15c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     160:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     164:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     168:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     16c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     170:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     174:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     178:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     17c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     180:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     184:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     188:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     18c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     190:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     194:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     198:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     19c:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1a0:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1a4:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1a8:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1ac:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1b0:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1b4:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1b8:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1bc:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1c0:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1c4:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1c8:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1cc:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1d0:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1d4:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1d8:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1dc:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1e0:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1e4:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1e8:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1ec:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1f0:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1f4:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>
     1f8:	0c 94 ae 01 	jmp	0x35c	; 0x35c <__bad_interrupt>

000001fc <__trampolines_start>:
     1fc:	0c 94 11 1e 	jmp	0x3c22	; 0x3c22 <WorkerLineFollower>
     200:	0c 94 4e 0c 	jmp	0x189c	; 0x189c <stdio_putchar>
     204:	0c 94 5f 15 	jmp	0x2abe	; 0x2abe <prvIdleTask>
     208:	0c 94 6b 23 	jmp	0x46d6	; 0x46d6 <WorkerOLEDMenu>
     20c:	0c 94 46 0c 	jmp	0x188c	; 0x188c <stdio_getchar>
     210:	0c 94 ef 1e 	jmp	0x3dde	; 0x3dde <WorkerMotorSpeed>
     214:	0c 94 92 1d 	jmp	0x3b24	; 0x3b24 <WorkerADC>

00000218 <__trampolines_end>:
     218:	6e 61       	ori	r22, 0x1E	; 30
     21a:	6e 00       	.word	0x006e	; ????

0000021c <__c.2332>:
     21c:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     22c:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     23c:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     24c:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     25c:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     26c:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     27c:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     28c:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     29c:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     2ac:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     2bc:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     2cc:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     2dc:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     2ec:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     2fc:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     30c:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

0000031a <__ctors_end>:
     31a:	11 24       	eor	r1, r1
     31c:	1f be       	out	0x3f, r1	; 63
     31e:	cf ef       	ldi	r28, 0xFF	; 255
     320:	cd bf       	out	0x3d, r28	; 61
     322:	df e9       	ldi	r29, 0x9F	; 159
     324:	de bf       	out	0x3e, r29	; 62
     326:	00 e0       	ldi	r16, 0x00	; 0
     328:	0c bf       	out	0x3c, r16	; 60

0000032a <__do_copy_data>:
     32a:	13 e2       	ldi	r17, 0x23	; 35
     32c:	a0 e0       	ldi	r26, 0x00	; 0
     32e:	b0 e2       	ldi	r27, 0x20	; 32
     330:	ee e4       	ldi	r30, 0x4E	; 78
     332:	f7 e5       	ldi	r31, 0x57	; 87
     334:	00 e0       	ldi	r16, 0x00	; 0
     336:	0b bf       	out	0x3b, r16	; 59
     338:	02 c0       	rjmp	.+4      	; 0x33e <__do_copy_data+0x14>
     33a:	07 90       	elpm	r0, Z+
     33c:	0d 92       	st	X+, r0
     33e:	a0 3b       	cpi	r26, 0xB0	; 176
     340:	b1 07       	cpc	r27, r17
     342:	d9 f7       	brne	.-10     	; 0x33a <__do_copy_data+0x10>

00000344 <__do_clear_bss>:
     344:	28 e6       	ldi	r18, 0x68	; 104
     346:	a0 eb       	ldi	r26, 0xB0	; 176
     348:	b3 e2       	ldi	r27, 0x23	; 35
     34a:	01 c0       	rjmp	.+2      	; 0x34e <.do_clear_bss_start>

0000034c <.do_clear_bss_loop>:
     34c:	1d 92       	st	X+, r1

0000034e <.do_clear_bss_start>:
     34e:	a8 3b       	cpi	r26, 0xB8	; 184
     350:	b2 07       	cpc	r27, r18
     352:	e1 f7       	brne	.-8      	; 0x34c <.do_clear_bss_loop>
     354:	0e 94 42 1d 	call	0x3a84	; 0x3a84 <main>
     358:	0c 94 a5 2b 	jmp	0x574a	; 0x574a <_exit>

0000035c <__bad_interrupt>:
     35c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000360 <DriverAdcInit>:
SemaphoreHandle_t AdcBusySema;					//Semaphore is taken when an ADC acquisition is performed
SemaphoreHandle_t ConversionCompleteSema;	//Semaphore used to signal completion of an ADC conversion

void DriverAdcInit(void)
{
	ADCA.CTRLA=0b00000001; //Enable ADC
     360:	e0 e0       	ldi	r30, 0x00	; 0
     362:	f2 e0       	ldi	r31, 0x02	; 2
     364:	81 e0       	ldi	r24, 0x01	; 1
     366:	80 83       	st	Z, r24
	ADCA.CTRLB=0b00000110; //Manual mode, 12 bit right justified
     368:	96 e0       	ldi	r25, 0x06	; 6
     36a:	91 83       	std	Z+1, r25	; 0x01
	ADCA.REFCTRL=0b00000010; //1.00V internal reference, enable bandgap
     36c:	92 e0       	ldi	r25, 0x02	; 2
     36e:	92 83       	std	Z+2, r25	; 0x02
	ADCA.PRESCALER=0b00000011; //DIV32; 1MHz ADCClk. Should be lower than 1,8MHz per spec
     370:	93 e0       	ldi	r25, 0x03	; 3
     372:	94 83       	std	Z+4, r25	; 0x04
	ADCA.CH0.INTCTRL=0b01; //Lo pri int
     374:	82 a3       	std	Z+34, r24	; 0x22
	
	AdcBusySema=xSemaphoreCreateBinary();
     376:	43 e0       	ldi	r20, 0x03	; 3
     378:	60 e0       	ldi	r22, 0x00	; 0
     37a:	0e 94 2d 11 	call	0x225a	; 0x225a <xQueueGenericCreate>
     37e:	80 93 9c 68 	sts	0x689C, r24	; 0x80689c <AdcBusySema>
     382:	90 93 9d 68 	sts	0x689D, r25	; 0x80689d <AdcBusySema+0x1>
	ConversionCompleteSema=xSemaphoreCreateBinary();
     386:	43 e0       	ldi	r20, 0x03	; 3
     388:	60 e0       	ldi	r22, 0x00	; 0
     38a:	81 e0       	ldi	r24, 0x01	; 1
     38c:	0e 94 2d 11 	call	0x225a	; 0x225a <xQueueGenericCreate>
     390:	80 93 9a 68 	sts	0x689A, r24	; 0x80689a <ConversionCompleteSema>
     394:	90 93 9b 68 	sts	0x689B, r25	; 0x80689b <ConversionCompleteSema+0x1>
	xSemaphoreGive(AdcBusySema);		
     398:	20 e0       	ldi	r18, 0x00	; 0
     39a:	40 e0       	ldi	r20, 0x00	; 0
     39c:	50 e0       	ldi	r21, 0x00	; 0
     39e:	60 e0       	ldi	r22, 0x00	; 0
     3a0:	70 e0       	ldi	r23, 0x00	; 0
     3a2:	80 91 9c 68 	lds	r24, 0x689C	; 0x80689c <AdcBusySema>
     3a6:	90 91 9d 68 	lds	r25, 0x689D	; 0x80689d <AdcBusySema+0x1>
     3aa:	0c 94 71 11 	jmp	0x22e2	; 0x22e2 <xQueueGenericSend>

000003ae <DriverAdcGetCh>:
}

int16_t DriverAdcGetCh(uint8_t PinPos,uint8_t PinNeg)
{
     3ae:	cf 93       	push	r28
     3b0:	df 93       	push	r29
     3b2:	c8 2f       	mov	r28, r24
     3b4:	d6 2f       	mov	r29, r22
	int16_t Res;
	
	xSemaphoreTake(AdcBusySema,portMAX_DELAY);
     3b6:	6f ef       	ldi	r22, 0xFF	; 255
     3b8:	7f ef       	ldi	r23, 0xFF	; 255
     3ba:	80 91 9c 68 	lds	r24, 0x689C	; 0x80689c <AdcBusySema>
     3be:	90 91 9d 68 	lds	r25, 0x689D	; 0x80689d <AdcBusySema+0x1>
     3c2:	0e 94 ab 13 	call	0x2756	; 0x2756 <xQueueSemaphoreTake>
	
	//Configure channels
	if (PinPos<16 && PinPos>=0)
     3c6:	c0 31       	cpi	r28, 0x10	; 16
     3c8:	28 f0       	brcs	.+10     	; 0x3d4 <DriverAdcGetCh+0x26>
		ADCA.CH0.MUXCTRL=PinPos<<3;
	else
		return 10000; //Invalid settings
     3ca:	80 e1       	ldi	r24, 0x10	; 16
     3cc:	97 e2       	ldi	r25, 0x27	; 39
	
	xSemaphoreTake(ConversionCompleteSema,portMAX_DELAY);
	Res=ADCA.CH0.RES;
	xSemaphoreGive(AdcBusySema);
	return Res;
}
     3ce:	df 91       	pop	r29
     3d0:	cf 91       	pop	r28
     3d2:	08 95       	ret
	
	xSemaphoreTake(AdcBusySema,portMAX_DELAY);
	
	//Configure channels
	if (PinPos<16 && PinPos>=0)
		ADCA.CH0.MUXCTRL=PinPos<<3;
     3d4:	cc 0f       	add	r28, r28
     3d6:	cc 0f       	add	r28, r28
     3d8:	cc 0f       	add	r28, r28
     3da:	c0 93 21 02 	sts	0x0221, r28	; 0x800221 <__TEXT_REGION_LENGTH__+0x700221>
	if (PinNeg==-1) 
		{			
		ADCA.CH0.CTRL=0b00000001; //Single ended mode, no gain
		ADCA.CTRLB&=~0b00010000;  //Unsigned mode		
		}		
	else if (PinNeg>=0 && PinNeg<4)
     3de:	d4 30       	cpi	r29, 0x04	; 4
     3e0:	80 f1       	brcs	.+96     	; 0x442 <__LOCK_REGION_LENGTH__+0x42>
		{			
		ADCA.CH0.CTRL=0b00000010; //Differential mode, no gain
		ADCA.CTRLB|=0b00010000;   //Signed mode
		ADCA.CH0.MUXCTRL|=PinNeg;
		}						
	else if (PinNeg>=4 && PinNeg<8)
     3e2:	d4 50       	subi	r29, 0x04	; 4
     3e4:	d4 30       	cpi	r29, 0x04	; 4
     3e6:	88 f7       	brcc	.-30     	; 0x3ca <DriverAdcGetCh+0x1c>
		{
		ADCA.CH0.CTRL=0b00000011; //Differential mode, 1X gain
     3e8:	83 e0       	ldi	r24, 0x03	; 3
     3ea:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
		ADCA.CTRLB|=0b00010000;
     3ee:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
     3f2:	80 61       	ori	r24, 0x10	; 16
     3f4:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
		ADCA.CH0.MUXCTRL|=(PinNeg-4);	
     3f8:	80 91 21 02 	lds	r24, 0x0221	; 0x800221 <__TEXT_REGION_LENGTH__+0x700221>
     3fc:	d8 2b       	or	r29, r24
     3fe:	d0 93 21 02 	sts	0x0221, r29	; 0x800221 <__TEXT_REGION_LENGTH__+0x700221>
		}
	else return 10000; //Invalid settings
	
	//Start measurement
	ADCA.CH0.CTRL|=0b10000000; //Start conversion
     402:	80 91 20 02 	lds	r24, 0x0220	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
     406:	80 68       	ori	r24, 0x80	; 128
     408:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
	
	xSemaphoreTake(ConversionCompleteSema,portMAX_DELAY);
     40c:	6f ef       	ldi	r22, 0xFF	; 255
     40e:	7f ef       	ldi	r23, 0xFF	; 255
     410:	80 91 9a 68 	lds	r24, 0x689A	; 0x80689a <ConversionCompleteSema>
     414:	90 91 9b 68 	lds	r25, 0x689B	; 0x80689b <ConversionCompleteSema+0x1>
     418:	0e 94 ab 13 	call	0x2756	; 0x2756 <xQueueSemaphoreTake>
	Res=ADCA.CH0.RES;
     41c:	c0 91 24 02 	lds	r28, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
     420:	d0 91 25 02 	lds	r29, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
	xSemaphoreGive(AdcBusySema);
     424:	20 e0       	ldi	r18, 0x00	; 0
     426:	40 e0       	ldi	r20, 0x00	; 0
     428:	50 e0       	ldi	r21, 0x00	; 0
     42a:	60 e0       	ldi	r22, 0x00	; 0
     42c:	70 e0       	ldi	r23, 0x00	; 0
     42e:	80 91 9c 68 	lds	r24, 0x689C	; 0x80689c <AdcBusySema>
     432:	90 91 9d 68 	lds	r25, 0x689D	; 0x80689d <AdcBusySema+0x1>
     436:	0e 94 71 11 	call	0x22e2	; 0x22e2 <xQueueGenericSend>
	return Res;
     43a:	ce 01       	movw	r24, r28
}
     43c:	df 91       	pop	r29
     43e:	cf 91       	pop	r28
     440:	08 95       	ret
		ADCA.CH0.CTRL=0b00000001; //Single ended mode, no gain
		ADCA.CTRLB&=~0b00010000;  //Unsigned mode		
		}		
	else if (PinNeg>=0 && PinNeg<4)
		{			
		ADCA.CH0.CTRL=0b00000010; //Differential mode, no gain
     442:	82 e0       	ldi	r24, 0x02	; 2
     444:	d2 cf       	rjmp	.-92     	; 0x3ea <DriverAdcGetCh+0x3c>

00000446 <__vector_71>:
	xSemaphoreGive(AdcBusySema);
	return Res;
}

ISR(ADCA_CH0_vect)
{
     446:	1f 92       	push	r1
     448:	0f 92       	push	r0
     44a:	0f b6       	in	r0, 0x3f	; 63
     44c:	0f 92       	push	r0
     44e:	11 24       	eor	r1, r1
     450:	0b b6       	in	r0, 0x3b	; 59
     452:	0f 92       	push	r0
     454:	2f 93       	push	r18
     456:	3f 93       	push	r19
     458:	4f 93       	push	r20
     45a:	5f 93       	push	r21
     45c:	6f 93       	push	r22
     45e:	7f 93       	push	r23
     460:	8f 93       	push	r24
     462:	9f 93       	push	r25
     464:	af 93       	push	r26
     466:	bf 93       	push	r27
     468:	ef 93       	push	r30
     46a:	ff 93       	push	r31
     46c:	cf 93       	push	r28
     46e:	df 93       	push	r29
     470:	1f 92       	push	r1
     472:	cd b7       	in	r28, 0x3d	; 61
     474:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
     476:	19 82       	std	Y+1, r1	; 0x01
	xSemaphoreGiveFromISR(ConversionCompleteSema,&xHigherPriorityTaskWoken);
     478:	be 01       	movw	r22, r28
     47a:	6f 5f       	subi	r22, 0xFF	; 255
     47c:	7f 4f       	sbci	r23, 0xFF	; 255
     47e:	80 91 9a 68 	lds	r24, 0x689A	; 0x80689a <ConversionCompleteSema>
     482:	90 91 9b 68 	lds	r25, 0x689B	; 0x80689b <ConversionCompleteSema+0x1>
     486:	0e 94 9b 12 	call	0x2536	; 0x2536 <xQueueGiveFromISR>
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     48a:	89 81       	ldd	r24, Y+1	; 0x01
     48c:	81 11       	cpse	r24, r1
     48e:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <vPortYieldISR>
     492:	0f 90       	pop	r0
     494:	df 91       	pop	r29
     496:	cf 91       	pop	r28
     498:	ff 91       	pop	r31
     49a:	ef 91       	pop	r30
     49c:	bf 91       	pop	r27
     49e:	af 91       	pop	r26
     4a0:	9f 91       	pop	r25
     4a2:	8f 91       	pop	r24
     4a4:	7f 91       	pop	r23
     4a6:	6f 91       	pop	r22
     4a8:	5f 91       	pop	r21
     4aa:	4f 91       	pop	r20
     4ac:	3f 91       	pop	r19
     4ae:	2f 91       	pop	r18
     4b0:	0f 90       	pop	r0
     4b2:	0b be       	out	0x3b, r0	; 59
     4b4:	0f 90       	pop	r0
     4b6:	0f be       	out	0x3f, r0	; 63
     4b8:	0f 90       	pop	r0
     4ba:	1f 90       	pop	r1
     4bc:	18 95       	reti

000004be <DriverAdps9960Init>:

#define REG_ID 0x92
#define ID 0xAB

void DriverAdps9960Init(void)
{
     4be:	0f 93       	push	r16
     4c0:	cf 93       	push	r28
     4c2:	df 93       	push	r29
     4c4:	1f 92       	push	r1
     4c6:	1f 92       	push	r1
     4c8:	cd b7       	in	r28, 0x3d	; 61
     4ca:	de b7       	in	r29, 0x3e	; 62
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=REG_ENABLE;
     4cc:	80 e8       	ldi	r24, 0x80	; 128
     4ce:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=(1<<REG_ENABLE_PON);
     4d0:	81 e0       	ldi	r24, 0x01	; 1
     4d2:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);
     4d4:	42 e0       	ldi	r20, 0x02	; 2
     4d6:	be 01       	movw	r22, r28
     4d8:	6f 5f       	subi	r22, 0xFF	; 255
     4da:	7f 4f       	sbci	r23, 0xFF	; 255
     4dc:	89 e3       	ldi	r24, 0x39	; 57
     4de:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
	//printf ("TwimWrite:%d\r\n",res);
	
	Buffer[0]=REG_ID;
     4e2:	82 e9       	ldi	r24, 0x92	; 146
     4e4:	89 83       	std	Y+1, r24	; 0x01
	res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,1);
     4e6:	01 e0       	ldi	r16, 0x01	; 1
     4e8:	9e 01       	movw	r18, r28
     4ea:	2f 5f       	subi	r18, 0xFF	; 255
     4ec:	3f 4f       	sbci	r19, 0xFF	; 255
     4ee:	41 e0       	ldi	r20, 0x01	; 1
     4f0:	b9 01       	movw	r22, r18
     4f2:	89 e3       	ldi	r24, 0x39	; 57
     4f4:	0e 94 14 0b 	call	0x1628	; 0x1628 <TWIMWriteRead>
	if (Buffer[0]!=ID)
     4f8:	89 81       	ldd	r24, Y+1	; 0x01
     4fa:	8b 3a       	cpi	r24, 0xAB	; 171
     4fc:	61 f0       	breq	.+24     	; 0x516 <DriverAdps9960Init+0x58>
		printf ("ADPS9960 ID readback fail: %d read\r\n",Buffer[0]);
     4fe:	1f 92       	push	r1
     500:	8f 93       	push	r24
     502:	80 e9       	ldi	r24, 0x90	; 144
     504:	90 e2       	ldi	r25, 0x20	; 32
     506:	9f 93       	push	r25
     508:	8f 93       	push	r24
     50a:	0e 94 04 2b 	call	0x5608	; 0x5608 <printf>
     50e:	0f 90       	pop	r0
     510:	0f 90       	pop	r0
     512:	0f 90       	pop	r0
     514:	0f 90       	pop	r0

	Buffer[0]=REG_ATIME;
     516:	81 e8       	ldi	r24, 0x81	; 129
     518:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=219; //100ms integration time
     51a:	8b ed       	ldi	r24, 0xDB	; 219
     51c:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);
     51e:	42 e0       	ldi	r20, 0x02	; 2
     520:	be 01       	movw	r22, r28
     522:	6f 5f       	subi	r22, 0xFF	; 255
     524:	7f 4f       	sbci	r23, 0xFF	; 255
     526:	89 e3       	ldi	r24, 0x39	; 57
     528:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>

	Buffer[0]=REG_CTRL1;
     52c:	8f e8       	ldi	r24, 0x8F	; 143
     52e:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=0b11<<REG_CTRL1_AGAIN; //max gain
     530:	83 e0       	ldi	r24, 0x03	; 3
     532:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);
     534:	42 e0       	ldi	r20, 0x02	; 2
     536:	be 01       	movw	r22, r28
     538:	6f 5f       	subi	r22, 0xFF	; 255
     53a:	7f 4f       	sbci	r23, 0xFF	; 255
     53c:	89 e3       	ldi	r24, 0x39	; 57
     53e:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>

}
     542:	0f 90       	pop	r0
     544:	0f 90       	pop	r0
     546:	df 91       	pop	r29
     548:	cf 91       	pop	r28
     54a:	0f 91       	pop	r16
     54c:	08 95       	ret

0000054e <DriverAdps9960Get>:

void DriverAdps9960Get(uint16_t *Clear,uint16_t *Red,uint16_t *Green, uint16_t *Blue)
{
     54e:	8f 92       	push	r8
     550:	9f 92       	push	r9
     552:	af 92       	push	r10
     554:	bf 92       	push	r11
     556:	cf 92       	push	r12
     558:	df 92       	push	r13
     55a:	ef 92       	push	r14
     55c:	ff 92       	push	r15
     55e:	0f 93       	push	r16
     560:	1f 93       	push	r17
     562:	cf 93       	push	r28
     564:	df 93       	push	r29
     566:	cd b7       	in	r28, 0x3d	; 61
     568:	de b7       	in	r29, 0x3e	; 62
     56a:	29 97       	sbiw	r28, 0x09	; 9
     56c:	cd bf       	out	0x3d, r28	; 61
     56e:	de bf       	out	0x3e, r29	; 62
     570:	4c 01       	movw	r8, r24
     572:	5b 01       	movw	r10, r22
     574:	6a 01       	movw	r12, r20
     576:	79 01       	movw	r14, r18
	uint8_t Buffer[9];
	uint16_t *C=(uint16_t *) &(Buffer[0]),*R=(uint16_t *) &(Buffer[2]),*G=(uint16_t *) &(Buffer[4]),*B=(uint16_t *) &(Buffer[6]);
	uint8_t *Status=&(Buffer[0]);


	Buffer[0]=REG_ENABLE;
     578:	80 e8       	ldi	r24, 0x80	; 128
     57a:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=(1<<REG_ENABLE_PON) | (1<<REG_ENABLE_AEN);
     57c:	83 e0       	ldi	r24, 0x03	; 3
     57e:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);
     580:	42 e0       	ldi	r20, 0x02	; 2
     582:	be 01       	movw	r22, r28
     584:	6f 5f       	subi	r22, 0xFF	; 255
     586:	7f 4f       	sbci	r23, 0xFF	; 255
     588:	89 e3       	ldi	r24, 0x39	; 57
     58a:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>


	do 
	{
		Buffer[0]=REG_STATUS;
     58e:	13 e9       	ldi	r17, 0x93	; 147
     590:	19 83       	std	Y+1, r17	; 0x01
		res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,1);
     592:	01 e0       	ldi	r16, 0x01	; 1
     594:	9e 01       	movw	r18, r28
     596:	2f 5f       	subi	r18, 0xFF	; 255
     598:	3f 4f       	sbci	r19, 0xFF	; 255
     59a:	41 e0       	ldi	r20, 0x01	; 1
     59c:	b9 01       	movw	r22, r18
     59e:	89 e3       	ldi	r24, 0x39	; 57
     5a0:	0e 94 14 0b 	call	0x1628	; 0x1628 <TWIMWriteRead>
		//printf ("STATUS:%d\r\n",Buffer[0]);
	} while (!(Buffer[0] & (1<<REG_STATUX_AVALID)) );
     5a4:	89 81       	ldd	r24, Y+1	; 0x01
     5a6:	80 ff       	sbrs	r24, 0
     5a8:	f3 cf       	rjmp	.-26     	; 0x590 <DriverAdps9960Get+0x42>


	Buffer[0]=REG_CDATA;
     5aa:	84 e9       	ldi	r24, 0x94	; 148
     5ac:	89 83       	std	Y+1, r24	; 0x01
	res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,8);
     5ae:	08 e0       	ldi	r16, 0x08	; 8
     5b0:	9e 01       	movw	r18, r28
     5b2:	2f 5f       	subi	r18, 0xFF	; 255
     5b4:	3f 4f       	sbci	r19, 0xFF	; 255
     5b6:	41 e0       	ldi	r20, 0x01	; 1
     5b8:	b9 01       	movw	r22, r18
     5ba:	89 e3       	ldi	r24, 0x39	; 57
     5bc:	0e 94 14 0b 	call	0x1628	; 0x1628 <TWIMWriteRead>
	//printf ("TwimWriteRead:%d\r\n",res);

	if (Clear!=NULL) *Clear=*C;	
     5c0:	81 14       	cp	r8, r1
     5c2:	91 04       	cpc	r9, r1
     5c4:	29 f0       	breq	.+10     	; 0x5d0 <DriverAdps9960Get+0x82>
     5c6:	89 81       	ldd	r24, Y+1	; 0x01
     5c8:	9a 81       	ldd	r25, Y+2	; 0x02
     5ca:	f4 01       	movw	r30, r8
     5cc:	80 83       	st	Z, r24
     5ce:	91 83       	std	Z+1, r25	; 0x01
	if (Red!=NULL) *Red=*R;
     5d0:	a1 14       	cp	r10, r1
     5d2:	b1 04       	cpc	r11, r1
     5d4:	29 f0       	breq	.+10     	; 0x5e0 <DriverAdps9960Get+0x92>
     5d6:	8b 81       	ldd	r24, Y+3	; 0x03
     5d8:	9c 81       	ldd	r25, Y+4	; 0x04
     5da:	f5 01       	movw	r30, r10
     5dc:	80 83       	st	Z, r24
     5de:	91 83       	std	Z+1, r25	; 0x01
	if (Green!=NULL) *Green=*G;
     5e0:	c1 14       	cp	r12, r1
     5e2:	d1 04       	cpc	r13, r1
     5e4:	29 f0       	breq	.+10     	; 0x5f0 <DriverAdps9960Get+0xa2>
     5e6:	8d 81       	ldd	r24, Y+5	; 0x05
     5e8:	9e 81       	ldd	r25, Y+6	; 0x06
     5ea:	f6 01       	movw	r30, r12
     5ec:	80 83       	st	Z, r24
     5ee:	91 83       	std	Z+1, r25	; 0x01
	if (Blue!=NULL) *Blue=*B;
     5f0:	e1 14       	cp	r14, r1
     5f2:	f1 04       	cpc	r15, r1
     5f4:	29 f0       	breq	.+10     	; 0x600 <DriverAdps9960Get+0xb2>
     5f6:	8f 81       	ldd	r24, Y+7	; 0x07
     5f8:	98 85       	ldd	r25, Y+8	; 0x08
     5fa:	f7 01       	movw	r30, r14
     5fc:	80 83       	st	Z, r24
     5fe:	91 83       	std	Z+1, r25	; 0x01

     600:	29 96       	adiw	r28, 0x09	; 9
     602:	cd bf       	out	0x3d, r28	; 61
     604:	de bf       	out	0x3e, r29	; 62
     606:	df 91       	pop	r29
     608:	cf 91       	pop	r28
     60a:	1f 91       	pop	r17
     60c:	0f 91       	pop	r16
     60e:	ff 90       	pop	r15
     610:	ef 90       	pop	r14
     612:	df 90       	pop	r13
     614:	cf 90       	pop	r12
     616:	bf 90       	pop	r11
     618:	af 90       	pop	r10
     61a:	9f 90       	pop	r9
     61c:	8f 90       	pop	r8
     61e:	08 95       	ret

00000620 <DriverCursorstickInit>:
#include "DriverCursorstick.h"

void DriverCursorstickInit(void)
{
	PORTB.DIRCLR=0b11111000;
     620:	e0 e2       	ldi	r30, 0x20	; 32
     622:	f6 e0       	ldi	r31, 0x06	; 6
     624:	88 ef       	ldi	r24, 0xF8	; 248
     626:	82 83       	std	Z+2, r24	; 0x02
	PORTB.PIN3CTRL=0b01011000; //Pull up, inverted
     628:	88 e5       	ldi	r24, 0x58	; 88
     62a:	83 8b       	std	Z+19, r24	; 0x13
	PORTB.PIN4CTRL=0b01011000; //Pull up, inverted	
     62c:	84 8b       	std	Z+20, r24	; 0x14
	PORTB.PIN5CTRL=0b01011000; //Pull up, inverted
     62e:	85 8b       	std	Z+21, r24	; 0x15
	PORTB.PIN6CTRL=0b01011000; //Pull up, inverted
     630:	86 8b       	std	Z+22, r24	; 0x16
	PORTB.PIN7CTRL=0b01011000; //Pull up, inverted
     632:	87 8b       	std	Z+23, r24	; 0x17
     634:	08 95       	ret

00000636 <DriverCursorstickGet>:
}

uint8_t DriverCursorstickGet(void)
{
	return PORTB.IN>>3;
     636:	80 91 28 06 	lds	r24, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     63a:	86 95       	lsr	r24
     63c:	86 95       	lsr	r24
     63e:	86 95       	lsr	r24
     640:	08 95       	ret

00000642 <DriverLedInit>:
}

void DriverLedWrite(uint8_t LedData)
{
	PORTB.OUT=(PORTB.OUT & 0b11111000) | (LedData & 0b00000111);
	PORTA.OUT=(PORTA.OUT & 0b01111111) | ((LedData & 0b00001000) << 4); 
     642:	e0 e2       	ldi	r30, 0x20	; 32
     644:	f6 e0       	ldi	r31, 0x06	; 6
     646:	87 e0       	ldi	r24, 0x07	; 7
     648:	81 83       	std	Z+1, r24	; 0x01
     64a:	80 e4       	ldi	r24, 0x40	; 64
     64c:	80 8b       	std	Z+16, r24	; 0x10
     64e:	81 8b       	std	Z+17, r24	; 0x11
     650:	82 8b       	std	Z+18, r24	; 0x12
     652:	e0 e0       	ldi	r30, 0x00	; 0
     654:	f6 e0       	ldi	r31, 0x06	; 6
     656:	90 e8       	ldi	r25, 0x80	; 128
     658:	91 83       	std	Z+1, r25	; 0x01
     65a:	87 8b       	std	Z+23, r24	; 0x17
     65c:	08 95       	ret

0000065e <DriverLedSet>:
}

void DriverLedSet(uint8_t LedData)
{
	PORTB.OUT=PORTB.OUT | (LedData & 0b00000111);
     65e:	e0 e2       	ldi	r30, 0x20	; 32
     660:	f6 e0       	ldi	r31, 0x06	; 6
     662:	94 81       	ldd	r25, Z+4	; 0x04
     664:	28 2f       	mov	r18, r24
     666:	27 70       	andi	r18, 0x07	; 7
     668:	92 2b       	or	r25, r18
     66a:	94 83       	std	Z+4, r25	; 0x04
	PORTA.OUT=PORTA.OUT | ((LedData & 0b00001000) << 4);
     66c:	e0 e0       	ldi	r30, 0x00	; 0
     66e:	f6 e0       	ldi	r31, 0x06	; 6
     670:	94 81       	ldd	r25, Z+4	; 0x04
     672:	88 70       	andi	r24, 0x08	; 8
     674:	82 95       	swap	r24
     676:	80 7f       	andi	r24, 0xF0	; 240
     678:	89 2b       	or	r24, r25
     67a:	84 83       	std	Z+4, r24	; 0x04
     67c:	08 95       	ret

0000067e <DriverLedClear>:
}

void DriverLedClear(uint8_t LedData)
{
	PORTB.OUT=PORTB.OUT & ~(LedData & 0b00000111);
     67e:	e0 e2       	ldi	r30, 0x20	; 32
     680:	f6 e0       	ldi	r31, 0x06	; 6
     682:	24 81       	ldd	r18, Z+4	; 0x04
     684:	98 2f       	mov	r25, r24
     686:	97 70       	andi	r25, 0x07	; 7
     688:	90 95       	com	r25
     68a:	92 23       	and	r25, r18
     68c:	94 83       	std	Z+4, r25	; 0x04
	PORTA.OUT=PORTA.OUT & ~((LedData & 0b00001000) << 4);
     68e:	e0 e0       	ldi	r30, 0x00	; 0
     690:	f6 e0       	ldi	r31, 0x06	; 6
     692:	94 81       	ldd	r25, Z+4	; 0x04
     694:	88 70       	andi	r24, 0x08	; 8
     696:	82 95       	swap	r24
     698:	80 7f       	andi	r24, 0xF0	; 240
     69a:	80 95       	com	r24
     69c:	89 23       	and	r24, r25
     69e:	84 83       	std	Z+4, r24	; 0x04
     6a0:	08 95       	ret

000006a2 <DriverLedToggle>:
}

void DriverLedToggle(uint8_t LedData)
{
	PORTB.OUT=PORTB.OUT ^ (LedData & 0b00000111);
     6a2:	e0 e2       	ldi	r30, 0x20	; 32
     6a4:	f6 e0       	ldi	r31, 0x06	; 6
     6a6:	94 81       	ldd	r25, Z+4	; 0x04
     6a8:	28 2f       	mov	r18, r24
     6aa:	27 70       	andi	r18, 0x07	; 7
     6ac:	92 27       	eor	r25, r18
     6ae:	94 83       	std	Z+4, r25	; 0x04
	PORTA.OUT=PORTA.OUT ^ ((LedData & 0b00001000) << 4);
     6b0:	e0 e0       	ldi	r30, 0x00	; 0
     6b2:	f6 e0       	ldi	r31, 0x06	; 6
     6b4:	94 81       	ldd	r25, Z+4	; 0x04
     6b6:	88 70       	andi	r24, 0x08	; 8
     6b8:	82 95       	swap	r24
     6ba:	80 7f       	andi	r24, 0xF0	; 240
     6bc:	89 27       	eor	r24, r25
     6be:	84 83       	std	Z+4, r24	; 0x04
     6c0:	08 95       	ret

000006c2 <DriverMotorInit>:
QueueHandle_t EncoderQueue;

void DriverMotorInit(void)
{
	//GPIO init
	PORTF.DIRSET=0b11111;
     6c2:	e0 ea       	ldi	r30, 0xA0	; 160
     6c4:	f6 e0       	ldi	r31, 0x06	; 6
     6c6:	8f e1       	ldi	r24, 0x1F	; 31
     6c8:	81 83       	std	Z+1, r24	; 0x01
	PORTF.PIN4CTRL=0b01000000; //Invert
     6ca:	20 e4       	ldi	r18, 0x40	; 64
     6cc:	24 8b       	std	Z+20, r18	; 0x14
	PORTF.OUTSET=0b10000; //Sleep enable
     6ce:	90 e1       	ldi	r25, 0x10	; 16
     6d0:	95 83       	std	Z+5, r25	; 0x05
	
	//Timer init, hbridge
	TCF0.CTRLA=0b00000001; //DIV1
     6d2:	e0 e0       	ldi	r30, 0x00	; 0
     6d4:	fb e0       	ldi	r31, 0x0B	; 11
     6d6:	81 e0       	ldi	r24, 0x01	; 1
     6d8:	80 83       	st	Z, r24
	TCF0.CTRLB=0b11110011; //OCA,OCB,OCC,OCD enable, SS PWM
     6da:	33 ef       	ldi	r19, 0xF3	; 243
     6dc:	31 83       	std	Z+1, r19	; 0x01
	TCF0.PER=4096; //7812 Hz PWM
     6de:	40 e0       	ldi	r20, 0x00	; 0
     6e0:	50 e1       	ldi	r21, 0x10	; 16
     6e2:	46 a3       	std	Z+38, r20	; 0x26
     6e4:	57 a3       	std	Z+39, r21	; 0x27
	
	//Encoder 1
	PORTC.DIRCLR=0b11000000; 
     6e6:	e0 e4       	ldi	r30, 0x40	; 64
     6e8:	f6 e0       	ldi	r31, 0x06	; 6
     6ea:	30 ec       	ldi	r19, 0xC0	; 192
     6ec:	32 83       	std	Z+2, r19	; 0x02
	PORTC.PIN6CTRL=0b01000000; //falling edge detect
     6ee:	26 8b       	std	Z+22, r18	; 0x16
	EVSYS_CH0MUX=0b01100000 + 6; //EVCH0 mapped to PC6
     6f0:	36 e6       	ldi	r19, 0x66	; 102
     6f2:	30 93 80 01 	sts	0x0180, r19	; 0x800180 <__TEXT_REGION_LENGTH__+0x700180>
	EVSYS_CH0CTRL=0b111; //8 samples filter
     6f6:	47 e0       	ldi	r20, 0x07	; 7
     6f8:	40 93 88 01 	sts	0x0188, r20	; 0x800188 <__TEXT_REGION_LENGTH__+0x700188>
	TCD0.CTRLA=0b00000110; //DIV256
     6fc:	e0 e0       	ldi	r30, 0x00	; 0
     6fe:	f9 e0       	ldi	r31, 0x09	; 9
     700:	36 e0       	ldi	r19, 0x06	; 6
     702:	30 83       	st	Z, r19
	TCD0.CTRLB=0b00010000; //CCAenable
     704:	91 83       	std	Z+1, r25	; 0x01
	TCD0.CTRLD=0b10101000; //FRQ, EVCH 0
     706:	58 ea       	ldi	r21, 0xA8	; 168
     708:	53 83       	std	Z+3, r21	; 0x03
	TCD0.INTCTRLA=0b00000001; //OVF INT
     70a:	86 83       	std	Z+6, r24	; 0x06
	TCD0.INTCTRLB=0b01; //CCA INT
     70c:	87 83       	std	Z+7, r24	; 0x07
	
	//Encoder 2
	PORTE.DIRCLR=0b00110000;
     70e:	e0 e8       	ldi	r30, 0x80	; 128
     710:	f6 e0       	ldi	r31, 0x06	; 6
     712:	50 e3       	ldi	r21, 0x30	; 48
     714:	52 83       	std	Z+2, r21	; 0x02
	PORTE.PIN4CTRL=0b01000000; //falling edge detect
     716:	24 8b       	std	Z+20, r18	; 0x14
	EVSYS_CH1MUX=0b01110000 + 4; //EVCH1 mapped to PE4
     718:	24 e7       	ldi	r18, 0x74	; 116
     71a:	20 93 81 01 	sts	0x0181, r18	; 0x800181 <__TEXT_REGION_LENGTH__+0x700181>
	EVSYS_CH1CTRL=0b111; //8 samples filter
     71e:	40 93 89 01 	sts	0x0189, r20	; 0x800189 <__TEXT_REGION_LENGTH__+0x700189>
	TCE0.CTRLA=0b00000110; //DIV256
     722:	e0 e0       	ldi	r30, 0x00	; 0
     724:	fa e0       	ldi	r31, 0x0A	; 10
     726:	30 83       	st	Z, r19
	TCE0.CTRLB=0b00010000; //CCAenable
     728:	91 83       	std	Z+1, r25	; 0x01
	TCE0.CTRLD=0b10101001; //FRQ, EVCH 1
     72a:	99 ea       	ldi	r25, 0xA9	; 169
     72c:	93 83       	std	Z+3, r25	; 0x03
	TCE0.INTCTRLA=0b00000001; //OVF INT
     72e:	86 83       	std	Z+6, r24	; 0x06
	TCE0.INTCTRLB=0b01; //CCA INT
     730:	87 83       	std	Z+7, r24	; 0x07
	
	//RTOS
	EncoderQueue=xQueueCreate(1,sizeof(EncoderRawStruct));
     732:	40 e0       	ldi	r20, 0x00	; 0
     734:	68 e0       	ldi	r22, 0x08	; 8
     736:	0e 94 2d 11 	call	0x225a	; 0x225a <xQueueGenericCreate>
     73a:	80 93 9e 68 	sts	0x689E, r24	; 0x80689e <EncoderQueue>
     73e:	90 93 9f 68 	sts	0x689F, r25	; 0x80689f <EncoderQueue+0x1>
	xQueueOverwrite(EncoderQueue,&EncoderRawInfo);
     742:	22 e0       	ldi	r18, 0x02	; 2
     744:	40 e0       	ldi	r20, 0x00	; 0
     746:	50 e0       	ldi	r21, 0x00	; 0
     748:	64 eb       	ldi	r22, 0xB4	; 180
     74a:	73 e2       	ldi	r23, 0x23	; 35
     74c:	0c 94 71 11 	jmp	0x22e2	; 0x22e2 <xQueueGenericSend>

00000750 <DriverMotorSet>:

void DriverMotorSet(int16_t MotorLeft,int16_t MotorRight)
{
	//Sleep mode handling
	if (MotorLeft==0 && MotorRight==0)
		PORTF.OUTSET=0b10000; //DRV8833 in sleep mode
     750:	20 e1       	ldi	r18, 0x10	; 16


void DriverMotorSet(int16_t MotorLeft,int16_t MotorRight)
{
	//Sleep mode handling
	if (MotorLeft==0 && MotorRight==0)
     752:	00 97       	sbiw	r24, 0x00	; 0
     754:	51 f5       	brne	.+84     	; 0x7aa <DriverMotorSet+0x5a>
     756:	61 15       	cp	r22, r1
     758:	71 05       	cpc	r23, r1
     75a:	09 f4       	brne	.+2      	; 0x75e <DriverMotorSet+0xe>
     75c:	51 c0       	rjmp	.+162    	; 0x800 <DriverMotorSet+0xb0>
		PORTF.OUTSET=0b10000; //DRV8833 in sleep mode
	else
		PORTF.OUTCLR=0b10000; //DRV8833 in active mode
     75e:	20 93 a6 06 	sts	0x06A6, r18	; 0x8006a6 <__TEXT_REGION_LENGTH__+0x7006a6>
		TCF0.CCB=MotorLeft;
	}
	else
	{
		if (MotorLeft<-4095) MotorLeft=-4095;
		TCF0.CCA=-MotorLeft;	
     762:	81 30       	cpi	r24, 0x01	; 1
     764:	20 ef       	ldi	r18, 0xF0	; 240
     766:	92 07       	cpc	r25, r18
     768:	0c f4       	brge	.+2      	; 0x76c <DriverMotorSet+0x1c>
     76a:	51 c0       	rjmp	.+162    	; 0x80e <DriverMotorSet+0xbe>
     76c:	91 95       	neg	r25
     76e:	81 95       	neg	r24
     770:	91 09       	sbc	r25, r1
     772:	80 93 28 0b 	sts	0x0B28, r24	; 0x800b28 <__TEXT_REGION_LENGTH__+0x700b28>
     776:	90 93 29 0b 	sts	0x0B29, r25	; 0x800b29 <__TEXT_REGION_LENGTH__+0x700b29>
		TCF0.CCB=0;
     77a:	10 92 2a 0b 	sts	0x0B2A, r1	; 0x800b2a <__TEXT_REGION_LENGTH__+0x700b2a>
     77e:	10 92 2b 0b 	sts	0x0B2B, r1	; 0x800b2b <__TEXT_REGION_LENGTH__+0x700b2b>
	}

	//Right motor
	if (MotorRight>0)
     782:	16 16       	cp	r1, r22
     784:	17 06       	cpc	r1, r23
     786:	2c f1       	brlt	.+74     	; 0x7d2 <DriverMotorSet+0x82>
		TCF0.CCD=MotorRight;
	}
	else
	{
		if (MotorRight<-4095) MotorRight=-4095;
		TCF0.CCC=-MotorRight;
     788:	61 30       	cpi	r22, 0x01	; 1
     78a:	20 ef       	ldi	r18, 0xF0	; 240
     78c:	72 07       	cpc	r23, r18
     78e:	0c f4       	brge	.+2      	; 0x792 <DriverMotorSet+0x42>
     790:	41 c0       	rjmp	.+130    	; 0x814 <DriverMotorSet+0xc4>
     792:	71 95       	neg	r23
     794:	61 95       	neg	r22
     796:	71 09       	sbc	r23, r1
     798:	60 93 2c 0b 	sts	0x0B2C, r22	; 0x800b2c <__TEXT_REGION_LENGTH__+0x700b2c>
     79c:	70 93 2d 0b 	sts	0x0B2D, r23	; 0x800b2d <__TEXT_REGION_LENGTH__+0x700b2d>
		TCF0.CCD=0;
     7a0:	10 92 2e 0b 	sts	0x0B2E, r1	; 0x800b2e <__TEXT_REGION_LENGTH__+0x700b2e>
     7a4:	10 92 2f 0b 	sts	0x0B2F, r1	; 0x800b2f <__TEXT_REGION_LENGTH__+0x700b2f>
	}
	
}
     7a8:	08 95       	ret
{
	//Sleep mode handling
	if (MotorLeft==0 && MotorRight==0)
		PORTF.OUTSET=0b10000; //DRV8833 in sleep mode
	else
		PORTF.OUTCLR=0b10000; //DRV8833 in active mode
     7aa:	20 93 a6 06 	sts	0x06A6, r18	; 0x8006a6 <__TEXT_REGION_LENGTH__+0x7006a6>
	
	//Left motor
	if (MotorLeft>0)
     7ae:	18 16       	cp	r1, r24
     7b0:	19 06       	cpc	r1, r25
     7b2:	bc f6       	brge	.-82     	; 0x762 <DriverMotorSet+0x12>
	{
		if (MotorLeft>4095) MotorLeft=4095;
		TCF0.CCA=0;
     7b4:	10 92 28 0b 	sts	0x0B28, r1	; 0x800b28 <__TEXT_REGION_LENGTH__+0x700b28>
     7b8:	10 92 29 0b 	sts	0x0B29, r1	; 0x800b29 <__TEXT_REGION_LENGTH__+0x700b29>
		TCF0.CCB=MotorLeft;
     7bc:	81 15       	cp	r24, r1
     7be:	20 e1       	ldi	r18, 0x10	; 16
     7c0:	92 07       	cpc	r25, r18
     7c2:	dc f4       	brge	.+54     	; 0x7fa <DriverMotorSet+0xaa>
     7c4:	80 93 2a 0b 	sts	0x0B2A, r24	; 0x800b2a <__TEXT_REGION_LENGTH__+0x700b2a>
     7c8:	90 93 2b 0b 	sts	0x0B2B, r25	; 0x800b2b <__TEXT_REGION_LENGTH__+0x700b2b>
		TCF0.CCA=-MotorLeft;	
		TCF0.CCB=0;
	}

	//Right motor
	if (MotorRight>0)
     7cc:	16 16       	cp	r1, r22
     7ce:	17 06       	cpc	r1, r23
     7d0:	dc f6       	brge	.-74     	; 0x788 <DriverMotorSet+0x38>
	{
		if (MotorRight>4095) MotorRight=4095;
		TCF0.CCC=0;
     7d2:	10 92 2c 0b 	sts	0x0B2C, r1	; 0x800b2c <__TEXT_REGION_LENGTH__+0x700b2c>
     7d6:	10 92 2d 0b 	sts	0x0B2D, r1	; 0x800b2d <__TEXT_REGION_LENGTH__+0x700b2d>
		TCF0.CCD=MotorRight;
     7da:	61 15       	cp	r22, r1
     7dc:	80 e1       	ldi	r24, 0x10	; 16
     7de:	78 07       	cpc	r23, r24
     7e0:	2c f4       	brge	.+10     	; 0x7ec <DriverMotorSet+0x9c>
     7e2:	60 93 2e 0b 	sts	0x0B2E, r22	; 0x800b2e <__TEXT_REGION_LENGTH__+0x700b2e>
     7e6:	70 93 2f 0b 	sts	0x0B2F, r23	; 0x800b2f <__TEXT_REGION_LENGTH__+0x700b2f>
     7ea:	08 95       	ret
     7ec:	6f ef       	ldi	r22, 0xFF	; 255
     7ee:	7f e0       	ldi	r23, 0x0F	; 15
     7f0:	60 93 2e 0b 	sts	0x0B2E, r22	; 0x800b2e <__TEXT_REGION_LENGTH__+0x700b2e>
     7f4:	70 93 2f 0b 	sts	0x0B2F, r23	; 0x800b2f <__TEXT_REGION_LENGTH__+0x700b2f>
     7f8:	08 95       	ret
	//Left motor
	if (MotorLeft>0)
	{
		if (MotorLeft>4095) MotorLeft=4095;
		TCF0.CCA=0;
		TCF0.CCB=MotorLeft;
     7fa:	8f ef       	ldi	r24, 0xFF	; 255
     7fc:	9f e0       	ldi	r25, 0x0F	; 15
     7fe:	e2 cf       	rjmp	.-60     	; 0x7c4 <DriverMotorSet+0x74>

void DriverMotorSet(int16_t MotorLeft,int16_t MotorRight)
{
	//Sleep mode handling
	if (MotorLeft==0 && MotorRight==0)
		PORTF.OUTSET=0b10000; //DRV8833 in sleep mode
     800:	20 93 a5 06 	sts	0x06A5, r18	; 0x8006a5 <__TEXT_REGION_LENGTH__+0x7006a5>
		TCF0.CCB=MotorLeft;
	}
	else
	{
		if (MotorLeft<-4095) MotorLeft=-4095;
		TCF0.CCA=-MotorLeft;	
     804:	81 30       	cpi	r24, 0x01	; 1
     806:	20 ef       	ldi	r18, 0xF0	; 240
     808:	92 07       	cpc	r25, r18
     80a:	0c f0       	brlt	.+2      	; 0x80e <DriverMotorSet+0xbe>
     80c:	af cf       	rjmp	.-162    	; 0x76c <DriverMotorSet+0x1c>
     80e:	81 e0       	ldi	r24, 0x01	; 1
     810:	90 ef       	ldi	r25, 0xF0	; 240
     812:	ac cf       	rjmp	.-168    	; 0x76c <DriverMotorSet+0x1c>
		TCF0.CCD=MotorRight;
	}
	else
	{
		if (MotorRight<-4095) MotorRight=-4095;
		TCF0.CCC=-MotorRight;
     814:	61 e0       	ldi	r22, 0x01	; 1
     816:	70 ef       	ldi	r23, 0xF0	; 240
     818:	bc cf       	rjmp	.-136    	; 0x792 <DriverMotorSet+0x42>

0000081a <DriverMotorGetEncoder>:
	}
	
}

EncoderStruct DriverMotorGetEncoder(void)
{
     81a:	0f 93       	push	r16
     81c:	1f 93       	push	r17
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
     822:	cd b7       	in	r28, 0x3d	; 61
     824:	de b7       	in	r29, 0x3e	; 62
     826:	28 97       	sbiw	r28, 0x08	; 8
     828:	cd bf       	out	0x3d, r28	; 61
     82a:	de bf       	out	0x3e, r29	; 62
	EncoderStruct EncoderInfo;
	EncoderRawStruct EncoderRawInfo;
	
	xQueuePeek(EncoderQueue,&EncoderRawInfo,portMAX_DELAY);
     82c:	4f ef       	ldi	r20, 0xFF	; 255
     82e:	5f ef       	ldi	r21, 0xFF	; 255
     830:	be 01       	movw	r22, r28
     832:	6f 5f       	subi	r22, 0xFF	; 255
     834:	7f 4f       	sbci	r23, 0xFF	; 255
     836:	80 91 9e 68 	lds	r24, 0x689E	; 0x80689e <EncoderQueue>
     83a:	90 91 9f 68 	lds	r25, 0x689F	; 0x80689f <EncoderQueue+0x1>
     83e:	0e 94 57 14 	call	0x28ae	; 0x28ae <xQueuePeek>
	
	if (EncoderRawInfo.Period1==0) 
     842:	29 81       	ldd	r18, Y+1	; 0x01
     844:	3a 81       	ldd	r19, Y+2	; 0x02
     846:	4b 81       	ldd	r20, Y+3	; 0x03
     848:	5c 81       	ldd	r21, Y+4	; 0x04
     84a:	21 15       	cp	r18, r1
     84c:	31 05       	cpc	r19, r1
     84e:	41 05       	cpc	r20, r1
     850:	51 05       	cpc	r21, r1
     852:	01 f1       	breq	.+64     	; 0x894 <DriverMotorGetEncoder+0x7a>
		EncoderInfo.Speed1=0;
	else
		EncoderInfo.Speed1=(uint32_t) RPM_CST / (uint32_t) EncoderRawInfo.Period1;
     854:	60 e7       	ldi	r22, 0x70	; 112
     856:	78 e3       	ldi	r23, 0x38	; 56
     858:	89 e3       	ldi	r24, 0x39	; 57
     85a:	90 e0       	ldi	r25, 0x00	; 0
     85c:	0e 94 a8 29 	call	0x5350	; 0x5350 <__udivmodsi4>
     860:	89 01       	movw	r16, r18
		
	if (EncoderRawInfo.Period2==0)
     862:	2d 81       	ldd	r18, Y+5	; 0x05
     864:	3e 81       	ldd	r19, Y+6	; 0x06
     866:	4f 81       	ldd	r20, Y+7	; 0x07
     868:	58 85       	ldd	r21, Y+8	; 0x08
     86a:	21 15       	cp	r18, r1
     86c:	31 05       	cpc	r19, r1
     86e:	41 05       	cpc	r20, r1
     870:	51 05       	cpc	r21, r1
     872:	99 f0       	breq	.+38     	; 0x89a <DriverMotorGetEncoder+0x80>
		EncoderInfo.Speed2=0;	
	else	
		EncoderInfo.Speed2=(uint32_t) RPM_CST / (uint32_t) EncoderRawInfo.Period2;
     874:	60 e7       	ldi	r22, 0x70	; 112
     876:	78 e3       	ldi	r23, 0x38	; 56
     878:	89 e3       	ldi	r24, 0x39	; 57
     87a:	90 e0       	ldi	r25, 0x00	; 0
     87c:	0e 94 a8 29 	call	0x5350	; 0x5350 <__udivmodsi4>
	
	return EncoderInfo;
     880:	b8 01       	movw	r22, r16
     882:	c9 01       	movw	r24, r18
}
     884:	28 96       	adiw	r28, 0x08	; 8
     886:	cd bf       	out	0x3d, r28	; 61
     888:	de bf       	out	0x3e, r29	; 62
     88a:	df 91       	pop	r29
     88c:	cf 91       	pop	r28
     88e:	1f 91       	pop	r17
     890:	0f 91       	pop	r16
     892:	08 95       	ret
	EncoderRawStruct EncoderRawInfo;
	
	xQueuePeek(EncoderQueue,&EncoderRawInfo,portMAX_DELAY);
	
	if (EncoderRawInfo.Period1==0) 
		EncoderInfo.Speed1=0;
     894:	00 e0       	ldi	r16, 0x00	; 0
     896:	10 e0       	ldi	r17, 0x00	; 0
     898:	e4 cf       	rjmp	.-56     	; 0x862 <DriverMotorGetEncoder+0x48>
	else
		EncoderInfo.Speed1=(uint32_t) RPM_CST / (uint32_t) EncoderRawInfo.Period1;
		
	if (EncoderRawInfo.Period2==0)
		EncoderInfo.Speed2=0;	
     89a:	20 e0       	ldi	r18, 0x00	; 0
     89c:	30 e0       	ldi	r19, 0x00	; 0
     89e:	f0 cf       	rjmp	.-32     	; 0x880 <DriverMotorGetEncoder+0x66>

000008a0 <__vector_77>:
}


//Encoder 1 ISR
ISR(TCD0_OVF_vect)
{
     8a0:	1f 92       	push	r1
     8a2:	0f 92       	push	r0
     8a4:	0f b6       	in	r0, 0x3f	; 63
     8a6:	0f 92       	push	r0
     8a8:	11 24       	eor	r1, r1
     8aa:	0b b6       	in	r0, 0x3b	; 59
     8ac:	0f 92       	push	r0
     8ae:	2f 93       	push	r18
     8b0:	3f 93       	push	r19
     8b2:	4f 93       	push	r20
     8b4:	5f 93       	push	r21
     8b6:	6f 93       	push	r22
     8b8:	7f 93       	push	r23
     8ba:	8f 93       	push	r24
     8bc:	9f 93       	push	r25
     8be:	af 93       	push	r26
     8c0:	bf 93       	push	r27
     8c2:	ef 93       	push	r30
     8c4:	ff 93       	push	r31
     8c6:	cf 93       	push	r28
     8c8:	df 93       	push	r29
     8ca:	1f 92       	push	r1
     8cc:	cd b7       	in	r28, 0x3d	; 61
     8ce:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
     8d0:	19 82       	std	Y+1, r1	; 0x01
	
	EncoderRawInfo.Period1=0;
     8d2:	10 92 b4 23 	sts	0x23B4, r1	; 0x8023b4 <EncoderRawInfo>
     8d6:	10 92 b5 23 	sts	0x23B5, r1	; 0x8023b5 <EncoderRawInfo+0x1>
     8da:	10 92 b6 23 	sts	0x23B6, r1	; 0x8023b6 <EncoderRawInfo+0x2>
     8de:	10 92 b7 23 	sts	0x23B7, r1	; 0x8023b7 <EncoderRawInfo+0x3>

	xQueueOverwriteFromISR(EncoderQueue,&EncoderRawInfo,&xHigherPriorityTaskWoken);
     8e2:	22 e0       	ldi	r18, 0x02	; 2
     8e4:	ae 01       	movw	r20, r28
     8e6:	4f 5f       	subi	r20, 0xFF	; 255
     8e8:	5f 4f       	sbci	r21, 0xFF	; 255
     8ea:	64 eb       	ldi	r22, 0xB4	; 180
     8ec:	73 e2       	ldi	r23, 0x23	; 35
     8ee:	80 91 9e 68 	lds	r24, 0x689E	; 0x80689e <EncoderQueue>
     8f2:	90 91 9f 68 	lds	r25, 0x689F	; 0x80689f <EncoderQueue+0x1>
     8f6:	0e 94 40 12 	call	0x2480	; 0x2480 <xQueueGenericSendFromISR>
	
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     8fa:	89 81       	ldd	r24, Y+1	; 0x01
     8fc:	81 11       	cpse	r24, r1
     8fe:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <vPortYieldISR>

}
     902:	0f 90       	pop	r0
     904:	df 91       	pop	r29
     906:	cf 91       	pop	r28
     908:	ff 91       	pop	r31
     90a:	ef 91       	pop	r30
     90c:	bf 91       	pop	r27
     90e:	af 91       	pop	r26
     910:	9f 91       	pop	r25
     912:	8f 91       	pop	r24
     914:	7f 91       	pop	r23
     916:	6f 91       	pop	r22
     918:	5f 91       	pop	r21
     91a:	4f 91       	pop	r20
     91c:	3f 91       	pop	r19
     91e:	2f 91       	pop	r18
     920:	0f 90       	pop	r0
     922:	0b be       	out	0x3b, r0	; 59
     924:	0f 90       	pop	r0
     926:	0f be       	out	0x3f, r0	; 63
     928:	0f 90       	pop	r0
     92a:	1f 90       	pop	r1
     92c:	18 95       	reti

0000092e <__vector_79>:

ISR(TCD0_CCA_vect) 
{
     92e:	1f 92       	push	r1
     930:	0f 92       	push	r0
     932:	0f b6       	in	r0, 0x3f	; 63
     934:	0f 92       	push	r0
     936:	11 24       	eor	r1, r1
     938:	0b b6       	in	r0, 0x3b	; 59
     93a:	0f 92       	push	r0
     93c:	2f 93       	push	r18
     93e:	3f 93       	push	r19
     940:	4f 93       	push	r20
     942:	5f 93       	push	r21
     944:	6f 93       	push	r22
     946:	7f 93       	push	r23
     948:	8f 93       	push	r24
     94a:	9f 93       	push	r25
     94c:	af 93       	push	r26
     94e:	bf 93       	push	r27
     950:	ef 93       	push	r30
     952:	ff 93       	push	r31
     954:	cf 93       	push	r28
     956:	df 93       	push	r29
     958:	1f 92       	push	r1
     95a:	cd b7       	in	r28, 0x3d	; 61
     95c:	de b7       	in	r29, 0x3e	; 62
	static uint8_t LedState;
	static uint16_t Period1=0;
	
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
     95e:	19 82       	std	Y+1, r1	; 0x01
	
	
	//Edge switch
	if (PORTC.PIN6CTRL & 0b01000000) PORTC.PIN6CTRL=0;
     960:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <__TEXT_REGION_LENGTH__+0x700656>
     964:	86 ff       	sbrs	r24, 6
     966:	2e c0       	rjmp	.+92     	; 0x9c4 <__vector_79+0x96>
     968:	10 92 56 06 	sts	0x0656, r1	; 0x800656 <__TEXT_REGION_LENGTH__+0x700656>
	else PORTC.PIN6CTRL=0b01000000;
	

	
	Period1+=(uint16_t) (TCD0.CCA);
     96c:	20 91 28 09 	lds	r18, 0x0928	; 0x800928 <__TEXT_REGION_LENGTH__+0x700928>
     970:	30 91 29 09 	lds	r19, 0x0929	; 0x800929 <__TEXT_REGION_LENGTH__+0x700929>
     974:	80 91 b2 23 	lds	r24, 0x23B2	; 0x8023b2 <Period1.4310>
     978:	90 91 b3 23 	lds	r25, 0x23B3	; 0x8023b3 <Period1.4310+0x1>
     97c:	82 0f       	add	r24, r18
     97e:	93 1f       	adc	r25, r19
     980:	80 93 b2 23 	sts	0x23B2, r24	; 0x8023b2 <Period1.4310>
     984:	90 93 b3 23 	sts	0x23B3, r25	; 0x8023b3 <Period1.4310+0x1>
	
	if (PORTC.PIN6CTRL & 0b01000000 && Period1>3000)
     988:	20 91 56 06 	lds	r18, 0x0656	; 0x800656 <__TEXT_REGION_LENGTH__+0x700656>
     98c:	26 ff       	sbrs	r18, 6
     98e:	04 c0       	rjmp	.+8      	; 0x998 <__vector_79+0x6a>
     990:	89 3b       	cpi	r24, 0xB9	; 185
     992:	2b e0       	ldi	r18, 0x0B	; 11
     994:	92 07       	cpc	r25, r18
     996:	d0 f4       	brcc	.+52     	; 0x9cc <__vector_79+0x9e>
		xQueueOverwriteFromISR(EncoderQueue,&EncoderRawInfo,&xHigherPriorityTaskWoken);	
		Period1=0;
	}
	
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
     998:	0f 90       	pop	r0
     99a:	df 91       	pop	r29
     99c:	cf 91       	pop	r28
     99e:	ff 91       	pop	r31
     9a0:	ef 91       	pop	r30
     9a2:	bf 91       	pop	r27
     9a4:	af 91       	pop	r26
     9a6:	9f 91       	pop	r25
     9a8:	8f 91       	pop	r24
     9aa:	7f 91       	pop	r23
     9ac:	6f 91       	pop	r22
     9ae:	5f 91       	pop	r21
     9b0:	4f 91       	pop	r20
     9b2:	3f 91       	pop	r19
     9b4:	2f 91       	pop	r18
     9b6:	0f 90       	pop	r0
     9b8:	0b be       	out	0x3b, r0	; 59
     9ba:	0f 90       	pop	r0
     9bc:	0f be       	out	0x3f, r0	; 63
     9be:	0f 90       	pop	r0
     9c0:	1f 90       	pop	r1
     9c2:	18 95       	reti
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	
	
	//Edge switch
	if (PORTC.PIN6CTRL & 0b01000000) PORTC.PIN6CTRL=0;
	else PORTC.PIN6CTRL=0b01000000;
     9c4:	80 e4       	ldi	r24, 0x40	; 64
     9c6:	80 93 56 06 	sts	0x0656, r24	; 0x800656 <__TEXT_REGION_LENGTH__+0x700656>
     9ca:	d0 cf       	rjmp	.-96     	; 0x96c <__vector_79+0x3e>
	
	Period1+=(uint16_t) (TCD0.CCA);
	
	if (PORTC.PIN6CTRL & 0b01000000 && Period1>3000)
	{
		EncoderRawInfo.Period1=Period1;
     9cc:	a0 e0       	ldi	r26, 0x00	; 0
     9ce:	b0 e0       	ldi	r27, 0x00	; 0
     9d0:	80 93 b4 23 	sts	0x23B4, r24	; 0x8023b4 <EncoderRawInfo>
     9d4:	90 93 b5 23 	sts	0x23B5, r25	; 0x8023b5 <EncoderRawInfo+0x1>
     9d8:	a0 93 b6 23 	sts	0x23B6, r26	; 0x8023b6 <EncoderRawInfo+0x2>
     9dc:	b0 93 b7 23 	sts	0x23B7, r27	; 0x8023b7 <EncoderRawInfo+0x3>
		xQueueOverwriteFromISR(EncoderQueue,&EncoderRawInfo,&xHigherPriorityTaskWoken);	
     9e0:	22 e0       	ldi	r18, 0x02	; 2
     9e2:	ae 01       	movw	r20, r28
     9e4:	4f 5f       	subi	r20, 0xFF	; 255
     9e6:	5f 4f       	sbci	r21, 0xFF	; 255
     9e8:	64 eb       	ldi	r22, 0xB4	; 180
     9ea:	73 e2       	ldi	r23, 0x23	; 35
     9ec:	80 91 9e 68 	lds	r24, 0x689E	; 0x80689e <EncoderQueue>
     9f0:	90 91 9f 68 	lds	r25, 0x689F	; 0x80689f <EncoderQueue+0x1>
     9f4:	0e 94 40 12 	call	0x2480	; 0x2480 <xQueueGenericSendFromISR>
		Period1=0;
     9f8:	10 92 b2 23 	sts	0x23B2, r1	; 0x8023b2 <Period1.4310>
     9fc:	10 92 b3 23 	sts	0x23B3, r1	; 0x8023b3 <Period1.4310+0x1>
	}
	
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     a00:	89 81       	ldd	r24, Y+1	; 0x01
     a02:	88 23       	and	r24, r24
     a04:	49 f2       	breq	.-110    	; 0x998 <__vector_79+0x6a>
     a06:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <vPortYieldISR>
}
     a0a:	c6 cf       	rjmp	.-116    	; 0x998 <__vector_79+0x6a>

00000a0c <__vector_47>:

//Encoder 2 ISR
ISR(TCE0_OVF_vect)
{
     a0c:	1f 92       	push	r1
     a0e:	0f 92       	push	r0
     a10:	0f b6       	in	r0, 0x3f	; 63
     a12:	0f 92       	push	r0
     a14:	11 24       	eor	r1, r1
     a16:	0b b6       	in	r0, 0x3b	; 59
     a18:	0f 92       	push	r0
     a1a:	2f 93       	push	r18
     a1c:	3f 93       	push	r19
     a1e:	4f 93       	push	r20
     a20:	5f 93       	push	r21
     a22:	6f 93       	push	r22
     a24:	7f 93       	push	r23
     a26:	8f 93       	push	r24
     a28:	9f 93       	push	r25
     a2a:	af 93       	push	r26
     a2c:	bf 93       	push	r27
     a2e:	ef 93       	push	r30
     a30:	ff 93       	push	r31
     a32:	cf 93       	push	r28
     a34:	df 93       	push	r29
     a36:	1f 92       	push	r1
     a38:	cd b7       	in	r28, 0x3d	; 61
     a3a:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
     a3c:	19 82       	std	Y+1, r1	; 0x01
	
	EncoderRawInfo.Period2=0;
     a3e:	10 92 b8 23 	sts	0x23B8, r1	; 0x8023b8 <EncoderRawInfo+0x4>
     a42:	10 92 b9 23 	sts	0x23B9, r1	; 0x8023b9 <EncoderRawInfo+0x5>
     a46:	10 92 ba 23 	sts	0x23BA, r1	; 0x8023ba <EncoderRawInfo+0x6>
     a4a:	10 92 bb 23 	sts	0x23BB, r1	; 0x8023bb <EncoderRawInfo+0x7>

	xQueueOverwriteFromISR(EncoderQueue,&EncoderRawInfo,&xHigherPriorityTaskWoken);
     a4e:	22 e0       	ldi	r18, 0x02	; 2
     a50:	ae 01       	movw	r20, r28
     a52:	4f 5f       	subi	r20, 0xFF	; 255
     a54:	5f 4f       	sbci	r21, 0xFF	; 255
     a56:	64 eb       	ldi	r22, 0xB4	; 180
     a58:	73 e2       	ldi	r23, 0x23	; 35
     a5a:	80 91 9e 68 	lds	r24, 0x689E	; 0x80689e <EncoderQueue>
     a5e:	90 91 9f 68 	lds	r25, 0x689F	; 0x80689f <EncoderQueue+0x1>
     a62:	0e 94 40 12 	call	0x2480	; 0x2480 <xQueueGenericSendFromISR>

	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     a66:	89 81       	ldd	r24, Y+1	; 0x01
     a68:	81 11       	cpse	r24, r1
     a6a:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <vPortYieldISR>
}
     a6e:	0f 90       	pop	r0
     a70:	df 91       	pop	r29
     a72:	cf 91       	pop	r28
     a74:	ff 91       	pop	r31
     a76:	ef 91       	pop	r30
     a78:	bf 91       	pop	r27
     a7a:	af 91       	pop	r26
     a7c:	9f 91       	pop	r25
     a7e:	8f 91       	pop	r24
     a80:	7f 91       	pop	r23
     a82:	6f 91       	pop	r22
     a84:	5f 91       	pop	r21
     a86:	4f 91       	pop	r20
     a88:	3f 91       	pop	r19
     a8a:	2f 91       	pop	r18
     a8c:	0f 90       	pop	r0
     a8e:	0b be       	out	0x3b, r0	; 59
     a90:	0f 90       	pop	r0
     a92:	0f be       	out	0x3f, r0	; 63
     a94:	0f 90       	pop	r0
     a96:	1f 90       	pop	r1
     a98:	18 95       	reti

00000a9a <__vector_49>:

ISR(TCE0_CCA_vect)
{
     a9a:	1f 92       	push	r1
     a9c:	0f 92       	push	r0
     a9e:	0f b6       	in	r0, 0x3f	; 63
     aa0:	0f 92       	push	r0
     aa2:	11 24       	eor	r1, r1
     aa4:	0b b6       	in	r0, 0x3b	; 59
     aa6:	0f 92       	push	r0
     aa8:	2f 93       	push	r18
     aaa:	3f 93       	push	r19
     aac:	4f 93       	push	r20
     aae:	5f 93       	push	r21
     ab0:	6f 93       	push	r22
     ab2:	7f 93       	push	r23
     ab4:	8f 93       	push	r24
     ab6:	9f 93       	push	r25
     ab8:	af 93       	push	r26
     aba:	bf 93       	push	r27
     abc:	ef 93       	push	r30
     abe:	ff 93       	push	r31
     ac0:	cf 93       	push	r28
     ac2:	df 93       	push	r29
     ac4:	1f 92       	push	r1
     ac6:	cd b7       	in	r28, 0x3d	; 61
     ac8:	de b7       	in	r29, 0x3e	; 62
	static uint16_t Period2=0;

	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
     aca:	19 82       	std	Y+1, r1	; 0x01
	
	//Debug
	DriverLedToggle(1<<3);
     acc:	88 e0       	ldi	r24, 0x08	; 8
     ace:	0e 94 51 03 	call	0x6a2	; 0x6a2 <DriverLedToggle>

	//Edge switch
	if (PORTE.PIN4CTRL & 0b01000000) PORTE.PIN4CTRL=0;
     ad2:	80 91 94 06 	lds	r24, 0x0694	; 0x800694 <__TEXT_REGION_LENGTH__+0x700694>
     ad6:	86 ff       	sbrs	r24, 6
     ad8:	32 c0       	rjmp	.+100    	; 0xb3e <__vector_49+0xa4>
     ada:	10 92 94 06 	sts	0x0694, r1	; 0x800694 <__TEXT_REGION_LENGTH__+0x700694>
	else PORTE.PIN4CTRL=0b01000000;
	
	Period2+=(uint16_t) (TCE0.CCA);
     ade:	20 91 28 0a 	lds	r18, 0x0A28	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
     ae2:	30 91 29 0a 	lds	r19, 0x0A29	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
     ae6:	80 91 b0 23 	lds	r24, 0x23B0	; 0x8023b0 <__data_end>
     aea:	90 91 b1 23 	lds	r25, 0x23B1	; 0x8023b1 <__data_end+0x1>
     aee:	82 0f       	add	r24, r18
     af0:	93 1f       	adc	r25, r19
     af2:	80 93 b0 23 	sts	0x23B0, r24	; 0x8023b0 <__data_end>
     af6:	90 93 b1 23 	sts	0x23B1, r25	; 0x8023b1 <__data_end+0x1>
	
	if (PORTE.PIN4CTRL & 0b01000000 && Period2>3000)
     afa:	20 91 94 06 	lds	r18, 0x0694	; 0x800694 <__TEXT_REGION_LENGTH__+0x700694>
     afe:	26 ff       	sbrs	r18, 6
     b00:	04 c0       	rjmp	.+8      	; 0xb0a <__vector_49+0x70>
     b02:	89 3b       	cpi	r24, 0xB9	; 185
     b04:	2b e0       	ldi	r18, 0x0B	; 11
     b06:	92 07       	cpc	r25, r18
     b08:	f0 f4       	brcc	.+60     	; 0xb46 <__vector_49+0xac>
		EncoderRawInfo.Period2=Period2;
		xQueueOverwriteFromISR(EncoderQueue,&EncoderRawInfo,&xHigherPriorityTaskWoken);
		Period2=0;
	}

	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     b0a:	89 81       	ldd	r24, Y+1	; 0x01
     b0c:	81 11       	cpse	r24, r1
     b0e:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <vPortYieldISR>
}
     b12:	0f 90       	pop	r0
     b14:	df 91       	pop	r29
     b16:	cf 91       	pop	r28
     b18:	ff 91       	pop	r31
     b1a:	ef 91       	pop	r30
     b1c:	bf 91       	pop	r27
     b1e:	af 91       	pop	r26
     b20:	9f 91       	pop	r25
     b22:	8f 91       	pop	r24
     b24:	7f 91       	pop	r23
     b26:	6f 91       	pop	r22
     b28:	5f 91       	pop	r21
     b2a:	4f 91       	pop	r20
     b2c:	3f 91       	pop	r19
     b2e:	2f 91       	pop	r18
     b30:	0f 90       	pop	r0
     b32:	0b be       	out	0x3b, r0	; 59
     b34:	0f 90       	pop	r0
     b36:	0f be       	out	0x3f, r0	; 63
     b38:	0f 90       	pop	r0
     b3a:	1f 90       	pop	r1
     b3c:	18 95       	reti
	//Debug
	DriverLedToggle(1<<3);

	//Edge switch
	if (PORTE.PIN4CTRL & 0b01000000) PORTE.PIN4CTRL=0;
	else PORTE.PIN4CTRL=0b01000000;
     b3e:	80 e4       	ldi	r24, 0x40	; 64
     b40:	80 93 94 06 	sts	0x0694, r24	; 0x800694 <__TEXT_REGION_LENGTH__+0x700694>
     b44:	cc cf       	rjmp	.-104    	; 0xade <__vector_49+0x44>
	
	Period2+=(uint16_t) (TCE0.CCA);
	
	if (PORTE.PIN4CTRL & 0b01000000 && Period2>3000)
	{
		EncoderRawInfo.Period2=Period2;
     b46:	a0 e0       	ldi	r26, 0x00	; 0
     b48:	b0 e0       	ldi	r27, 0x00	; 0
     b4a:	80 93 b8 23 	sts	0x23B8, r24	; 0x8023b8 <EncoderRawInfo+0x4>
     b4e:	90 93 b9 23 	sts	0x23B9, r25	; 0x8023b9 <EncoderRawInfo+0x5>
     b52:	a0 93 ba 23 	sts	0x23BA, r26	; 0x8023ba <EncoderRawInfo+0x6>
     b56:	b0 93 bb 23 	sts	0x23BB, r27	; 0x8023bb <EncoderRawInfo+0x7>
		xQueueOverwriteFromISR(EncoderQueue,&EncoderRawInfo,&xHigherPriorityTaskWoken);
     b5a:	22 e0       	ldi	r18, 0x02	; 2
     b5c:	ae 01       	movw	r20, r28
     b5e:	4f 5f       	subi	r20, 0xFF	; 255
     b60:	5f 4f       	sbci	r21, 0xFF	; 255
     b62:	64 eb       	ldi	r22, 0xB4	; 180
     b64:	73 e2       	ldi	r23, 0x23	; 35
     b66:	80 91 9e 68 	lds	r24, 0x689E	; 0x80689e <EncoderQueue>
     b6a:	90 91 9f 68 	lds	r25, 0x689F	; 0x80689f <EncoderQueue+0x1>
     b6e:	0e 94 40 12 	call	0x2480	; 0x2480 <xQueueGenericSendFromISR>
		Period2=0;
     b72:	10 92 b0 23 	sts	0x23B0, r1	; 0x8023b0 <__data_end>
     b76:	10 92 b1 23 	sts	0x23B1, r1	; 0x8023b1 <__data_end+0x1>
     b7a:	c7 cf       	rjmp	.-114    	; 0xb0a <__vector_49+0x70>

00000b7c <set_page_address>:
}

void DriverOLEDWake()
{
	send_command(0xAF);
}
     b7c:	1f 93       	push	r17
     b7e:	cf 93       	push	r28
     b80:	df 93       	push	r29
     b82:	1f 92       	push	r1
     b84:	1f 92       	push	r1
     b86:	cd b7       	in	r28, 0x3d	; 61
     b88:	de b7       	in	r29, 0x3e	; 62
     b8a:	10 e8       	ldi	r17, 0x80	; 128
     b8c:	19 83       	std	Y+1, r17	; 0x01
     b8e:	82 e2       	ldi	r24, 0x22	; 34
     b90:	8a 83       	std	Y+2, r24	; 0x02
     b92:	42 e0       	ldi	r20, 0x02	; 2
     b94:	be 01       	movw	r22, r28
     b96:	6f 5f       	subi	r22, 0xFF	; 255
     b98:	7f 4f       	sbci	r23, 0xFF	; 255
     b9a:	8c e3       	ldi	r24, 0x3C	; 60
     b9c:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
     ba0:	19 83       	std	Y+1, r17	; 0x01
     ba2:	1a 82       	std	Y+2, r1	; 0x02
     ba4:	42 e0       	ldi	r20, 0x02	; 2
     ba6:	be 01       	movw	r22, r28
     ba8:	6f 5f       	subi	r22, 0xFF	; 255
     baa:	7f 4f       	sbci	r23, 0xFF	; 255
     bac:	8c e3       	ldi	r24, 0x3C	; 60
     bae:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
     bb2:	19 83       	std	Y+1, r17	; 0x01
     bb4:	87 e0       	ldi	r24, 0x07	; 7
     bb6:	8a 83       	std	Y+2, r24	; 0x02
     bb8:	42 e0       	ldi	r20, 0x02	; 2
     bba:	be 01       	movw	r22, r28
     bbc:	6f 5f       	subi	r22, 0xFF	; 255
     bbe:	7f 4f       	sbci	r23, 0xFF	; 255
     bc0:	8c e3       	ldi	r24, 0x3C	; 60
     bc2:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
     bc6:	0f 90       	pop	r0
     bc8:	0f 90       	pop	r0
     bca:	df 91       	pop	r29
     bcc:	cf 91       	pop	r28
     bce:	1f 91       	pop	r17
     bd0:	08 95       	ret

00000bd2 <set_column_address>:
     bd2:	1f 93       	push	r17
     bd4:	cf 93       	push	r28
     bd6:	df 93       	push	r29
     bd8:	1f 92       	push	r1
     bda:	1f 92       	push	r1
     bdc:	cd b7       	in	r28, 0x3d	; 61
     bde:	de b7       	in	r29, 0x3e	; 62
     be0:	10 e8       	ldi	r17, 0x80	; 128
     be2:	19 83       	std	Y+1, r17	; 0x01
     be4:	81 e2       	ldi	r24, 0x21	; 33
     be6:	8a 83       	std	Y+2, r24	; 0x02
     be8:	42 e0       	ldi	r20, 0x02	; 2
     bea:	be 01       	movw	r22, r28
     bec:	6f 5f       	subi	r22, 0xFF	; 255
     bee:	7f 4f       	sbci	r23, 0xFF	; 255
     bf0:	8c e3       	ldi	r24, 0x3C	; 60
     bf2:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
     bf6:	19 83       	std	Y+1, r17	; 0x01
     bf8:	1a 82       	std	Y+2, r1	; 0x02
     bfa:	42 e0       	ldi	r20, 0x02	; 2
     bfc:	be 01       	movw	r22, r28
     bfe:	6f 5f       	subi	r22, 0xFF	; 255
     c00:	7f 4f       	sbci	r23, 0xFF	; 255
     c02:	8c e3       	ldi	r24, 0x3C	; 60
     c04:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
     c08:	19 83       	std	Y+1, r17	; 0x01
     c0a:	8f e7       	ldi	r24, 0x7F	; 127
     c0c:	8a 83       	std	Y+2, r24	; 0x02
     c0e:	42 e0       	ldi	r20, 0x02	; 2
     c10:	be 01       	movw	r22, r28
     c12:	6f 5f       	subi	r22, 0xFF	; 255
     c14:	7f 4f       	sbci	r23, 0xFF	; 255
     c16:	8c e3       	ldi	r24, 0x3C	; 60
     c18:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
     c1c:	0f 90       	pop	r0
     c1e:	0f 90       	pop	r0
     c20:	df 91       	pop	r29
     c22:	cf 91       	pop	r28
     c24:	1f 91       	pop	r17
     c26:	08 95       	ret

00000c28 <DriverOLEDUpdate>:
     c28:	bf 92       	push	r11
     c2a:	cf 92       	push	r12
     c2c:	df 92       	push	r13
     c2e:	ef 92       	push	r14
     c30:	ff 92       	push	r15
     c32:	0f 93       	push	r16
     c34:	1f 93       	push	r17
     c36:	cf 93       	push	r28
     c38:	df 93       	push	r29
     c3a:	cd b7       	in	r28, 0x3d	; 61
     c3c:	de b7       	in	r29, 0x3e	; 62
     c3e:	61 97       	sbiw	r28, 0x11	; 17
     c40:	cd bf       	out	0x3d, r28	; 61
     c42:	de bf       	out	0x3e, r29	; 62
     c44:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <set_column_address>
     c48:	0e 94 be 05 	call	0xb7c	; 0xb7c <set_page_address>
     c4c:	8d eb       	ldi	r24, 0xBD	; 189
     c4e:	c8 2e       	mov	r12, r24
     c50:	83 e2       	ldi	r24, 0x23	; 35
     c52:	d8 2e       	mov	r13, r24
     c54:	9d eb       	ldi	r25, 0xBD	; 189
     c56:	e9 2e       	mov	r14, r25
     c58:	97 e2       	ldi	r25, 0x27	; 39
     c5a:	f9 2e       	mov	r15, r25
     c5c:	8e 01       	movw	r16, r28
     c5e:	0e 5e       	subi	r16, 0xEE	; 238
     c60:	1f 4f       	sbci	r17, 0xFF	; 255
     c62:	20 e4       	ldi	r18, 0x40	; 64
     c64:	b2 2e       	mov	r11, r18
     c66:	b9 82       	std	Y+1, r11	; 0x01
     c68:	fe 01       	movw	r30, r28
     c6a:	32 96       	adiw	r30, 0x02	; 2
     c6c:	d6 01       	movw	r26, r12
     c6e:	8d 91       	ld	r24, X+
     c70:	81 93       	st	Z+, r24
     c72:	e0 17       	cp	r30, r16
     c74:	f1 07       	cpc	r31, r17
     c76:	d9 f7       	brne	.-10     	; 0xc6e <DriverOLEDUpdate+0x46>
     c78:	41 e1       	ldi	r20, 0x11	; 17
     c7a:	be 01       	movw	r22, r28
     c7c:	6f 5f       	subi	r22, 0xFF	; 255
     c7e:	7f 4f       	sbci	r23, 0xFF	; 255
     c80:	8c e3       	ldi	r24, 0x3C	; 60
     c82:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
     c86:	80 e1       	ldi	r24, 0x10	; 16
     c88:	c8 0e       	add	r12, r24
     c8a:	d1 1c       	adc	r13, r1
     c8c:	ec 14       	cp	r14, r12
     c8e:	fd 04       	cpc	r15, r13
     c90:	51 f7       	brne	.-44     	; 0xc66 <DriverOLEDUpdate+0x3e>
     c92:	61 96       	adiw	r28, 0x11	; 17
     c94:	cd bf       	out	0x3d, r28	; 61
     c96:	de bf       	out	0x3e, r29	; 62
     c98:	df 91       	pop	r29
     c9a:	cf 91       	pop	r28
     c9c:	1f 91       	pop	r17
     c9e:	0f 91       	pop	r16
     ca0:	ff 90       	pop	r15
     ca2:	ef 90       	pop	r14
     ca4:	df 90       	pop	r13
     ca6:	cf 90       	pop	r12
     ca8:	bf 90       	pop	r11
     caa:	08 95       	ret

00000cac <DriverOLEDClearScreen>:
     cac:	80 e0       	ldi	r24, 0x00	; 0
     cae:	94 e0       	ldi	r25, 0x04	; 4
     cb0:	ed eb       	ldi	r30, 0xBD	; 189
     cb2:	f3 e2       	ldi	r31, 0x23	; 35
     cb4:	df 01       	movw	r26, r30
     cb6:	9c 01       	movw	r18, r24
     cb8:	1d 92       	st	X+, r1
     cba:	21 50       	subi	r18, 0x01	; 1
     cbc:	30 40       	sbci	r19, 0x00	; 0
     cbe:	e1 f7       	brne	.-8      	; 0xcb8 <DriverOLEDClearScreen+0xc>
     cc0:	08 95       	ret

00000cc2 <DriverOLEDDrawPixel>:
     cc2:	90 91 bc 23 	lds	r25, 0x23BC	; 0x8023bc <GlobOrientation>
     cc6:	91 11       	cpse	r25, r1
     cc8:	1c c0       	rjmp	.+56     	; 0xd02 <DriverOLEDDrawPixel+0x40>
     cca:	87 fd       	sbrc	r24, 7
     ccc:	19 c0       	rjmp	.+50     	; 0xd00 <DriverOLEDDrawPixel+0x3e>
     cce:	60 34       	cpi	r22, 0x40	; 64
     cd0:	b8 f4       	brcc	.+46     	; 0xd00 <DriverOLEDDrawPixel+0x3e>
     cd2:	96 2f       	mov	r25, r22
     cd4:	96 95       	lsr	r25
     cd6:	96 95       	lsr	r25
     cd8:	96 95       	lsr	r25
     cda:	e8 2f       	mov	r30, r24
     cdc:	f0 e0       	ldi	r31, 0x00	; 0
     cde:	20 e8       	ldi	r18, 0x80	; 128
     ce0:	92 9f       	mul	r25, r18
     ce2:	e0 0d       	add	r30, r0
     ce4:	f1 1d       	adc	r31, r1
     ce6:	11 24       	eor	r1, r1
     ce8:	e3 54       	subi	r30, 0x43	; 67
     cea:	fc 4d       	sbci	r31, 0xDC	; 220
     cec:	67 70       	andi	r22, 0x07	; 7
     cee:	81 e0       	ldi	r24, 0x01	; 1
     cf0:	90 e0       	ldi	r25, 0x00	; 0
     cf2:	01 c0       	rjmp	.+2      	; 0xcf6 <DriverOLEDDrawPixel+0x34>
     cf4:	88 0f       	add	r24, r24
     cf6:	6a 95       	dec	r22
     cf8:	ea f7       	brpl	.-6      	; 0xcf4 <DriverOLEDDrawPixel+0x32>
     cfa:	90 81       	ld	r25, Z
     cfc:	89 2b       	or	r24, r25
     cfe:	80 83       	st	Z, r24
     d00:	08 95       	ret
     d02:	91 30       	cpi	r25, 0x01	; 1
     d04:	e9 f0       	breq	.+58     	; 0xd40 <DriverOLEDDrawPixel+0x7e>
     d06:	92 30       	cpi	r25, 0x02	; 2
     d08:	d9 f7       	brne	.-10     	; 0xd00 <DriverOLEDDrawPixel+0x3e>
     d0a:	87 fd       	sbrc	r24, 7
     d0c:	f9 cf       	rjmp	.-14     	; 0xd00 <DriverOLEDDrawPixel+0x3e>
     d0e:	60 34       	cpi	r22, 0x40	; 64
     d10:	b8 f7       	brcc	.-18     	; 0xd00 <DriverOLEDDrawPixel+0x3e>
     d12:	ef e3       	ldi	r30, 0x3F	; 63
     d14:	f0 e0       	ldi	r31, 0x00	; 0
     d16:	e6 1b       	sub	r30, r22
     d18:	f1 09       	sbc	r31, r1
     d1a:	f5 95       	asr	r31
     d1c:	e7 95       	ror	r30
     d1e:	f5 95       	asr	r31
     d20:	e7 95       	ror	r30
     d22:	f5 95       	asr	r31
     d24:	e7 95       	ror	r30
     d26:	f6 95       	lsr	r31
     d28:	fe 2f       	mov	r31, r30
     d2a:	ee 27       	eor	r30, r30
     d2c:	f7 95       	ror	r31
     d2e:	e7 95       	ror	r30
     d30:	2f e7       	ldi	r18, 0x7F	; 127
     d32:	30 e0       	ldi	r19, 0x00	; 0
     d34:	a9 01       	movw	r20, r18
     d36:	48 1b       	sub	r20, r24
     d38:	51 09       	sbc	r21, r1
     d3a:	e4 0f       	add	r30, r20
     d3c:	f5 1f       	adc	r31, r21
     d3e:	d4 cf       	rjmp	.-88     	; 0xce8 <DriverOLEDDrawPixel+0x26>
     d40:	80 34       	cpi	r24, 0x40	; 64
     d42:	f0 f6       	brcc	.-68     	; 0xd00 <DriverOLEDDrawPixel+0x3e>
     d44:	67 fd       	sbrc	r22, 7
     d46:	dc cf       	rjmp	.-72     	; 0xd00 <DriverOLEDDrawPixel+0x3e>
     d48:	98 2f       	mov	r25, r24
     d4a:	96 95       	lsr	r25
     d4c:	96 95       	lsr	r25
     d4e:	96 95       	lsr	r25
     d50:	af e7       	ldi	r26, 0x7F	; 127
     d52:	b0 e0       	ldi	r27, 0x00	; 0
     d54:	a6 1b       	sub	r26, r22
     d56:	b1 09       	sbc	r27, r1
     d58:	40 e8       	ldi	r20, 0x80	; 128
     d5a:	94 9f       	mul	r25, r20
     d5c:	a0 0d       	add	r26, r0
     d5e:	b1 1d       	adc	r27, r1
     d60:	11 24       	eor	r1, r1
     d62:	a3 54       	subi	r26, 0x43	; 67
     d64:	bc 4d       	sbci	r27, 0xDC	; 220
     d66:	e8 2f       	mov	r30, r24
     d68:	e7 70       	andi	r30, 0x07	; 7
     d6a:	81 e0       	ldi	r24, 0x01	; 1
     d6c:	90 e0       	ldi	r25, 0x00	; 0
     d6e:	01 c0       	rjmp	.+2      	; 0xd72 <DriverOLEDDrawPixel+0xb0>
     d70:	88 0f       	add	r24, r24
     d72:	ea 95       	dec	r30
     d74:	ea f7       	brpl	.-6      	; 0xd70 <DriverOLEDDrawPixel+0xae>
     d76:	9c 91       	ld	r25, X
     d78:	89 2b       	or	r24, r25
     d7a:	8c 93       	st	X, r24
     d7c:	08 95       	ret

00000d7e <DriverOLEDClearPixel>:
     d7e:	90 91 bc 23 	lds	r25, 0x23BC	; 0x8023bc <GlobOrientation>
     d82:	91 11       	cpse	r25, r1
     d84:	1d c0       	rjmp	.+58     	; 0xdc0 <DriverOLEDClearPixel+0x42>
     d86:	87 fd       	sbrc	r24, 7
     d88:	1a c0       	rjmp	.+52     	; 0xdbe <DriverOLEDClearPixel+0x40>
     d8a:	60 34       	cpi	r22, 0x40	; 64
     d8c:	c0 f4       	brcc	.+48     	; 0xdbe <DriverOLEDClearPixel+0x40>
     d8e:	96 2f       	mov	r25, r22
     d90:	96 95       	lsr	r25
     d92:	96 95       	lsr	r25
     d94:	96 95       	lsr	r25
     d96:	e8 2f       	mov	r30, r24
     d98:	f0 e0       	ldi	r31, 0x00	; 0
     d9a:	20 e8       	ldi	r18, 0x80	; 128
     d9c:	92 9f       	mul	r25, r18
     d9e:	e0 0d       	add	r30, r0
     da0:	f1 1d       	adc	r31, r1
     da2:	11 24       	eor	r1, r1
     da4:	e3 54       	subi	r30, 0x43	; 67
     da6:	fc 4d       	sbci	r31, 0xDC	; 220
     da8:	67 70       	andi	r22, 0x07	; 7
     daa:	81 e0       	ldi	r24, 0x01	; 1
     dac:	90 e0       	ldi	r25, 0x00	; 0
     dae:	01 c0       	rjmp	.+2      	; 0xdb2 <DriverOLEDClearPixel+0x34>
     db0:	88 0f       	add	r24, r24
     db2:	6a 95       	dec	r22
     db4:	ea f7       	brpl	.-6      	; 0xdb0 <DriverOLEDClearPixel+0x32>
     db6:	80 95       	com	r24
     db8:	90 81       	ld	r25, Z
     dba:	89 23       	and	r24, r25
     dbc:	80 83       	st	Z, r24
     dbe:	08 95       	ret
     dc0:	91 30       	cpi	r25, 0x01	; 1
     dc2:	e9 f0       	breq	.+58     	; 0xdfe <DriverOLEDClearPixel+0x80>
     dc4:	92 30       	cpi	r25, 0x02	; 2
     dc6:	d9 f7       	brne	.-10     	; 0xdbe <DriverOLEDClearPixel+0x40>
     dc8:	87 fd       	sbrc	r24, 7
     dca:	f9 cf       	rjmp	.-14     	; 0xdbe <DriverOLEDClearPixel+0x40>
     dcc:	60 34       	cpi	r22, 0x40	; 64
     dce:	b8 f7       	brcc	.-18     	; 0xdbe <DriverOLEDClearPixel+0x40>
     dd0:	ef e3       	ldi	r30, 0x3F	; 63
     dd2:	f0 e0       	ldi	r31, 0x00	; 0
     dd4:	e6 1b       	sub	r30, r22
     dd6:	f1 09       	sbc	r31, r1
     dd8:	f5 95       	asr	r31
     dda:	e7 95       	ror	r30
     ddc:	f5 95       	asr	r31
     dde:	e7 95       	ror	r30
     de0:	f5 95       	asr	r31
     de2:	e7 95       	ror	r30
     de4:	f6 95       	lsr	r31
     de6:	fe 2f       	mov	r31, r30
     de8:	ee 27       	eor	r30, r30
     dea:	f7 95       	ror	r31
     dec:	e7 95       	ror	r30
     dee:	2f e7       	ldi	r18, 0x7F	; 127
     df0:	30 e0       	ldi	r19, 0x00	; 0
     df2:	a9 01       	movw	r20, r18
     df4:	48 1b       	sub	r20, r24
     df6:	51 09       	sbc	r21, r1
     df8:	e4 0f       	add	r30, r20
     dfa:	f5 1f       	adc	r31, r21
     dfc:	d3 cf       	rjmp	.-90     	; 0xda4 <DriverOLEDClearPixel+0x26>
     dfe:	80 34       	cpi	r24, 0x40	; 64
     e00:	f0 f6       	brcc	.-68     	; 0xdbe <DriverOLEDClearPixel+0x40>
     e02:	67 fd       	sbrc	r22, 7
     e04:	dc cf       	rjmp	.-72     	; 0xdbe <DriverOLEDClearPixel+0x40>
     e06:	98 2f       	mov	r25, r24
     e08:	96 95       	lsr	r25
     e0a:	96 95       	lsr	r25
     e0c:	96 95       	lsr	r25
     e0e:	af e7       	ldi	r26, 0x7F	; 127
     e10:	b0 e0       	ldi	r27, 0x00	; 0
     e12:	a6 1b       	sub	r26, r22
     e14:	b1 09       	sbc	r27, r1
     e16:	40 e8       	ldi	r20, 0x80	; 128
     e18:	94 9f       	mul	r25, r20
     e1a:	a0 0d       	add	r26, r0
     e1c:	b1 1d       	adc	r27, r1
     e1e:	11 24       	eor	r1, r1
     e20:	a3 54       	subi	r26, 0x43	; 67
     e22:	bc 4d       	sbci	r27, 0xDC	; 220
     e24:	e8 2f       	mov	r30, r24
     e26:	e7 70       	andi	r30, 0x07	; 7
     e28:	81 e0       	ldi	r24, 0x01	; 1
     e2a:	90 e0       	ldi	r25, 0x00	; 0
     e2c:	01 c0       	rjmp	.+2      	; 0xe30 <DriverOLEDClearPixel+0xb2>
     e2e:	88 0f       	add	r24, r24
     e30:	ea 95       	dec	r30
     e32:	ea f7       	brpl	.-6      	; 0xe2e <DriverOLEDClearPixel+0xb0>
     e34:	80 95       	com	r24
     e36:	9c 91       	ld	r25, X
     e38:	89 23       	and	r24, r25
     e3a:	8c 93       	st	X, r24
     e3c:	08 95       	ret

00000e3e <DriverOLEDPrintSmChar.part.2>:
     e3e:	4f 92       	push	r4
     e40:	5f 92       	push	r5
     e42:	6f 92       	push	r6
     e44:	7f 92       	push	r7
     e46:	8f 92       	push	r8
     e48:	9f 92       	push	r9
     e4a:	af 92       	push	r10
     e4c:	bf 92       	push	r11
     e4e:	cf 92       	push	r12
     e50:	df 92       	push	r13
     e52:	ef 92       	push	r14
     e54:	ff 92       	push	r15
     e56:	0f 93       	push	r16
     e58:	1f 93       	push	r17
     e5a:	cf 93       	push	r28
     e5c:	df 93       	push	r29
     e5e:	90 91 bc 23 	lds	r25, 0x23BC	; 0x8023bc <GlobOrientation>
     e62:	91 11       	cpse	r25, r1
     e64:	28 c0       	rjmp	.+80     	; 0xeb6 <DriverOLEDPrintSmChar.part.2+0x78>
     e66:	22 23       	and	r18, r18
     e68:	e1 f1       	breq	.+120    	; 0xee2 <DriverOLEDPrintSmChar.part.2+0xa4>
     e6a:	26 e0       	ldi	r18, 0x06	; 6
     e6c:	82 9f       	mul	r24, r18
     e6e:	c0 01       	movw	r24, r0
     e70:	11 24       	eor	r1, r1
     e72:	20 e8       	ldi	r18, 0x80	; 128
     e74:	62 9f       	mul	r22, r18
     e76:	80 0d       	add	r24, r0
     e78:	91 1d       	adc	r25, r1
     e7a:	11 24       	eor	r1, r1
     e7c:	50 e0       	ldi	r21, 0x00	; 0
     e7e:	40 52       	subi	r20, 0x20	; 32
     e80:	51 09       	sbc	r21, r1
     e82:	fa 01       	movw	r30, r20
     e84:	ee 0f       	add	r30, r30
     e86:	ff 1f       	adc	r31, r31
     e88:	ee 0f       	add	r30, r30
     e8a:	ff 1f       	adc	r31, r31
     e8c:	e4 0f       	add	r30, r20
     e8e:	f5 1f       	adc	r31, r21
     e90:	eb 54       	subi	r30, 0x4B	; 75
     e92:	ff 4d       	sbci	r31, 0xDF	; 223
     e94:	dc 01       	movw	r26, r24
     e96:	a3 54       	subi	r26, 0x43	; 67
     e98:	bc 4d       	sbci	r27, 0xDC	; 220
     e9a:	ac 01       	movw	r20, r24
     e9c:	4b 5f       	subi	r20, 0xFB	; 251
     e9e:	5f 4f       	sbci	r21, 0xFF	; 255
     ea0:	01 96       	adiw	r24, 0x01	; 1
     ea2:	21 91       	ld	r18, Z+
     ea4:	2d 93       	st	X+, r18
     ea6:	84 17       	cp	r24, r20
     ea8:	95 07       	cpc	r25, r21
     eaa:	d1 f7       	brne	.-12     	; 0xea0 <DriverOLEDPrintSmChar.part.2+0x62>
     eac:	fc 01       	movw	r30, r24
     eae:	e3 54       	subi	r30, 0x43	; 67
     eb0:	fc 4d       	sbci	r31, 0xDC	; 220
     eb2:	10 82       	st	Z, r1
     eb4:	05 c0       	rjmp	.+10     	; 0xec0 <DriverOLEDPrintSmChar.part.2+0x82>
     eb6:	91 30       	cpi	r25, 0x01	; 1
     eb8:	f9 f0       	breq	.+62     	; 0xef8 <DriverOLEDPrintSmChar.part.2+0xba>
     eba:	92 30       	cpi	r25, 0x02	; 2
     ebc:	09 f4       	brne	.+2      	; 0xec0 <DriverOLEDPrintSmChar.part.2+0x82>
     ebe:	6f c0       	rjmp	.+222    	; 0xf9e <DriverOLEDPrintSmChar.part.2+0x160>
     ec0:	df 91       	pop	r29
     ec2:	cf 91       	pop	r28
     ec4:	1f 91       	pop	r17
     ec6:	0f 91       	pop	r16
     ec8:	ff 90       	pop	r15
     eca:	ef 90       	pop	r14
     ecc:	df 90       	pop	r13
     ece:	cf 90       	pop	r12
     ed0:	bf 90       	pop	r11
     ed2:	af 90       	pop	r10
     ed4:	9f 90       	pop	r9
     ed6:	8f 90       	pop	r8
     ed8:	7f 90       	pop	r7
     eda:	6f 90       	pop	r6
     edc:	5f 90       	pop	r5
     ede:	4f 90       	pop	r4
     ee0:	08 95       	ret
     ee2:	36 e0       	ldi	r19, 0x06	; 6
     ee4:	83 9f       	mul	r24, r19
     ee6:	c0 01       	movw	r24, r0
     ee8:	11 24       	eor	r1, r1
     eea:	8b 37       	cpi	r24, 0x7B	; 123
     eec:	91 05       	cpc	r25, r1
     eee:	0c f2       	brlt	.-126    	; 0xe72 <DriverOLEDPrintSmChar.part.2+0x34>
     ef0:	6f 5f       	subi	r22, 0xFF	; 255
     ef2:	80 e0       	ldi	r24, 0x00	; 0
     ef4:	90 e0       	ldi	r25, 0x00	; 0
     ef6:	bd cf       	rjmp	.-134    	; 0xe72 <DriverOLEDPrintSmChar.part.2+0x34>
     ef8:	88 2e       	mov	r8, r24
     efa:	88 0c       	add	r8, r8
     efc:	88 0d       	add	r24, r8
     efe:	88 2e       	mov	r8, r24
     f00:	88 0c       	add	r8, r8
     f02:	66 2e       	mov	r6, r22
     f04:	66 0c       	add	r6, r6
     f06:	66 0c       	add	r6, r6
     f08:	66 0c       	add	r6, r6
     f0a:	c6 2c       	mov	r12, r6
     f0c:	d1 2c       	mov	r13, r1
     f0e:	37 e0       	ldi	r19, 0x07	; 7
     f10:	c3 0e       	add	r12, r19
     f12:	d1 1c       	adc	r13, r1
     f14:	e8 2c       	mov	r14, r8
     f16:	f1 2c       	mov	r15, r1
     f18:	84 e0       	ldi	r24, 0x04	; 4
     f1a:	e8 0e       	add	r14, r24
     f1c:	f1 1c       	adc	r15, r1
     f1e:	76 2c       	mov	r7, r6
     f20:	50 e0       	ldi	r21, 0x00	; 0
     f22:	40 52       	subi	r20, 0x20	; 32
     f24:	51 09       	sbc	r21, r1
     f26:	aa 24       	eor	r10, r10
     f28:	a3 94       	inc	r10
     f2a:	b1 2c       	mov	r11, r1
     f2c:	ea 01       	movw	r28, r20
     f2e:	cc 0f       	add	r28, r28
     f30:	dd 1f       	adc	r29, r29
     f32:	cc 0f       	add	r28, r28
     f34:	dd 1f       	adc	r29, r29
     f36:	4c 0f       	add	r20, r28
     f38:	5d 1f       	adc	r21, r29
     f3a:	ea 01       	movw	r28, r20
     f3c:	cb 54       	subi	r28, 0x4B	; 75
     f3e:	df 4d       	sbci	r29, 0xDF	; 223
     f40:	87 2d       	mov	r24, r7
     f42:	86 19       	sub	r24, r6
     f44:	85 01       	movw	r16, r10
     f46:	02 c0       	rjmp	.+4      	; 0xf4c <DriverOLEDPrintSmChar.part.2+0x10e>
     f48:	00 0f       	add	r16, r16
     f4a:	11 1f       	adc	r17, r17
     f4c:	8a 95       	dec	r24
     f4e:	e2 f7       	brpl	.-8      	; 0xf48 <DriverOLEDPrintSmChar.part.2+0x10a>
     f50:	98 2c       	mov	r9, r8
     f52:	09 c0       	rjmp	.+18     	; 0xf66 <DriverOLEDPrintSmChar.part.2+0x128>
     f54:	89 2d       	mov	r24, r9
     f56:	0e 94 61 06 	call	0xcc2	; 0xcc2 <DriverOLEDDrawPixel>
     f5a:	93 94       	inc	r9
     f5c:	89 2d       	mov	r24, r9
     f5e:	90 e0       	ldi	r25, 0x00	; 0
     f60:	e8 16       	cp	r14, r24
     f62:	f9 06       	cpc	r15, r25
     f64:	ac f0       	brlt	.+42     	; 0xf90 <DriverOLEDPrintSmChar.part.2+0x152>
     f66:	89 2d       	mov	r24, r9
     f68:	88 19       	sub	r24, r8
     f6a:	fe 01       	movw	r30, r28
     f6c:	e8 0f       	add	r30, r24
     f6e:	f1 1d       	adc	r31, r1
     f70:	80 81       	ld	r24, Z
     f72:	90 e0       	ldi	r25, 0x00	; 0
     f74:	80 23       	and	r24, r16
     f76:	91 23       	and	r25, r17
     f78:	67 2d       	mov	r22, r7
     f7a:	89 2b       	or	r24, r25
     f7c:	59 f7       	brne	.-42     	; 0xf54 <DriverOLEDPrintSmChar.part.2+0x116>
     f7e:	89 2d       	mov	r24, r9
     f80:	0e 94 bf 06 	call	0xd7e	; 0xd7e <DriverOLEDClearPixel>
     f84:	93 94       	inc	r9
     f86:	89 2d       	mov	r24, r9
     f88:	90 e0       	ldi	r25, 0x00	; 0
     f8a:	e8 16       	cp	r14, r24
     f8c:	f9 06       	cpc	r15, r25
     f8e:	5c f7       	brge	.-42     	; 0xf66 <DriverOLEDPrintSmChar.part.2+0x128>
     f90:	73 94       	inc	r7
     f92:	87 2d       	mov	r24, r7
     f94:	90 e0       	ldi	r25, 0x00	; 0
     f96:	c8 16       	cp	r12, r24
     f98:	d9 06       	cpc	r13, r25
     f9a:	94 f6       	brge	.-92     	; 0xf40 <DriverOLEDPrintSmChar.part.2+0x102>
     f9c:	91 cf       	rjmp	.-222    	; 0xec0 <DriverOLEDPrintSmChar.part.2+0x82>
     f9e:	58 2e       	mov	r5, r24
     fa0:	55 0c       	add	r5, r5
     fa2:	85 0d       	add	r24, r5
     fa4:	58 2e       	mov	r5, r24
     fa6:	55 0c       	add	r5, r5
     fa8:	66 2e       	mov	r6, r22
     faa:	66 0c       	add	r6, r6
     fac:	66 0c       	add	r6, r6
     fae:	66 0c       	add	r6, r6
     fb0:	86 2c       	mov	r8, r6
     fb2:	91 2c       	mov	r9, r1
     fb4:	27 e0       	ldi	r18, 0x07	; 7
     fb6:	82 0e       	add	r8, r18
     fb8:	91 1c       	adc	r9, r1
     fba:	e5 2c       	mov	r14, r5
     fbc:	f1 2c       	mov	r15, r1
     fbe:	34 e0       	ldi	r19, 0x04	; 4
     fc0:	e3 0e       	add	r14, r19
     fc2:	f1 1c       	adc	r15, r1
     fc4:	46 2c       	mov	r4, r6
     fc6:	50 e0       	ldi	r21, 0x00	; 0
     fc8:	40 52       	subi	r20, 0x20	; 32
     fca:	51 09       	sbc	r21, r1
     fcc:	87 e0       	ldi	r24, 0x07	; 7
     fce:	a8 2e       	mov	r10, r24
     fd0:	b1 2c       	mov	r11, r1
     fd2:	cc 24       	eor	r12, r12
     fd4:	c3 94       	inc	r12
     fd6:	d1 2c       	mov	r13, r1
     fd8:	ea 01       	movw	r28, r20
     fda:	cc 0f       	add	r28, r28
     fdc:	dd 1f       	adc	r29, r29
     fde:	cc 0f       	add	r28, r28
     fe0:	dd 1f       	adc	r29, r29
     fe2:	4c 0f       	add	r20, r28
     fe4:	5d 1f       	adc	r21, r29
     fe6:	ea 01       	movw	r28, r20
     fe8:	cb 54       	subi	r28, 0x4B	; 75
     fea:	df 4d       	sbci	r29, 0xDF	; 223
     fec:	84 2d       	mov	r24, r4
     fee:	86 19       	sub	r24, r6
     ff0:	95 01       	movw	r18, r10
     ff2:	28 1b       	sub	r18, r24
     ff4:	31 09       	sbc	r19, r1
     ff6:	86 01       	movw	r16, r12
     ff8:	02 c0       	rjmp	.+4      	; 0xffe <DriverOLEDPrintSmChar.part.2+0x1c0>
     ffa:	00 0f       	add	r16, r16
     ffc:	11 1f       	adc	r17, r17
     ffe:	2a 95       	dec	r18
    1000:	e2 f7       	brpl	.-8      	; 0xffa <DriverOLEDPrintSmChar.part.2+0x1bc>
    1002:	75 2c       	mov	r7, r5
    1004:	09 c0       	rjmp	.+18     	; 0x1018 <DriverOLEDPrintSmChar.part.2+0x1da>
    1006:	87 2d       	mov	r24, r7
    1008:	0e 94 61 06 	call	0xcc2	; 0xcc2 <DriverOLEDDrawPixel>
    100c:	73 94       	inc	r7
    100e:	87 2d       	mov	r24, r7
    1010:	90 e0       	ldi	r25, 0x00	; 0
    1012:	e8 16       	cp	r14, r24
    1014:	f9 06       	cpc	r15, r25
    1016:	ac f0       	brlt	.+42     	; 0x1042 <DriverOLEDPrintSmChar.part.2+0x204>
    1018:	87 2d       	mov	r24, r7
    101a:	85 19       	sub	r24, r5
    101c:	fe 01       	movw	r30, r28
    101e:	e8 0f       	add	r30, r24
    1020:	f1 1d       	adc	r31, r1
    1022:	80 81       	ld	r24, Z
    1024:	90 e0       	ldi	r25, 0x00	; 0
    1026:	80 23       	and	r24, r16
    1028:	91 23       	and	r25, r17
    102a:	64 2d       	mov	r22, r4
    102c:	89 2b       	or	r24, r25
    102e:	59 f7       	brne	.-42     	; 0x1006 <DriverOLEDPrintSmChar.part.2+0x1c8>
    1030:	87 2d       	mov	r24, r7
    1032:	0e 94 bf 06 	call	0xd7e	; 0xd7e <DriverOLEDClearPixel>
    1036:	73 94       	inc	r7
    1038:	87 2d       	mov	r24, r7
    103a:	90 e0       	ldi	r25, 0x00	; 0
    103c:	e8 16       	cp	r14, r24
    103e:	f9 06       	cpc	r15, r25
    1040:	5c f7       	brge	.-42     	; 0x1018 <DriverOLEDPrintSmChar.part.2+0x1da>
    1042:	43 94       	inc	r4
    1044:	84 2d       	mov	r24, r4
    1046:	90 e0       	ldi	r25, 0x00	; 0
    1048:	88 16       	cp	r8, r24
    104a:	99 06       	cpc	r9, r25
    104c:	7c f6       	brge	.-98     	; 0xfec <DriverOLEDPrintSmChar.part.2+0x1ae>
    104e:	38 cf       	rjmp	.-400    	; 0xec0 <DriverOLEDPrintSmChar.part.2+0x82>

00001050 <DriverOLEDPrintSmChar>:
    1050:	81 38       	cpi	r24, 0x81	; 129
    1052:	20 f4       	brcc	.+8      	; 0x105c <DriverOLEDPrintSmChar+0xc>
    1054:	61 34       	cpi	r22, 0x41	; 65
    1056:	10 f4       	brcc	.+4      	; 0x105c <DriverOLEDPrintSmChar+0xc>
    1058:	0c 94 1f 07 	jmp	0xe3e	; 0xe3e <DriverOLEDPrintSmChar.part.2>
    105c:	08 95       	ret

0000105e <DriverOLEDPrintSmText>:
    105e:	ef 92       	push	r14
    1060:	ff 92       	push	r15
    1062:	0f 93       	push	r16
    1064:	1f 93       	push	r17
    1066:	cf 93       	push	r28
    1068:	df 93       	push	r29
    106a:	f8 2e       	mov	r15, r24
    106c:	e4 2e       	mov	r14, r20
    106e:	80 91 bc 23 	lds	r24, 0x23BC	; 0x8023bc <GlobOrientation>
    1072:	98 2f       	mov	r25, r24
    1074:	9d 7f       	andi	r25, 0xFD	; 253
    1076:	49 f0       	breq	.+18     	; 0x108a <DriverOLEDPrintSmText+0x2c>
    1078:	81 30       	cpi	r24, 0x01	; 1
    107a:	81 f1       	breq	.+96     	; 0x10dc <DriverOLEDPrintSmText+0x7e>
    107c:	df 91       	pop	r29
    107e:	cf 91       	pop	r28
    1080:	1f 91       	pop	r17
    1082:	0f 91       	pop	r16
    1084:	ff 90       	pop	r15
    1086:	ef 90       	pop	r14
    1088:	08 95       	ret
    108a:	27 e0       	ldi	r18, 0x07	; 7
    108c:	2f 15       	cp	r18, r15
    108e:	b0 f3       	brcs	.-20     	; 0x107c <DriverOLEDPrintSmText+0x1e>
    1090:	fb 01       	movw	r30, r22
    1092:	40 81       	ld	r20, Z
    1094:	44 23       	and	r20, r20
    1096:	91 f3       	breq	.-28     	; 0x107c <DriverOLEDPrintSmText+0x1e>
    1098:	8b 01       	movw	r16, r22
    109a:	0f 5f       	subi	r16, 0xFF	; 255
    109c:	1f 4f       	sbci	r17, 0xFF	; 255
    109e:	c0 e0       	ldi	r28, 0x00	; 0
    10a0:	0e c0       	rjmp	.+28     	; 0x10be <DriverOLEDPrintSmText+0x60>
    10a2:	26 e0       	ldi	r18, 0x06	; 6
    10a4:	c2 9f       	mul	r28, r18
    10a6:	c0 01       	movw	r24, r0
    10a8:	11 24       	eor	r1, r1
    10aa:	8b 37       	cpi	r24, 0x7B	; 123
    10ac:	91 05       	cpc	r25, r1
    10ae:	74 f0       	brlt	.+28     	; 0x10cc <DriverOLEDPrintSmText+0x6e>
    10b0:	f3 94       	inc	r15
    10b2:	c1 e0       	ldi	r28, 0x01	; 1
    10b4:	f8 01       	movw	r30, r16
    10b6:	41 91       	ld	r20, Z+
    10b8:	8f 01       	movw	r16, r30
    10ba:	44 23       	and	r20, r20
    10bc:	f9 f2       	breq	.-66     	; 0x107c <DriverOLEDPrintSmText+0x1e>
    10be:	c1 38       	cpi	r28, 0x81	; 129
    10c0:	18 f4       	brcc	.+6      	; 0x10c8 <DriverOLEDPrintSmText+0x6a>
    10c2:	f0 e4       	ldi	r31, 0x40	; 64
    10c4:	ff 15       	cp	r31, r15
    10c6:	20 f4       	brcc	.+8      	; 0x10d0 <DriverOLEDPrintSmText+0x72>
    10c8:	ee 20       	and	r14, r14
    10ca:	59 f3       	breq	.-42     	; 0x10a2 <DriverOLEDPrintSmText+0x44>
    10cc:	cf 5f       	subi	r28, 0xFF	; 255
    10ce:	f2 cf       	rjmp	.-28     	; 0x10b4 <DriverOLEDPrintSmText+0x56>
    10d0:	2e 2d       	mov	r18, r14
    10d2:	6f 2d       	mov	r22, r15
    10d4:	8c 2f       	mov	r24, r28
    10d6:	0e 94 1f 07 	call	0xe3e	; 0xe3e <DriverOLEDPrintSmChar.part.2>
    10da:	f6 cf       	rjmp	.-20     	; 0x10c8 <DriverOLEDPrintSmText+0x6a>
    10dc:	ff e0       	ldi	r31, 0x0F	; 15
    10de:	ff 15       	cp	r31, r15
    10e0:	68 f2       	brcs	.-102    	; 0x107c <DriverOLEDPrintSmText+0x1e>
    10e2:	fb 01       	movw	r30, r22
    10e4:	40 81       	ld	r20, Z
    10e6:	44 23       	and	r20, r20
    10e8:	49 f2       	breq	.-110    	; 0x107c <DriverOLEDPrintSmText+0x1e>
    10ea:	eb 01       	movw	r28, r22
    10ec:	21 96       	adiw	r28, 0x01	; 1
    10ee:	10 e0       	ldi	r17, 0x00	; 0
    10f0:	0c c0       	rjmp	.+24     	; 0x110a <DriverOLEDPrintSmText+0xac>
    10f2:	26 e0       	ldi	r18, 0x06	; 6
    10f4:	12 9f       	mul	r17, r18
    10f6:	c0 01       	movw	r24, r0
    10f8:	11 24       	eor	r1, r1
    10fa:	cb 97       	sbiw	r24, 0x3b	; 59
    10fc:	6c f0       	brlt	.+26     	; 0x1118 <DriverOLEDPrintSmText+0xba>
    10fe:	f3 94       	inc	r15
    1100:	11 e0       	ldi	r17, 0x01	; 1
    1102:	49 91       	ld	r20, Y+
    1104:	44 23       	and	r20, r20
    1106:	09 f4       	brne	.+2      	; 0x110a <DriverOLEDPrintSmText+0xac>
    1108:	b9 cf       	rjmp	.-142    	; 0x107c <DriverOLEDPrintSmText+0x1e>
    110a:	11 38       	cpi	r17, 0x81	; 129
    110c:	18 f4       	brcc	.+6      	; 0x1114 <DriverOLEDPrintSmText+0xb6>
    110e:	f0 e4       	ldi	r31, 0x40	; 64
    1110:	ff 15       	cp	r31, r15
    1112:	20 f4       	brcc	.+8      	; 0x111c <DriverOLEDPrintSmText+0xbe>
    1114:	ee 20       	and	r14, r14
    1116:	69 f3       	breq	.-38     	; 0x10f2 <DriverOLEDPrintSmText+0x94>
    1118:	1f 5f       	subi	r17, 0xFF	; 255
    111a:	f3 cf       	rjmp	.-26     	; 0x1102 <DriverOLEDPrintSmText+0xa4>
    111c:	2e 2d       	mov	r18, r14
    111e:	6f 2d       	mov	r22, r15
    1120:	81 2f       	mov	r24, r17
    1122:	0e 94 1f 07 	call	0xe3e	; 0xe3e <DriverOLEDPrintSmChar.part.2>
    1126:	f6 cf       	rjmp	.-20     	; 0x1114 <DriverOLEDPrintSmText+0xb6>

00001128 <DriverOLEDInit>:

void DriverOLEDInit(uint8_t Orientation)
{
    1128:	0f 93       	push	r16
    112a:	1f 93       	push	r17
    112c:	cf 93       	push	r28
    112e:	df 93       	push	r29
    1130:	00 d0       	rcall	.+0      	; 0x1132 <DriverOLEDInit+0xa>
    1132:	1f 92       	push	r1
    1134:	cd b7       	in	r28, 0x3d	; 61
    1136:	de b7       	in	r29, 0x3e	; 62
	GlobOrientation=Orientation;
    1138:	80 93 bc 23 	sts	0x23BC, r24	; 0x8023bc <GlobOrientation>
}

void send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    113c:	10 e8       	ldi	r17, 0x80	; 128
    113e:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1140:	8e ea       	ldi	r24, 0xAE	; 174
    1142:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1144:	42 e0       	ldi	r20, 0x02	; 2
    1146:	be 01       	movw	r22, r28
    1148:	6f 5f       	subi	r22, 0xFF	; 255
    114a:	7f 4f       	sbci	r23, 0xFF	; 255
    114c:	8c e3       	ldi	r24, 0x3C	; 60
    114e:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
}

void send_command_data(uint8_t command, uint8_t data) {
	
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1152:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1154:	85 ed       	ldi	r24, 0xD5	; 213
    1156:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1158:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    115a:	1c 83       	std	Y+4, r17	; 0x04
	TWIMWrite(ADDRESS,Buffer,4);
    115c:	44 e0       	ldi	r20, 0x04	; 4
    115e:	be 01       	movw	r22, r28
    1160:	6f 5f       	subi	r22, 0xFF	; 255
    1162:	7f 4f       	sbci	r23, 0xFF	; 255
    1164:	8c e3       	ldi	r24, 0x3C	; 60
    1166:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
}

void send_command_data(uint8_t command, uint8_t data) {
	
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    116a:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    116c:	88 ea       	ldi	r24, 0xA8	; 168
    116e:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1170:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1172:	8f e3       	ldi	r24, 0x3F	; 63
    1174:	8c 83       	std	Y+4, r24	; 0x04
	TWIMWrite(ADDRESS,Buffer,4);
    1176:	44 e0       	ldi	r20, 0x04	; 4
    1178:	be 01       	movw	r22, r28
    117a:	6f 5f       	subi	r22, 0xFF	; 255
    117c:	7f 4f       	sbci	r23, 0xFF	; 255
    117e:	8c e3       	ldi	r24, 0x3C	; 60
    1180:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
}

void send_command_data(uint8_t command, uint8_t data) {
	
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1184:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1186:	83 ed       	ldi	r24, 0xD3	; 211
    1188:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    118a:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    118c:	1c 82       	std	Y+4, r1	; 0x04
	TWIMWrite(ADDRESS,Buffer,4);
    118e:	44 e0       	ldi	r20, 0x04	; 4
    1190:	be 01       	movw	r22, r28
    1192:	6f 5f       	subi	r22, 0xFF	; 255
    1194:	7f 4f       	sbci	r23, 0xFF	; 255
    1196:	8c e3       	ldi	r24, 0x3C	; 60
    1198:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
}

void send_command_data(uint8_t command, uint8_t data) {
	
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    119c:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    119e:	8d e8       	ldi	r24, 0x8D	; 141
    11a0:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    11a2:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    11a4:	84 e1       	ldi	r24, 0x14	; 20
    11a6:	8c 83       	std	Y+4, r24	; 0x04
	TWIMWrite(ADDRESS,Buffer,4);
    11a8:	44 e0       	ldi	r20, 0x04	; 4
    11aa:	be 01       	movw	r22, r28
    11ac:	6f 5f       	subi	r22, 0xFF	; 255
    11ae:	7f 4f       	sbci	r23, 0xFF	; 255
    11b0:	8c e3       	ldi	r24, 0x3C	; 60
    11b2:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
}

void send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    11b6:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    11b8:	00 e4       	ldi	r16, 0x40	; 64
    11ba:	0a 83       	std	Y+2, r16	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    11bc:	42 e0       	ldi	r20, 0x02	; 2
    11be:	be 01       	movw	r22, r28
    11c0:	6f 5f       	subi	r22, 0xFF	; 255
    11c2:	7f 4f       	sbci	r23, 0xFF	; 255
    11c4:	8c e3       	ldi	r24, 0x3C	; 60
    11c6:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
}

void send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    11ca:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    11cc:	86 ea       	ldi	r24, 0xA6	; 166
    11ce:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    11d0:	42 e0       	ldi	r20, 0x02	; 2
    11d2:	be 01       	movw	r22, r28
    11d4:	6f 5f       	subi	r22, 0xFF	; 255
    11d6:	7f 4f       	sbci	r23, 0xFF	; 255
    11d8:	8c e3       	ldi	r24, 0x3C	; 60
    11da:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
}

void send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    11de:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    11e0:	84 ea       	ldi	r24, 0xA4	; 164
    11e2:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    11e4:	42 e0       	ldi	r20, 0x02	; 2
    11e6:	be 01       	movw	r22, r28
    11e8:	6f 5f       	subi	r22, 0xFF	; 255
    11ea:	7f 4f       	sbci	r23, 0xFF	; 255
    11ec:	8c e3       	ldi	r24, 0x3C	; 60
    11ee:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
}

void send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    11f2:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    11f4:	81 ea       	ldi	r24, 0xA1	; 161
    11f6:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    11f8:	42 e0       	ldi	r20, 0x02	; 2
    11fa:	be 01       	movw	r22, r28
    11fc:	6f 5f       	subi	r22, 0xFF	; 255
    11fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1200:	8c e3       	ldi	r24, 0x3C	; 60
    1202:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
}

void send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1206:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1208:	88 ec       	ldi	r24, 0xC8	; 200
    120a:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    120c:	42 e0       	ldi	r20, 0x02	; 2
    120e:	be 01       	movw	r22, r28
    1210:	6f 5f       	subi	r22, 0xFF	; 255
    1212:	7f 4f       	sbci	r23, 0xFF	; 255
    1214:	8c e3       	ldi	r24, 0x3C	; 60
    1216:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
}

void send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    121a:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    121c:	80 e2       	ldi	r24, 0x20	; 32
    121e:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1220:	42 e0       	ldi	r20, 0x02	; 2
    1222:	be 01       	movw	r22, r28
    1224:	6f 5f       	subi	r22, 0xFF	; 255
    1226:	7f 4f       	sbci	r23, 0xFF	; 255
    1228:	8c e3       	ldi	r24, 0x3C	; 60
    122a:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
}

void send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    122e:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1230:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1232:	42 e0       	ldi	r20, 0x02	; 2
    1234:	be 01       	movw	r22, r28
    1236:	6f 5f       	subi	r22, 0xFF	; 255
    1238:	7f 4f       	sbci	r23, 0xFF	; 255
    123a:	8c e3       	ldi	r24, 0x3C	; 60
    123c:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
}

void send_command_data(uint8_t command, uint8_t data) {
	
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1240:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1242:	8a ed       	ldi	r24, 0xDA	; 218
    1244:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1246:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1248:	82 e1       	ldi	r24, 0x12	; 18
    124a:	8c 83       	std	Y+4, r24	; 0x04
	TWIMWrite(ADDRESS,Buffer,4);
    124c:	44 e0       	ldi	r20, 0x04	; 4
    124e:	be 01       	movw	r22, r28
    1250:	6f 5f       	subi	r22, 0xFF	; 255
    1252:	7f 4f       	sbci	r23, 0xFF	; 255
    1254:	8c e3       	ldi	r24, 0x3C	; 60
    1256:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
}

void send_command_data(uint8_t command, uint8_t data) {
	
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    125a:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    125c:	81 e8       	ldi	r24, 0x81	; 129
    125e:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1260:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1262:	8f e8       	ldi	r24, 0x8F	; 143
    1264:	8c 83       	std	Y+4, r24	; 0x04
	TWIMWrite(ADDRESS,Buffer,4);
    1266:	44 e0       	ldi	r20, 0x04	; 4
    1268:	be 01       	movw	r22, r28
    126a:	6f 5f       	subi	r22, 0xFF	; 255
    126c:	7f 4f       	sbci	r23, 0xFF	; 255
    126e:	8c e3       	ldi	r24, 0x3C	; 60
    1270:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
}

void send_command_data(uint8_t command, uint8_t data) {
	
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1274:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1276:	89 ed       	ldi	r24, 0xD9	; 217
    1278:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    127a:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    127c:	81 ef       	ldi	r24, 0xF1	; 241
    127e:	8c 83       	std	Y+4, r24	; 0x04
	TWIMWrite(ADDRESS,Buffer,4);
    1280:	44 e0       	ldi	r20, 0x04	; 4
    1282:	be 01       	movw	r22, r28
    1284:	6f 5f       	subi	r22, 0xFF	; 255
    1286:	7f 4f       	sbci	r23, 0xFF	; 255
    1288:	8c e3       	ldi	r24, 0x3C	; 60
    128a:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
}

void send_command_data(uint8_t command, uint8_t data) {
	
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    128e:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1290:	8b ed       	ldi	r24, 0xDB	; 219
    1292:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1294:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1296:	0c 83       	std	Y+4, r16	; 0x04
	TWIMWrite(ADDRESS,Buffer,4);
    1298:	44 e0       	ldi	r20, 0x04	; 4
    129a:	be 01       	movw	r22, r28
    129c:	6f 5f       	subi	r22, 0xFF	; 255
    129e:	7f 4f       	sbci	r23, 0xFF	; 255
    12a0:	8c e3       	ldi	r24, 0x3C	; 60
    12a2:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
}

void send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    12a6:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    12a8:	8f ea       	ldi	r24, 0xAF	; 175
    12aa:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    12ac:	42 e0       	ldi	r20, 0x02	; 2
    12ae:	be 01       	movw	r22, r28
    12b0:	6f 5f       	subi	r22, 0xFF	; 255
    12b2:	7f 4f       	sbci	r23, 0xFF	; 255
    12b4:	8c e3       	ldi	r24, 0x3C	; 60
    12b6:	0e 94 84 0b 	call	0x1708	; 0x1708 <TWIMWrite>
		return;
	}
}

void DriverOLEDClearScreen() {
	memset(buffer, 0, BUFFER_SIZE);
    12ba:	80 e0       	ldi	r24, 0x00	; 0
    12bc:	94 e0       	ldi	r25, 0x04	; 4
    12be:	ed eb       	ldi	r30, 0xBD	; 189
    12c0:	f3 e2       	ldi	r31, 0x23	; 35
    12c2:	df 01       	movw	r26, r30
    12c4:	9c 01       	movw	r18, r24
    12c6:	1d 92       	st	X+, r1
    12c8:	21 50       	subi	r18, 0x01	; 1
    12ca:	30 40       	sbci	r19, 0x00	; 0
    12cc:	e1 f7       	brne	.-8      	; 0x12c6 <DriverOLEDInit+0x19e>
	drawSolidRectangle(37,54,40,30);
	*/
	

	
	DriverOLEDUpdate();
    12ce:	0e 94 14 06 	call	0xc28	; 0xc28 <DriverOLEDUpdate>
    12d2:	24 96       	adiw	r28, 0x04	; 4
    12d4:	cd bf       	out	0x3d, r28	; 61
    12d6:	de bf       	out	0x3e, r29	; 62
    12d8:	df 91       	pop	r29
    12da:	cf 91       	pop	r28
    12dc:	1f 91       	pop	r17
    12de:	0f 91       	pop	r16
    12e0:	08 95       	ret

000012e2 <ShiftInBit>:
{
	uint8_t a;
	for (a=0;a<BUFFER_SIZE;a++)
		SendByte(DataBuffer[a]);
	
}
    12e2:	90 91 0c 28 	lds	r25, 0x280C	; 0x80280c <BitIdx>
    12e6:	20 91 0b 28 	lds	r18, 0x280B	; 0x80280b <ByteIdx>
    12ea:	91 11       	cpse	r25, r1
    12ec:	23 c0       	rjmp	.+70     	; 0x1334 <ShiftInBit+0x52>
    12ee:	42 2f       	mov	r20, r18
    12f0:	50 e0       	ldi	r21, 0x00	; 0
    12f2:	fa 01       	movw	r30, r20
    12f4:	e3 54       	subi	r30, 0x43	; 67
    12f6:	f8 4d       	sbci	r31, 0xD8	; 216
    12f8:	3f ef       	ldi	r19, 0xFF	; 255
    12fa:	30 83       	st	Z, r19
    12fc:	2e 34       	cpi	r18, 0x4E	; 78
    12fe:	08 f5       	brcc	.+66     	; 0x1342 <ShiftInBit+0x60>
    1300:	81 11       	cpse	r24, r1
    1302:	23 c0       	rjmp	.+70     	; 0x134a <ShiftInBit+0x68>
    1304:	fa 01       	movw	r30, r20
    1306:	e3 54       	subi	r30, 0x43	; 67
    1308:	f8 4d       	sbci	r31, 0xD8	; 216
    130a:	40 e8       	ldi	r20, 0x80	; 128
    130c:	50 e0       	ldi	r21, 0x00	; 0
    130e:	09 2e       	mov	r0, r25
    1310:	02 c0       	rjmp	.+4      	; 0x1316 <ShiftInBit+0x34>
    1312:	55 95       	asr	r21
    1314:	47 95       	ror	r20
    1316:	0a 94       	dec	r0
    1318:	e2 f7       	brpl	.-8      	; 0x1312 <ShiftInBit+0x30>
    131a:	40 95       	com	r20
    131c:	80 81       	ld	r24, Z
    131e:	48 23       	and	r20, r24
    1320:	40 83       	st	Z, r20
    1322:	9f 5f       	subi	r25, 0xFF	; 255
    1324:	98 30       	cpi	r25, 0x08	; 8
    1326:	91 f4       	brne	.+36     	; 0x134c <ShiftInBit+0x6a>
    1328:	10 92 0c 28 	sts	0x280C, r1	; 0x80280c <BitIdx>
    132c:	2f 5f       	subi	r18, 0xFF	; 255
    132e:	20 93 0b 28 	sts	0x280B, r18	; 0x80280b <ByteIdx>
    1332:	08 95       	ret
    1334:	2e 34       	cpi	r18, 0x4E	; 78
    1336:	a8 f7       	brcc	.-22     	; 0x1322 <ShiftInBit+0x40>
    1338:	81 11       	cpse	r24, r1
    133a:	f3 cf       	rjmp	.-26     	; 0x1322 <ShiftInBit+0x40>
    133c:	42 2f       	mov	r20, r18
    133e:	50 e0       	ldi	r21, 0x00	; 0
    1340:	e1 cf       	rjmp	.-62     	; 0x1304 <ShiftInBit+0x22>
    1342:	81 e0       	ldi	r24, 0x01	; 1
    1344:	80 93 0c 28 	sts	0x280C, r24	; 0x80280c <BitIdx>
    1348:	08 95       	ret
    134a:	91 e0       	ldi	r25, 0x01	; 1
    134c:	90 93 0c 28 	sts	0x280C, r25	; 0x80280c <BitIdx>
    1350:	08 95       	ret

00001352 <ShiftInReset>:
    1352:	20 91 0b 28 	lds	r18, 0x280B	; 0x80280b <ByteIdx>
    1356:	80 91 0c 28 	lds	r24, 0x280C	; 0x80280c <BitIdx>
    135a:	95 e8       	ldi	r25, 0x85	; 133
    135c:	3f ef       	ldi	r19, 0xFF	; 255
    135e:	08 c0       	rjmp	.+16     	; 0x1370 <ShiftInReset+0x1e>
    1360:	e2 2f       	mov	r30, r18
    1362:	f0 e0       	ldi	r31, 0x00	; 0
    1364:	e3 54       	subi	r30, 0x43	; 67
    1366:	f8 4d       	sbci	r31, 0xD8	; 216
    1368:	30 83       	st	Z, r19
    136a:	81 e0       	ldi	r24, 0x01	; 1
    136c:	91 50       	subi	r25, 0x01	; 1
    136e:	49 f0       	breq	.+18     	; 0x1382 <ShiftInReset+0x30>
    1370:	88 23       	and	r24, r24
    1372:	b1 f3       	breq	.-20     	; 0x1360 <ShiftInReset+0xe>
    1374:	8f 5f       	subi	r24, 0xFF	; 255
    1376:	88 30       	cpi	r24, 0x08	; 8
    1378:	c9 f7       	brne	.-14     	; 0x136c <ShiftInReset+0x1a>
    137a:	2f 5f       	subi	r18, 0xFF	; 255
    137c:	80 e0       	ldi	r24, 0x00	; 0
    137e:	91 50       	subi	r25, 0x01	; 1
    1380:	b9 f7       	brne	.-18     	; 0x1370 <ShiftInReset+0x1e>
    1382:	20 93 0b 28 	sts	0x280B, r18	; 0x80280b <ByteIdx>
    1386:	80 93 0c 28 	sts	0x280C, r24	; 0x80280c <BitIdx>
    138a:	08 95       	ret

0000138c <ShiftIn0>:
    138c:	80 e0       	ldi	r24, 0x00	; 0
    138e:	0e 94 71 09 	call	0x12e2	; 0x12e2 <ShiftInBit>
    1392:	80 91 0c 28 	lds	r24, 0x280C	; 0x80280c <BitIdx>
    1396:	e0 91 0b 28 	lds	r30, 0x280B	; 0x80280b <ByteIdx>
    139a:	81 11       	cpse	r24, r1
    139c:	19 c0       	rjmp	.+50     	; 0x13d0 <ShiftIn0+0x44>
    139e:	ae 2f       	mov	r26, r30
    13a0:	b0 e0       	ldi	r27, 0x00	; 0
    13a2:	a3 54       	subi	r26, 0x43	; 67
    13a4:	b8 4d       	sbci	r27, 0xD8	; 216
    13a6:	8f ef       	ldi	r24, 0xFF	; 255
    13a8:	8c 93       	st	X, r24
    13aa:	82 e0       	ldi	r24, 0x02	; 2
    13ac:	91 e0       	ldi	r25, 0x01	; 1
    13ae:	98 0f       	add	r25, r24
    13b0:	88 23       	and	r24, r24
    13b2:	99 f1       	breq	.+102    	; 0x141a <ShiftIn0+0x8e>
    13b4:	98 30       	cpi	r25, 0x08	; 8
    13b6:	d1 f4       	brne	.+52     	; 0x13ec <ShiftIn0+0x60>
    13b8:	ef 5f       	subi	r30, 0xFF	; 255
    13ba:	e0 93 0b 28 	sts	0x280B, r30	; 0x80280b <ByteIdx>
    13be:	81 e0       	ldi	r24, 0x01	; 1
    13c0:	f0 e0       	ldi	r31, 0x00	; 0
    13c2:	e3 54       	subi	r30, 0x43	; 67
    13c4:	f8 4d       	sbci	r31, 0xD8	; 216
    13c6:	9f ef       	ldi	r25, 0xFF	; 255
    13c8:	90 83       	st	Z, r25
    13ca:	80 93 0c 28 	sts	0x280C, r24	; 0x80280c <BitIdx>
    13ce:	08 95       	ret
    13d0:	91 e0       	ldi	r25, 0x01	; 1
    13d2:	98 0f       	add	r25, r24
    13d4:	98 30       	cpi	r25, 0x08	; 8
    13d6:	b1 f4       	brne	.+44     	; 0x1404 <ShiftIn0+0x78>
    13d8:	ef 5f       	subi	r30, 0xFF	; 255
    13da:	e0 93 0b 28 	sts	0x280B, r30	; 0x80280b <ByteIdx>
    13de:	ae 2f       	mov	r26, r30
    13e0:	b0 e0       	ldi	r27, 0x00	; 0
    13e2:	a3 54       	subi	r26, 0x43	; 67
    13e4:	b8 4d       	sbci	r27, 0xD8	; 216
    13e6:	8f ef       	ldi	r24, 0xFF	; 255
    13e8:	8c 93       	st	X, r24
    13ea:	92 e0       	ldi	r25, 0x02	; 2
    13ec:	81 e0       	ldi	r24, 0x01	; 1
    13ee:	89 0f       	add	r24, r25
    13f0:	99 23       	and	r25, r25
    13f2:	31 f3       	breq	.-52     	; 0x13c0 <ShiftIn0+0x34>
    13f4:	88 30       	cpi	r24, 0x08	; 8
    13f6:	c9 f4       	brne	.+50     	; 0x142a <ShiftIn0+0x9e>
    13f8:	10 92 0c 28 	sts	0x280C, r1	; 0x80280c <BitIdx>
    13fc:	ef 5f       	subi	r30, 0xFF	; 255
    13fe:	e0 93 0b 28 	sts	0x280B, r30	; 0x80280b <ByteIdx>
    1402:	08 95       	ret
    1404:	99 23       	and	r25, r25
    1406:	59 f3       	breq	.-42     	; 0x13de <ShiftIn0+0x52>
    1408:	8e 5f       	subi	r24, 0xFE	; 254
    140a:	88 30       	cpi	r24, 0x08	; 8
    140c:	79 f6       	brne	.-98     	; 0x13ac <ShiftIn0+0x20>
    140e:	ef 5f       	subi	r30, 0xFF	; 255
    1410:	e0 93 0b 28 	sts	0x280B, r30	; 0x80280b <ByteIdx>
    1414:	82 e0       	ldi	r24, 0x02	; 2
    1416:	91 e0       	ldi	r25, 0x01	; 1
    1418:	01 c0       	rjmp	.+2      	; 0x141c <ShiftIn0+0x90>
    141a:	82 e0       	ldi	r24, 0x02	; 2
    141c:	ae 2f       	mov	r26, r30
    141e:	b0 e0       	ldi	r27, 0x00	; 0
    1420:	a3 54       	subi	r26, 0x43	; 67
    1422:	b8 4d       	sbci	r27, 0xD8	; 216
    1424:	2f ef       	ldi	r18, 0xFF	; 255
    1426:	2c 93       	st	X, r18
    1428:	e3 cf       	rjmp	.-58     	; 0x13f0 <ShiftIn0+0x64>
    142a:	80 93 0c 28 	sts	0x280C, r24	; 0x80280c <BitIdx>
    142e:	08 95       	ret

00001430 <ShiftIn1>:
    1430:	80 e0       	ldi	r24, 0x00	; 0
    1432:	0e 94 71 09 	call	0x12e2	; 0x12e2 <ShiftInBit>
    1436:	80 e0       	ldi	r24, 0x00	; 0
    1438:	0e 94 71 09 	call	0x12e2	; 0x12e2 <ShiftInBit>
    143c:	80 e0       	ldi	r24, 0x00	; 0
    143e:	0e 94 71 09 	call	0x12e2	; 0x12e2 <ShiftInBit>
    1442:	80 e0       	ldi	r24, 0x00	; 0
    1444:	0e 94 71 09 	call	0x12e2	; 0x12e2 <ShiftInBit>
    1448:	80 91 0c 28 	lds	r24, 0x280C	; 0x80280c <BitIdx>
    144c:	81 11       	cpse	r24, r1
    144e:	0b c0       	rjmp	.+22     	; 0x1466 <ShiftIn1+0x36>
    1450:	e0 91 0b 28 	lds	r30, 0x280B	; 0x80280b <ByteIdx>
    1454:	f0 e0       	ldi	r31, 0x00	; 0
    1456:	e3 54       	subi	r30, 0x43	; 67
    1458:	f8 4d       	sbci	r31, 0xD8	; 216
    145a:	8f ef       	ldi	r24, 0xFF	; 255
    145c:	80 83       	st	Z, r24
    145e:	81 e0       	ldi	r24, 0x01	; 1
    1460:	80 93 0c 28 	sts	0x280C, r24	; 0x80280c <BitIdx>
    1464:	08 95       	ret
    1466:	8f 5f       	subi	r24, 0xFF	; 255
    1468:	88 30       	cpi	r24, 0x08	; 8
    146a:	41 f4       	brne	.+16     	; 0x147c <ShiftIn1+0x4c>
    146c:	80 91 0b 28 	lds	r24, 0x280B	; 0x80280b <ByteIdx>
    1470:	10 92 0c 28 	sts	0x280C, r1	; 0x80280c <BitIdx>
    1474:	8f 5f       	subi	r24, 0xFF	; 255
    1476:	80 93 0b 28 	sts	0x280B, r24	; 0x80280b <ByteIdx>
    147a:	08 95       	ret
    147c:	80 93 0c 28 	sts	0x280C, r24	; 0x80280c <BitIdx>
    1480:	08 95       	ret

00001482 <ShiftInByte>:
    1482:	cf 93       	push	r28
    1484:	df 93       	push	r29
    1486:	d8 2f       	mov	r29, r24
    1488:	c8 e0       	ldi	r28, 0x08	; 8
    148a:	05 c0       	rjmp	.+10     	; 0x1496 <ShiftInByte+0x14>
    148c:	0e 94 c6 09 	call	0x138c	; 0x138c <ShiftIn0>
    1490:	dd 0f       	add	r29, r29
    1492:	c1 50       	subi	r28, 0x01	; 1
    1494:	39 f0       	breq	.+14     	; 0x14a4 <ShiftInByte+0x22>
    1496:	d7 ff       	sbrs	r29, 7
    1498:	f9 cf       	rjmp	.-14     	; 0x148c <ShiftInByte+0xa>
    149a:	0e 94 18 0a 	call	0x1430	; 0x1430 <ShiftIn1>
    149e:	dd 0f       	add	r29, r29
    14a0:	c1 50       	subi	r28, 0x01	; 1
    14a2:	c9 f7       	brne	.-14     	; 0x1496 <ShiftInByte+0x14>
    14a4:	df 91       	pop	r29
    14a6:	cf 91       	pop	r28
    14a8:	08 95       	ret

000014aa <DriverPL9823Init>:
void DriverPL9823Init()
{
	//CS init
	PORTA.DIRSET=1<<6;
    14aa:	e0 e0       	ldi	r30, 0x00	; 0
    14ac:	f6 e0       	ldi	r31, 0x06	; 6
    14ae:	80 e4       	ldi	r24, 0x40	; 64
    14b0:	81 83       	std	Z+1, r24	; 0x01
	PORTA.OUTCLR=1<<6;
    14b2:	86 83       	std	Z+6, r24	; 0x06
	
	//Data init
	PORTD.DIRSET=0b1000;
    14b4:	e0 e6       	ldi	r30, 0x60	; 96
    14b6:	f6 e0       	ldi	r31, 0x06	; 6
    14b8:	98 e0       	ldi	r25, 0x08	; 8
    14ba:	91 83       	std	Z+1, r25	; 0x01
	PORTD.PIN3CTRL=0b01000000;
    14bc:	83 8b       	std	Z+19, r24	; 0x13
	USARTD0.CTRLB=0b1000;
    14be:	e0 ea       	ldi	r30, 0xA0	; 160
    14c0:	f9 e0       	ldi	r31, 0x09	; 9
    14c2:	94 83       	std	Z+4, r25	; 0x04
	USARTD0.CTRLC=0b11000000;
    14c4:	80 ec       	ldi	r24, 0xC0	; 192
    14c6:	85 83       	std	Z+5, r24	; 0x05
	USARTD0.BAUDCTRLA=5; //0.375s per bit
    14c8:	85 e0       	ldi	r24, 0x05	; 5
    14ca:	86 83       	std	Z+6, r24	; 0x06
    14cc:	08 95       	ret

000014ce <DriverPL9823Set>:
}
void DriverPL9823Set(uint8_t *r,uint8_t *g,uint8_t *b)
{
    14ce:	8f 92       	push	r8
    14d0:	9f 92       	push	r9
    14d2:	af 92       	push	r10
    14d4:	bf 92       	push	r11
    14d6:	cf 92       	push	r12
    14d8:	df 92       	push	r13
    14da:	ef 92       	push	r14
    14dc:	ff 92       	push	r15
    14de:	0f 93       	push	r16
    14e0:	1f 93       	push	r17
    14e2:	cf 93       	push	r28
    14e4:	df 93       	push	r29
    14e6:	6c 01       	movw	r12, r24
    14e8:	7b 01       	movw	r14, r22
    14ea:	5a 01       	movw	r10, r20
}

void ShiftReset()
{
	uint8_t a;
	BitIdx=0;
    14ec:	10 92 0c 28 	sts	0x280C, r1	; 0x80280c <BitIdx>
	ByteIdx=0;
    14f0:	10 92 0b 28 	sts	0x280B, r1	; 0x80280b <ByteIdx>
    14f4:	cd eb       	ldi	r28, 0xBD	; 189
    14f6:	d7 e2       	ldi	r29, 0x27	; 39
    14f8:	0b e0       	ldi	r16, 0x0B	; 11
    14fa:	18 e2       	ldi	r17, 0x28	; 40
    14fc:	fe 01       	movw	r30, r28
	
	for (a=0;a<BUFFER_SIZE;a++)
		DataBuffer[a]=255;	
    14fe:	8f ef       	ldi	r24, 0xFF	; 255
    1500:	81 93       	st	Z+, r24
{
	uint8_t a;
	BitIdx=0;
	ByteIdx=0;
	
	for (a=0;a<BUFFER_SIZE;a++)
    1502:	98 e2       	ldi	r25, 0x28	; 40
    1504:	eb 30       	cpi	r30, 0x0B	; 11
    1506:	f9 07       	cpc	r31, r25
    1508:	d9 f7       	brne	.-10     	; 0x1500 <DriverPL9823Set+0x32>
void DriverPL9823Set(uint8_t *r,uint8_t *g,uint8_t *b)
{
	uint8_t a;
	ShiftReset();

	ShiftInReset();
    150a:	0e 94 a9 09 	call	0x1352	; 0x1352 <ShiftInReset>
	
	PORTA.OUTSET=1<<6; //CS enable
    150e:	80 e4       	ldi	r24, 0x40	; 64
    1510:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
    1514:	46 01       	movw	r8, r12
    1516:	67 01       	movw	r12, r14
    1518:	75 01       	movw	r14, r10
    151a:	54 01       	movw	r10, r8
    151c:	e4 e0       	ldi	r30, 0x04	; 4
    151e:	ae 0e       	add	r10, r30
    1520:	b1 1c       	adc	r11, r1
	for (a=0;a<4;a++)
	{
		ShiftInByte(r[a]);
    1522:	f4 01       	movw	r30, r8
    1524:	81 91       	ld	r24, Z+
    1526:	4f 01       	movw	r8, r30
    1528:	0e 94 41 0a 	call	0x1482	; 0x1482 <ShiftInByte>
		ShiftInByte(g[a]);
    152c:	f6 01       	movw	r30, r12
    152e:	81 91       	ld	r24, Z+
    1530:	6f 01       	movw	r12, r30
    1532:	0e 94 41 0a 	call	0x1482	; 0x1482 <ShiftInByte>
		ShiftInByte(b[a]);
    1536:	f7 01       	movw	r30, r14
    1538:	81 91       	ld	r24, Z+
    153a:	7f 01       	movw	r14, r30
    153c:	0e 94 41 0a 	call	0x1482	; 0x1482 <ShiftInByte>
	ShiftReset();

	ShiftInReset();
	
	PORTA.OUTSET=1<<6; //CS enable
	for (a=0;a<4;a++)
    1540:	8a 14       	cp	r8, r10
    1542:	9b 04       	cpc	r9, r11
    1544:	71 f7       	brne	.-36     	; 0x1522 <DriverPL9823Set+0x54>

void SendBuffer()
{
	uint8_t a;
	for (a=0;a<BUFFER_SIZE;a++)
		SendByte(DataBuffer[a]);
    1546:	99 91       	ld	r25, Y+
static uint8_t BitIdx=0,ByteIdx=0;
static uint8_t DataBuffer[BUFFER_SIZE];

void SendByte(uint8_t Data)
{
	while (!(USARTD0.STATUS&0b100000));
    1548:	80 91 a1 09 	lds	r24, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    154c:	85 ff       	sbrs	r24, 5
    154e:	fc cf       	rjmp	.-8      	; 0x1548 <DriverPL9823Set+0x7a>
	USARTD0.DATA=Data;
    1550:	90 93 a0 09 	sts	0x09A0, r25	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>


void SendBuffer()
{
	uint8_t a;
	for (a=0;a<BUFFER_SIZE;a++)
    1554:	0c 17       	cp	r16, r28
    1556:	1d 07       	cpc	r17, r29
    1558:	b1 f7       	brne	.-20     	; 0x1546 <DriverPL9823Set+0x78>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    155a:	8f e8       	ldi	r24, 0x8F	; 143
    155c:	91 e0       	ldi	r25, 0x01	; 1
    155e:	01 97       	sbiw	r24, 0x01	; 1
    1560:	f1 f7       	brne	.-4      	; 0x155e <DriverPL9823Set+0x90>
    1562:	00 c0       	rjmp	.+0      	; 0x1564 <DriverPL9823Set+0x96>
    1564:	00 00       	nop
		ShiftInByte(g[a]);
		ShiftInByte(b[a]);
	}
	SendBuffer();
	_delay_us(50);
	PORTA.OUTCLR=1<<6; //CS disable
    1566:	80 e4       	ldi	r24, 0x40	; 64
    1568:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    156c:	df 91       	pop	r29
    156e:	cf 91       	pop	r28
    1570:	1f 91       	pop	r17
    1572:	0f 91       	pop	r16
    1574:	ff 90       	pop	r15
    1576:	ef 90       	pop	r14
    1578:	df 90       	pop	r13
    157a:	cf 90       	pop	r12
    157c:	bf 90       	pop	r11
    157e:	af 90       	pop	r10
    1580:	9f 90       	pop	r9
    1582:	8f 90       	pop	r8
    1584:	08 95       	ret

00001586 <DriverPowerInit>:
#include "DriverPower.h"

void DriverPowerInit(void)
{
	//Aux Vcc GPIO setup
	PORTC.DIRSET=1<<5;
    1586:	80 e2       	ldi	r24, 0x20	; 32
    1588:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
    158c:	08 95       	ret

0000158e <DriverPowerVccAuxSet>:
}


void DriverPowerVccAuxSet(uint8_t State)
{
	if (State)
    158e:	81 11       	cpse	r24, r1
    1590:	04 c0       	rjmp	.+8      	; 0x159a <DriverPowerVccAuxSet+0xc>
		PORTC.OUTSET=1<<5;
	else
		PORTC.OUTCLR=1<<5;
    1592:	80 e2       	ldi	r24, 0x20	; 32
    1594:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
    1598:	08 95       	ret


void DriverPowerVccAuxSet(uint8_t State)
{
	if (State)
		PORTC.OUTSET=1<<5;
    159a:	80 e2       	ldi	r24, 0x20	; 32
    159c:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
    15a0:	08 95       	ret

000015a2 <DriverSysClkXtalInit>:
    // Clock setup          
    if (F_XTAL<400E3) return -1; //Invalid frequency
    if (F_XTAL<=2E6) OSC.XOSCCTRL=0b00001011; //Select <2 Mhz XTAL osc, max startup time
    else if(F_XTAL<=9E6) OSC.XOSCCTRL=0b01001011; //Select <2 Mhz XTAL osc, max startup time 
    else if(F_XTAL<=12E6) OSC.XOSCCTRL=0b10001011; //Select <2 Mhz XTAL osc, max startup time 
    else if(F_XTAL<=16E6) OSC.XOSCCTRL=0b11001011; //Select <2 Mhz XTAL osc, max startup time 
    15a2:	8b ec       	ldi	r24, 0xCB	; 203
    15a4:	80 93 52 00 	sts	0x0052, r24	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>
    else return -1; //Invalid frequency
    OSC.CTRL=0b01000; //Enable oscillator
    15a8:	88 e0       	ldi	r24, 0x08	; 8
    15aa:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
    
	//Wait until XTAL osc is ready
    while (!(OSC.STATUS&0b1000)); 
    15ae:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
    15b2:	83 ff       	sbrs	r24, 3
    15b4:	fc cf       	rjmp	.-8      	; 0x15ae <DriverSysClkXtalInit+0xc>
	{
		//Configure PLL
		Mult=F_CPU/F_XTAL;
		if (Mult>31) return -1; //Invalid frequency; too high
		if (F_XTAL * (uint32_t) Mult !=F_CPU) return -1; //Only supports whole dividers
		OSC.PLLCTRL=0b11000000 | (Mult);
    15b6:	82 ec       	ldi	r24, 0xC2	; 194
    15b8:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
		OSC.CTRL=0b00011000; //Enable PLL
    15bc:	88 e1       	ldi	r24, 0x18	; 24
    15be:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
		
		//Wait until PLL is ready
		while (!(OSC.STATUS & 0b00010000));
    15c2:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
    15c6:	84 ff       	sbrs	r24, 4
    15c8:	fc cf       	rjmp	.-8      	; 0x15c2 <DriverSysClkXtalInit+0x20>
		
		//Select PLL as system CLK source
		CCP=0xd8;
    15ca:	88 ed       	ldi	r24, 0xD8	; 216
    15cc:	84 bf       	out	0x34, r24	; 52
		CLK.CTRL=0b100;
    15ce:	84 e0       	ldi	r24, 0x04	; 4
    15d0:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
	}
	return 0;
}
    15d4:	80 e0       	ldi	r24, 0x00	; 0
    15d6:	08 95       	ret

000015d8 <DriverTWIMInit>:
}

void TWIMTransactionFinished( uint8_t result)
{
	Twim_result = result;
	Twim_status = TWIM_STATUS_READY;
    15d8:	10 92 11 28 	sts	0x2811, r1	; 0x802811 <Twim_status>
    15dc:	e0 e8       	ldi	r30, 0x80	; 128
    15de:	f6 e0       	ldi	r31, 0x06	; 6
    15e0:	88 e1       	ldi	r24, 0x18	; 24
    15e2:	80 8b       	std	Z+16, r24	; 0x10
    15e4:	81 8b       	std	Z+17, r24	; 0x11
    15e6:	e0 ea       	ldi	r30, 0xA0	; 160
    15e8:	f4 e0       	ldi	r31, 0x04	; 4
    15ea:	88 e7       	ldi	r24, 0x78	; 120
    15ec:	81 83       	std	Z+1, r24	; 0x01
    15ee:	83 e2       	ldi	r24, 0x23	; 35
    15f0:	85 83       	std	Z+5, r24	; 0x05
    15f2:	81 e0       	ldi	r24, 0x01	; 1
    15f4:	84 83       	std	Z+4, r24	; 0x04
    15f6:	43 e0       	ldi	r20, 0x03	; 3
    15f8:	60 e0       	ldi	r22, 0x00	; 0
    15fa:	0e 94 2d 11 	call	0x225a	; 0x225a <xQueueGenericCreate>
    15fe:	80 93 0f 28 	sts	0x280F, r24	; 0x80280f <SemaBus>
    1602:	90 93 10 28 	sts	0x2810, r25	; 0x802810 <SemaBus+0x1>
    1606:	20 e0       	ldi	r18, 0x00	; 0
    1608:	40 e0       	ldi	r20, 0x00	; 0
    160a:	50 e0       	ldi	r21, 0x00	; 0
    160c:	60 e0       	ldi	r22, 0x00	; 0
    160e:	70 e0       	ldi	r23, 0x00	; 0
    1610:	0e 94 71 11 	call	0x22e2	; 0x22e2 <xQueueGenericSend>
    1614:	43 e0       	ldi	r20, 0x03	; 3
    1616:	60 e0       	ldi	r22, 0x00	; 0
    1618:	81 e0       	ldi	r24, 0x01	; 1
    161a:	0e 94 2d 11 	call	0x225a	; 0x225a <xQueueGenericCreate>
    161e:	80 93 0d 28 	sts	0x280D, r24	; 0x80280d <SemaRx>
    1622:	90 93 0e 28 	sts	0x280E, r25	; 0x80280e <SemaRx+0x1>
    1626:	08 95       	ret

00001628 <TWIMWriteRead>:
    1628:	cf 92       	push	r12
    162a:	df 92       	push	r13
    162c:	ef 92       	push	r14
    162e:	ff 92       	push	r15
    1630:	0f 93       	push	r16
    1632:	cf 93       	push	r28
    1634:	df 93       	push	r29
    1636:	c8 2f       	mov	r28, r24
    1638:	6b 01       	movw	r12, r22
    163a:	d4 2f       	mov	r29, r20
    163c:	79 01       	movw	r14, r18
    163e:	6f ef       	ldi	r22, 0xFF	; 255
    1640:	7f ef       	ldi	r23, 0xFF	; 255
    1642:	80 91 0f 28 	lds	r24, 0x280F	; 0x80280f <SemaBus>
    1646:	90 91 10 28 	lds	r25, 0x2810	; 0x802810 <SemaBus+0x1>
    164a:	0e 94 ab 13 	call	0x2756	; 0x2756 <xQueueSemaphoreTake>
    164e:	c0 92 18 28 	sts	0x2818, r12	; 0x802818 <Twim_writeData>
    1652:	d0 92 19 28 	sts	0x2819, r13	; 0x802819 <Twim_writeData+0x1>
    1656:	e0 92 16 28 	sts	0x2816, r14	; 0x802816 <Twim_readData>
    165a:	f0 92 17 28 	sts	0x2817, r15	; 0x802817 <Twim_readData+0x1>
    165e:	80 91 11 28 	lds	r24, 0x2811	; 0x802811 <Twim_status>
    1662:	81 11       	cpse	r24, r1
    1664:	3d c0       	rjmp	.+122    	; 0x16e0 <TWIMWriteRead+0xb8>
    1666:	81 e0       	ldi	r24, 0x01	; 1
    1668:	80 93 11 28 	sts	0x2811, r24	; 0x802811 <Twim_status>
    166c:	cc 0f       	add	r28, r28
    166e:	c0 93 1a 28 	sts	0x281A, r28	; 0x80281a <Twim_address>
    1672:	d0 93 15 28 	sts	0x2815, r29	; 0x802815 <Twim_bytesToWrite>
    1676:	00 93 14 28 	sts	0x2814, r16	; 0x802814 <Twim_bytesToRead>
    167a:	10 92 13 28 	sts	0x2813, r1	; 0x802813 <Twim_bytesWritten>
    167e:	10 92 12 28 	sts	0x2812, r1	; 0x802812 <Twim_bytesRead>
    1682:	80 91 15 28 	lds	r24, 0x2815	; 0x802815 <Twim_bytesToWrite>
    1686:	81 11       	cpse	r24, r1
    1688:	25 c0       	rjmp	.+74     	; 0x16d4 <TWIMWriteRead+0xac>
    168a:	80 91 14 28 	lds	r24, 0x2814	; 0x802814 <Twim_bytesToRead>
    168e:	88 23       	and	r24, r24
    1690:	29 f0       	breq	.+10     	; 0x169c <TWIMWriteRead+0x74>
    1692:	80 91 1a 28 	lds	r24, 0x281A	; 0x80281a <Twim_address>
    1696:	81 60       	ori	r24, 0x01	; 1
    1698:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7004a6>
    169c:	68 ee       	ldi	r22, 0xE8	; 232
    169e:	73 e0       	ldi	r23, 0x03	; 3
    16a0:	80 91 0d 28 	lds	r24, 0x280D	; 0x80280d <SemaRx>
    16a4:	90 91 0e 28 	lds	r25, 0x280E	; 0x80280e <SemaRx+0x1>
    16a8:	0e 94 ab 13 	call	0x2756	; 0x2756 <xQueueSemaphoreTake>
    16ac:	20 e0       	ldi	r18, 0x00	; 0
    16ae:	40 e0       	ldi	r20, 0x00	; 0
    16b0:	50 e0       	ldi	r21, 0x00	; 0
    16b2:	60 e0       	ldi	r22, 0x00	; 0
    16b4:	70 e0       	ldi	r23, 0x00	; 0
    16b6:	80 91 0f 28 	lds	r24, 0x280F	; 0x80280f <SemaBus>
    16ba:	90 91 10 28 	lds	r25, 0x2810	; 0x802810 <SemaBus+0x1>
    16be:	0e 94 71 11 	call	0x22e2	; 0x22e2 <xQueueGenericSend>
    16c2:	81 e0       	ldi	r24, 0x01	; 1
    16c4:	df 91       	pop	r29
    16c6:	cf 91       	pop	r28
    16c8:	0f 91       	pop	r16
    16ca:	ff 90       	pop	r15
    16cc:	ef 90       	pop	r14
    16ce:	df 90       	pop	r13
    16d0:	cf 90       	pop	r12
    16d2:	08 95       	ret
    16d4:	80 91 1a 28 	lds	r24, 0x281A	; 0x80281a <Twim_address>
    16d8:	8e 7f       	andi	r24, 0xFE	; 254
    16da:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7004a6>
    16de:	de cf       	rjmp	.-68     	; 0x169c <TWIMWriteRead+0x74>
    16e0:	20 e0       	ldi	r18, 0x00	; 0
    16e2:	40 e0       	ldi	r20, 0x00	; 0
    16e4:	50 e0       	ldi	r21, 0x00	; 0
    16e6:	60 e0       	ldi	r22, 0x00	; 0
    16e8:	70 e0       	ldi	r23, 0x00	; 0
    16ea:	80 91 0f 28 	lds	r24, 0x280F	; 0x80280f <SemaBus>
    16ee:	90 91 10 28 	lds	r25, 0x2810	; 0x802810 <SemaBus+0x1>
    16f2:	0e 94 71 11 	call	0x22e2	; 0x22e2 <xQueueGenericSend>
    16f6:	80 e0       	ldi	r24, 0x00	; 0
    16f8:	df 91       	pop	r29
    16fa:	cf 91       	pop	r28
    16fc:	0f 91       	pop	r16
    16fe:	ff 90       	pop	r15
    1700:	ef 90       	pop	r14
    1702:	df 90       	pop	r13
    1704:	cf 90       	pop	r12
    1706:	08 95       	ret

00001708 <TWIMWrite>:
    1708:	0f 93       	push	r16
    170a:	00 e0       	ldi	r16, 0x00	; 0
    170c:	20 e0       	ldi	r18, 0x00	; 0
    170e:	30 e0       	ldi	r19, 0x00	; 0
    1710:	0e 94 14 0b 	call	0x1628	; 0x1628 <TWIMWriteRead>
    1714:	0f 91       	pop	r16
    1716:	08 95       	ret

00001718 <TWIMWriteHandler>:
    1718:	90 91 15 28 	lds	r25, 0x2815	; 0x802815 <Twim_bytesToWrite>
    171c:	20 91 14 28 	lds	r18, 0x2814	; 0x802814 <Twim_bytesToRead>
    1720:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>
    1724:	84 fd       	sbrc	r24, 4
    1726:	08 c0       	rjmp	.+16     	; 0x1738 <TWIMWriteHandler+0x20>
    1728:	80 91 13 28 	lds	r24, 0x2813	; 0x802813 <Twim_bytesWritten>
    172c:	89 17       	cp	r24, r25
    172e:	50 f0       	brcs	.+20     	; 0x1744 <TWIMWriteHandler+0x2c>
    1730:	80 91 12 28 	lds	r24, 0x2812	; 0x802812 <Twim_bytesRead>
    1734:	82 17       	cp	r24, r18
    1736:	b8 f0       	brcs	.+46     	; 0x1766 <TWIMWriteHandler+0x4e>
    1738:	83 e0       	ldi	r24, 0x03	; 3
    173a:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    173e:	10 92 11 28 	sts	0x2811, r1	; 0x802811 <Twim_status>
    1742:	08 95       	ret
    1744:	80 91 13 28 	lds	r24, 0x2813	; 0x802813 <Twim_bytesWritten>
    1748:	e0 91 18 28 	lds	r30, 0x2818	; 0x802818 <Twim_writeData>
    174c:	f0 91 19 28 	lds	r31, 0x2819	; 0x802819 <Twim_writeData+0x1>
    1750:	e8 0f       	add	r30, r24
    1752:	f1 1d       	adc	r31, r1
    1754:	80 81       	ld	r24, Z
    1756:	80 93 a7 04 	sts	0x04A7, r24	; 0x8004a7 <__TEXT_REGION_LENGTH__+0x7004a7>
    175a:	80 91 13 28 	lds	r24, 0x2813	; 0x802813 <Twim_bytesWritten>
    175e:	8f 5f       	subi	r24, 0xFF	; 255
    1760:	80 93 13 28 	sts	0x2813, r24	; 0x802813 <Twim_bytesWritten>
    1764:	08 95       	ret
    1766:	80 91 1a 28 	lds	r24, 0x281A	; 0x80281a <Twim_address>
    176a:	81 60       	ori	r24, 0x01	; 1
    176c:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7004a6>
    1770:	08 95       	ret

00001772 <TWIMReadHandler>:
    1772:	80 91 12 28 	lds	r24, 0x2812	; 0x802812 <Twim_bytesRead>
    1776:	80 32       	cpi	r24, 0x20	; 32
    1778:	e0 f4       	brcc	.+56     	; 0x17b2 <TWIMReadHandler+0x40>
    177a:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <__TEXT_REGION_LENGTH__+0x7004a7>
    177e:	90 91 12 28 	lds	r25, 0x2812	; 0x802812 <Twim_bytesRead>
    1782:	e0 91 16 28 	lds	r30, 0x2816	; 0x802816 <Twim_readData>
    1786:	f0 91 17 28 	lds	r31, 0x2817	; 0x802817 <Twim_readData+0x1>
    178a:	e9 0f       	add	r30, r25
    178c:	f1 1d       	adc	r31, r1
    178e:	80 83       	st	Z, r24
    1790:	80 91 12 28 	lds	r24, 0x2812	; 0x802812 <Twim_bytesRead>
    1794:	8f 5f       	subi	r24, 0xFF	; 255
    1796:	80 93 12 28 	sts	0x2812, r24	; 0x802812 <Twim_bytesRead>
    179a:	90 91 14 28 	lds	r25, 0x2814	; 0x802814 <Twim_bytesToRead>
    179e:	80 91 12 28 	lds	r24, 0x2812	; 0x802812 <Twim_bytesRead>
    17a2:	89 17       	cp	r24, r25
    17a4:	88 f0       	brcs	.+34     	; 0x17c8 <TWIMReadHandler+0x56>
    17a6:	87 e0       	ldi	r24, 0x07	; 7
    17a8:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    17ac:	10 92 11 28 	sts	0x2811, r1	; 0x802811 <Twim_status>
    17b0:	08 95       	ret
    17b2:	83 e0       	ldi	r24, 0x03	; 3
    17b4:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    17b8:	10 92 11 28 	sts	0x2811, r1	; 0x802811 <Twim_status>
    17bc:	90 91 14 28 	lds	r25, 0x2814	; 0x802814 <Twim_bytesToRead>
    17c0:	80 91 12 28 	lds	r24, 0x2812	; 0x802812 <Twim_bytesRead>
    17c4:	89 17       	cp	r24, r25
    17c6:	78 f7       	brcc	.-34     	; 0x17a6 <TWIMReadHandler+0x34>
    17c8:	82 e0       	ldi	r24, 0x02	; 2
    17ca:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    17ce:	08 95       	ret

000017d0 <__vector_46>:
}

ISR (TWIM_BUS_vect)
{
    17d0:	1f 92       	push	r1
    17d2:	0f 92       	push	r0
    17d4:	0f b6       	in	r0, 0x3f	; 63
    17d6:	0f 92       	push	r0
    17d8:	11 24       	eor	r1, r1
    17da:	0b b6       	in	r0, 0x3b	; 59
    17dc:	0f 92       	push	r0
    17de:	2f 93       	push	r18
    17e0:	3f 93       	push	r19
    17e2:	4f 93       	push	r20
    17e4:	5f 93       	push	r21
    17e6:	6f 93       	push	r22
    17e8:	7f 93       	push	r23
    17ea:	8f 93       	push	r24
    17ec:	9f 93       	push	r25
    17ee:	af 93       	push	r26
    17f0:	bf 93       	push	r27
    17f2:	ef 93       	push	r30
    17f4:	ff 93       	push	r31
    17f6:	cf 93       	push	r28
    17f8:	df 93       	push	r29
    17fa:	1f 92       	push	r1
    17fc:	cd b7       	in	r28, 0x3d	; 61
    17fe:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    1800:	19 82       	std	Y+1, r1	; 0x01
	uint8_t currentStatus = TWIM_BUS.MASTER.STATUS;
    1802:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>

	/* If arbitration lost or bus error. */
	if ((currentStatus & TWI_MASTER_ARBLOST_bm) ||
    1806:	98 2f       	mov	r25, r24
    1808:	9c 70       	andi	r25, 0x0C	; 12
    180a:	c9 f4       	brne	.+50     	; 0x183e <__vector_46+0x6e>

		TWIMArbitrationLostBusErrorHandler();
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_MASTER_WIF_bm) {
    180c:	86 fd       	sbrc	r24, 6
    180e:	38 c0       	rjmp	.+112    	; 0x1880 <__vector_46+0xb0>
		TWIMWriteHandler();
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_MASTER_RIF_bm) {
    1810:	87 fd       	sbrc	r24, 7
    1812:	39 c0       	rjmp	.+114    	; 0x1886 <__vector_46+0xb6>
}

void TWIMTransactionFinished( uint8_t result)
{
	Twim_result = result;
	Twim_status = TWIM_STATUS_READY;
    1814:	10 92 11 28 	sts	0x2811, r1	; 0x802811 <Twim_status>
	/* If unexpected state. */
	else {
		TWIMTransactionFinished(TWIM_RESULT_FAIL);
	}
	
	if (Twim_status == TWIM_STATUS_READY) //Transaction finished
    1818:	80 91 11 28 	lds	r24, 0x2811	; 0x802811 <Twim_status>
    181c:	81 11       	cpse	r24, r1
    181e:	1a c0       	rjmp	.+52     	; 0x1854 <__vector_46+0x84>
	{
		BaseType_t res=xSemaphoreGiveFromISR( SemaRx, &xHigherPriorityTaskWoken );
    1820:	be 01       	movw	r22, r28
    1822:	6f 5f       	subi	r22, 0xFF	; 255
    1824:	7f 4f       	sbci	r23, 0xFF	; 255
    1826:	80 91 0d 28 	lds	r24, 0x280D	; 0x80280d <SemaRx>
    182a:	90 91 0e 28 	lds	r25, 0x280E	; 0x80280e <SemaRx+0x1>
    182e:	0e 94 9b 12 	call	0x2536	; 0x2536 <xQueueGiveFromISR>

		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );		
    1832:	89 81       	ldd	r24, Y+1	; 0x01
    1834:	88 23       	and	r24, r24
    1836:	71 f0       	breq	.+28     	; 0x1854 <__vector_46+0x84>
    1838:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <vPortYieldISR>
	}
}
    183c:	0b c0       	rjmp	.+22     	; 0x1854 <__vector_46+0x84>
	}
}

void TWIMArbitrationLostBusErrorHandler()
{
	uint8_t currentStatus = TWIM_BUS.MASTER.STATUS;
    183e:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>
	else {
		Twim_result = TWIM_RESULT_ARBITRATION_LOST;
	}

	/* Clear interrupt flag. */
	TWIM_BUS.MASTER.STATUS = currentStatus | TWI_MASTER_ARBLOST_bm;
    1842:	88 60       	ori	r24, 0x08	; 8
    1844:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>

	Twim_status = TWIM_STATUS_READY;
    1848:	10 92 11 28 	sts	0x2811, r1	; 0x802811 <Twim_status>
	/* If unexpected state. */
	else {
		TWIMTransactionFinished(TWIM_RESULT_FAIL);
	}
	
	if (Twim_status == TWIM_STATUS_READY) //Transaction finished
    184c:	80 91 11 28 	lds	r24, 0x2811	; 0x802811 <Twim_status>
    1850:	88 23       	and	r24, r24
    1852:	31 f3       	breq	.-52     	; 0x1820 <__vector_46+0x50>
	{
		BaseType_t res=xSemaphoreGiveFromISR( SemaRx, &xHigherPriorityTaskWoken );

		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );		
	}
}
    1854:	0f 90       	pop	r0
    1856:	df 91       	pop	r29
    1858:	cf 91       	pop	r28
    185a:	ff 91       	pop	r31
    185c:	ef 91       	pop	r30
    185e:	bf 91       	pop	r27
    1860:	af 91       	pop	r26
    1862:	9f 91       	pop	r25
    1864:	8f 91       	pop	r24
    1866:	7f 91       	pop	r23
    1868:	6f 91       	pop	r22
    186a:	5f 91       	pop	r21
    186c:	4f 91       	pop	r20
    186e:	3f 91       	pop	r19
    1870:	2f 91       	pop	r18
    1872:	0f 90       	pop	r0
    1874:	0b be       	out	0x3b, r0	; 59
    1876:	0f 90       	pop	r0
    1878:	0f be       	out	0x3f, r0	; 63
    187a:	0f 90       	pop	r0
    187c:	1f 90       	pop	r1
    187e:	18 95       	reti
		TWIMArbitrationLostBusErrorHandler();
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_MASTER_WIF_bm) {
		TWIMWriteHandler();
    1880:	0e 94 8c 0b 	call	0x1718	; 0x1718 <TWIMWriteHandler>
    1884:	e3 cf       	rjmp	.-58     	; 0x184c <__vector_46+0x7c>
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_MASTER_RIF_bm) {
		TWIMReadHandler();
    1886:	0e 94 b9 0b 	call	0x1772	; 0x1772 <TWIMReadHandler>
    188a:	e0 cf       	rjmp	.-64     	; 0x184c <__vector_46+0x7c>

0000188c <stdio_getchar>:
	return 0;
}
	
static int stdio_getchar(FILE *stream)
{
	while (!(USART.STATUS & 0b10000000));
    188c:	80 91 a1 0a 	lds	r24, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
    1890:	87 ff       	sbrs	r24, 7
    1892:	fc cf       	rjmp	.-8      	; 0x188c <stdio_getchar>
	return USART.DATA;
    1894:	80 91 a0 0a 	lds	r24, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
}
    1898:	90 e0       	ldi	r25, 0x00	; 0
    189a:	08 95       	ret

0000189c <stdio_putchar>:

}


static int stdio_putchar(char c, FILE * stream)
{
    189c:	cf 93       	push	r28
    189e:	df 93       	push	r29
    18a0:	1f 92       	push	r1
    18a2:	1f 92       	push	r1
    18a4:	cd b7       	in	r28, 0x3d	; 61
    18a6:	de b7       	in	r29, 0x3e	; 62
    18a8:	8a 83       	std	Y+2, r24	; 0x02
	int res;
	char cbuf;

	xQueueSend(UsartTxQueue,&c,portMAX_DELAY);
    18aa:	20 e0       	ldi	r18, 0x00	; 0
    18ac:	4f ef       	ldi	r20, 0xFF	; 255
    18ae:	5f ef       	ldi	r21, 0xFF	; 255
    18b0:	be 01       	movw	r22, r28
    18b2:	6e 5f       	subi	r22, 0xFE	; 254
    18b4:	7f 4f       	sbci	r23, 0xFF	; 255
    18b6:	80 91 a0 68 	lds	r24, 0x68A0	; 0x8068a0 <UsartTxQueue>
    18ba:	90 91 a1 68 	lds	r25, 0x68A1	; 0x8068a1 <UsartTxQueue+0x1>
    18be:	0e 94 71 11 	call	0x22e2	; 0x22e2 <xQueueGenericSend>

	if (USART.STATUS & (1<<5))
    18c2:	80 91 a1 0a 	lds	r24, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
    18c6:	85 ff       	sbrs	r24, 5
    18c8:	0e c0       	rjmp	.+28     	; 0x18e6 <stdio_putchar+0x4a>
	{
		xQueueReceive(UsartTxQueue,&cbuf,0);
    18ca:	40 e0       	ldi	r20, 0x00	; 0
    18cc:	50 e0       	ldi	r21, 0x00	; 0
    18ce:	be 01       	movw	r22, r28
    18d0:	6f 5f       	subi	r22, 0xFF	; 255
    18d2:	7f 4f       	sbci	r23, 0xFF	; 255
    18d4:	80 91 a0 68 	lds	r24, 0x68A0	; 0x8068a0 <UsartTxQueue>
    18d8:	90 91 a1 68 	lds	r25, 0x68A1	; 0x8068a1 <UsartTxQueue+0x1>
    18dc:	0e 94 ee 12 	call	0x25dc	; 0x25dc <xQueueReceive>
		USART.DATA=cbuf;
    18e0:	89 81       	ldd	r24, Y+1	; 0x01
    18e2:	80 93 a0 0a 	sts	0x0AA0, r24	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
	}
		
	return 0;
}
    18e6:	80 e0       	ldi	r24, 0x00	; 0
    18e8:	90 e0       	ldi	r25, 0x00	; 0
    18ea:	0f 90       	pop	r0
    18ec:	0f 90       	pop	r0
    18ee:	df 91       	pop	r29
    18f0:	cf 91       	pop	r28
    18f2:	08 95       	ret

000018f4 <USARTInit>:

QueueHandle_t UsartTxQueue;

void USARTInit(void)
{
	UsartTxQueue=xQueueCreate(10,sizeof(char));
    18f4:	40 e0       	ldi	r20, 0x00	; 0
    18f6:	61 e0       	ldi	r22, 0x01	; 1
    18f8:	8a e0       	ldi	r24, 0x0A	; 10
    18fa:	0e 94 2d 11 	call	0x225a	; 0x225a <xQueueGenericCreate>
    18fe:	80 93 a0 68 	sts	0x68A0, r24	; 0x8068a0 <UsartTxQueue>
    1902:	90 93 a1 68 	sts	0x68A1, r25	; 0x8068a1 <UsartTxQueue+0x1>
		
	USART_PORT.DIRSET=0b00001000;	
    1906:	e0 e8       	ldi	r30, 0x80	; 128
    1908:	f6 e0       	ldi	r31, 0x06	; 6
    190a:	88 e0       	ldi	r24, 0x08	; 8
    190c:	81 83       	std	Z+1, r24	; 0x01
	USART_PORT.DIRCLR=0b00000100;
    190e:	84 e0       	ldi	r24, 0x04	; 4
    1910:	82 83       	std	Z+2, r24	; 0x02
	
	USART.CTRLA=0b00010100;
    1912:	e0 ea       	ldi	r30, 0xA0	; 160
    1914:	fa e0       	ldi	r31, 0x0A	; 10
    1916:	84 e1       	ldi	r24, 0x14	; 20
    1918:	83 83       	std	Z+3, r24	; 0x03
	USART.CTRLB=0b00011000;
    191a:	88 e1       	ldi	r24, 0x18	; 24
    191c:	84 83       	std	Z+4, r24	; 0x04
	USART.CTRLC=0b00000011;
    191e:	83 e0       	ldi	r24, 0x03	; 3
    1920:	85 83       	std	Z+5, r24	; 0x05
	
	
	USART.BAUDCTRLA=0xE5; //BSEL=3301, BSCALE=-5 19200 baud
    1922:	85 ee       	ldi	r24, 0xE5	; 229
    1924:	86 83       	std	Z+6, r24	; 0x06
	USART.BAUDCTRLB=0xBC; 
    1926:	8c eb       	ldi	r24, 0xBC	; 188
    1928:	87 83       	std	Z+7, r24	; 0x07
	
	stdout=&UsartStdio;
    192a:	e2 eb       	ldi	r30, 0xB2	; 178
    192c:	f8 e6       	ldi	r31, 0x68	; 104
    192e:	80 e0       	ldi	r24, 0x00	; 0
    1930:	90 e2       	ldi	r25, 0x20	; 32
    1932:	82 83       	std	Z+2, r24	; 0x02
    1934:	93 83       	std	Z+3, r25	; 0x03
	stdin=&UsartStdio;
    1936:	80 83       	st	Z, r24
    1938:	91 83       	std	Z+1, r25	; 0x01
    193a:	08 95       	ret

0000193c <__vector_60>:
}



ISR(USART_TXC_vect)
{
    193c:	1f 92       	push	r1
    193e:	0f 92       	push	r0
    1940:	0f b6       	in	r0, 0x3f	; 63
    1942:	0f 92       	push	r0
    1944:	11 24       	eor	r1, r1
    1946:	0b b6       	in	r0, 0x3b	; 59
    1948:	0f 92       	push	r0
    194a:	2f 93       	push	r18
    194c:	3f 93       	push	r19
    194e:	4f 93       	push	r20
    1950:	5f 93       	push	r21
    1952:	6f 93       	push	r22
    1954:	7f 93       	push	r23
    1956:	8f 93       	push	r24
    1958:	9f 93       	push	r25
    195a:	af 93       	push	r26
    195c:	bf 93       	push	r27
    195e:	ef 93       	push	r30
    1960:	ff 93       	push	r31
    1962:	cf 93       	push	r28
    1964:	df 93       	push	r29
    1966:	1f 92       	push	r1
    1968:	1f 92       	push	r1
    196a:	cd b7       	in	r28, 0x3d	; 61
    196c:	de b7       	in	r29, 0x3e	; 62
	char c;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    196e:	19 82       	std	Y+1, r1	; 0x01
	if (xQueueReceiveFromISR(UsartTxQueue,&c,&xHigherPriorityTaskWoken)==pdPASS)
    1970:	ae 01       	movw	r20, r28
    1972:	4f 5f       	subi	r20, 0xFF	; 255
    1974:	5f 4f       	sbci	r21, 0xFF	; 255
    1976:	be 01       	movw	r22, r28
    1978:	6e 5f       	subi	r22, 0xFE	; 254
    197a:	7f 4f       	sbci	r23, 0xFF	; 255
    197c:	80 91 a0 68 	lds	r24, 0x68A0	; 0x8068a0 <UsartTxQueue>
    1980:	90 91 a1 68 	lds	r25, 0x68A1	; 0x8068a1 <UsartTxQueue+0x1>
    1984:	0e 94 14 15 	call	0x2a28	; 0x2a28 <xQueueReceiveFromISR>
    1988:	81 30       	cpi	r24, 0x01	; 1
    198a:	d1 f0       	breq	.+52     	; 0x19c0 <__vector_60+0x84>
	{
		USART.DATA=c;
		
	}
	
	if (xHigherPriorityTaskWoken==pdTRUE)
    198c:	89 81       	ldd	r24, Y+1	; 0x01
    198e:	81 30       	cpi	r24, 0x01	; 1
    1990:	e9 f0       	breq	.+58     	; 0x19cc <__vector_60+0x90>
	{
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
		//asm volatile ( "ret" );
	}
}
    1992:	0f 90       	pop	r0
    1994:	0f 90       	pop	r0
    1996:	df 91       	pop	r29
    1998:	cf 91       	pop	r28
    199a:	ff 91       	pop	r31
    199c:	ef 91       	pop	r30
    199e:	bf 91       	pop	r27
    19a0:	af 91       	pop	r26
    19a2:	9f 91       	pop	r25
    19a4:	8f 91       	pop	r24
    19a6:	7f 91       	pop	r23
    19a8:	6f 91       	pop	r22
    19aa:	5f 91       	pop	r21
    19ac:	4f 91       	pop	r20
    19ae:	3f 91       	pop	r19
    19b0:	2f 91       	pop	r18
    19b2:	0f 90       	pop	r0
    19b4:	0b be       	out	0x3b, r0	; 59
    19b6:	0f 90       	pop	r0
    19b8:	0f be       	out	0x3f, r0	; 63
    19ba:	0f 90       	pop	r0
    19bc:	1f 90       	pop	r1
    19be:	18 95       	reti
{
	char c;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
	if (xQueueReceiveFromISR(UsartTxQueue,&c,&xHigherPriorityTaskWoken)==pdPASS)
	{
		USART.DATA=c;
    19c0:	8a 81       	ldd	r24, Y+2	; 0x02
    19c2:	80 93 a0 0a 	sts	0x0AA0, r24	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
		
	}
	
	if (xHigherPriorityTaskWoken==pdTRUE)
    19c6:	89 81       	ldd	r24, Y+1	; 0x01
    19c8:	81 30       	cpi	r24, 0x01	; 1
    19ca:	19 f7       	brne	.-58     	; 0x1992 <__vector_60+0x56>
	{
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    19cc:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <vPortYieldISR>
		//asm volatile ( "ret" );
	}
}
    19d0:	e0 cf       	rjmp	.-64     	; 0x1992 <__vector_60+0x56>

000019d2 <__vector_58>:

ISR(USART_RXC_vect)
{
    19d2:	1f 92       	push	r1
    19d4:	0f 92       	push	r0
    19d6:	0f b6       	in	r0, 0x3f	; 63
    19d8:	0f 92       	push	r0
    19da:	11 24       	eor	r1, r1
    19dc:	8f 93       	push	r24
	char c;
	c=USART.DATA;
    19de:	80 91 a0 0a 	lds	r24, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
	
    19e2:	8f 91       	pop	r24
    19e4:	0f 90       	pop	r0
    19e6:	0f be       	out	0x3f, r0	; 63
    19e8:	0f 90       	pop	r0
    19ea:	1f 90       	pop	r1
    19ec:	18 95       	reti

000019ee <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    19ee:	0f 93       	push	r16
    19f0:	1f 93       	push	r17
    19f2:	cf 93       	push	r28
    19f4:	df 93       	push	r29
    19f6:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    19f8:	0e 94 6f 18 	call	0x30de	; 0x30de <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    19fc:	80 91 1b 28 	lds	r24, 0x281B	; 0x80281b <xHeapHasBeenInitialised.4116>
    1a00:	81 11       	cpse	r24, r1
    1a02:	21 c0       	rjmp	.+66     	; 0x1a46 <pvPortMalloc+0x58>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    1a04:	85 e2       	ldi	r24, 0x25	; 37
    1a06:	98 e2       	ldi	r25, 0x28	; 40
    1a08:	80 93 20 28 	sts	0x2820, r24	; 0x802820 <xStart>
    1a0c:	90 93 21 28 	sts	0x2821, r25	; 0x802821 <xStart+0x1>
	xStart.xBlockSize = ( size_t ) 0;
    1a10:	10 92 22 28 	sts	0x2822, r1	; 0x802822 <xStart+0x2>
    1a14:	10 92 23 28 	sts	0x2823, r1	; 0x802823 <xStart+0x3>

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    1a18:	8f ef       	ldi	r24, 0xFF	; 255
    1a1a:	9f e3       	ldi	r25, 0x3F	; 63
    1a1c:	80 93 1e 28 	sts	0x281E, r24	; 0x80281e <xEnd+0x2>
    1a20:	90 93 1f 28 	sts	0x281F, r25	; 0x80281f <xEnd+0x3>
	xEnd.pxNextFreeBlock = NULL;
    1a24:	10 92 1c 28 	sts	0x281C, r1	; 0x80281c <xEnd>
    1a28:	10 92 1d 28 	sts	0x281D, r1	; 0x80281d <xEnd+0x1>

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    1a2c:	80 93 27 28 	sts	0x2827, r24	; 0x802827 <ucHeap+0x3>
    1a30:	90 93 28 28 	sts	0x2828, r25	; 0x802828 <ucHeap+0x4>
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    1a34:	8c e1       	ldi	r24, 0x1C	; 28
    1a36:	98 e2       	ldi	r25, 0x28	; 40
    1a38:	80 93 25 28 	sts	0x2825, r24	; 0x802825 <ucHeap+0x1>
    1a3c:	90 93 26 28 	sts	0x2826, r25	; 0x802826 <ucHeap+0x2>
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
    1a40:	81 e0       	ldi	r24, 0x01	; 1
    1a42:	80 93 1b 28 	sts	0x281B, r24	; 0x80281b <xHeapHasBeenInitialised.4116>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1a46:	20 97       	sbiw	r28, 0x00	; 0
    1a48:	09 f4       	brne	.+2      	; 0x1a4c <pvPortMalloc+0x5e>
    1a4a:	64 c0       	rjmp	.+200    	; 0x1b14 <pvPortMalloc+0x126>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1a4c:	ae 01       	movw	r20, r28
    1a4e:	4c 5f       	subi	r20, 0xFC	; 252
    1a50:	5f 4f       	sbci	r21, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
    1a52:	23 96       	adiw	r28, 0x03	; 3
    1a54:	ce 3f       	cpi	r28, 0xFE	; 254
    1a56:	df 43       	sbci	r29, 0x3F	; 63
    1a58:	08 f0       	brcs	.+2      	; 0x1a5c <pvPortMalloc+0x6e>
    1a5a:	5c c0       	rjmp	.+184    	; 0x1b14 <pvPortMalloc+0x126>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1a5c:	e0 91 20 28 	lds	r30, 0x2820	; 0x802820 <xStart>
    1a60:	f0 91 21 28 	lds	r31, 0x2821	; 0x802821 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1a64:	a0 e2       	ldi	r26, 0x20	; 32
    1a66:	b8 e2       	ldi	r27, 0x28	; 40
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    1a68:	06 c0       	rjmp	.+12     	; 0x1a76 <pvPortMalloc+0x88>
    1a6a:	80 81       	ld	r24, Z
    1a6c:	91 81       	ldd	r25, Z+1	; 0x01
    1a6e:	00 97       	sbiw	r24, 0x00	; 0
    1a70:	39 f0       	breq	.+14     	; 0x1a80 <pvPortMalloc+0x92>
    1a72:	df 01       	movw	r26, r30
    1a74:	fc 01       	movw	r30, r24
    1a76:	22 81       	ldd	r18, Z+2	; 0x02
    1a78:	33 81       	ldd	r19, Z+3	; 0x03
    1a7a:	24 17       	cp	r18, r20
    1a7c:	35 07       	cpc	r19, r21
    1a7e:	a8 f3       	brcs	.-22     	; 0x1a6a <pvPortMalloc+0x7c>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1a80:	c8 e2       	ldi	r28, 0x28	; 40
    1a82:	ec 31       	cpi	r30, 0x1C	; 28
    1a84:	fc 07       	cpc	r31, r28
    1a86:	09 f4       	brne	.+2      	; 0x1a8a <pvPortMalloc+0x9c>
    1a88:	45 c0       	rjmp	.+138    	; 0x1b14 <pvPortMalloc+0x126>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1a8a:	cd 91       	ld	r28, X+
    1a8c:	dc 91       	ld	r29, X
    1a8e:	11 97       	sbiw	r26, 0x01	; 1
    1a90:	8e 01       	movw	r16, r28
    1a92:	0c 5f       	subi	r16, 0xFC	; 252
    1a94:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1a96:	80 81       	ld	r24, Z
    1a98:	91 81       	ldd	r25, Z+1	; 0x01
    1a9a:	8d 93       	st	X+, r24
    1a9c:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1a9e:	c9 01       	movw	r24, r18
    1aa0:	84 1b       	sub	r24, r20
    1aa2:	95 0b       	sbc	r25, r21
    1aa4:	89 30       	cpi	r24, 0x09	; 9
    1aa6:	91 05       	cpc	r25, r1
    1aa8:	00 f1       	brcs	.+64     	; 0x1aea <pvPortMalloc+0xfc>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    1aaa:	bf 01       	movw	r22, r30
    1aac:	64 0f       	add	r22, r20
    1aae:	75 1f       	adc	r23, r21

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1ab0:	db 01       	movw	r26, r22
    1ab2:	12 96       	adiw	r26, 0x02	; 2
    1ab4:	8d 93       	st	X+, r24
    1ab6:	9c 93       	st	X, r25
    1ab8:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1aba:	42 83       	std	Z+2, r20	; 0x02
    1abc:	53 83       	std	Z+3, r21	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1abe:	12 96       	adiw	r26, 0x02	; 2
    1ac0:	2d 91       	ld	r18, X+
    1ac2:	3c 91       	ld	r19, X
    1ac4:	13 97       	sbiw	r26, 0x03	; 3
    1ac6:	a0 e2       	ldi	r26, 0x20	; 32
    1ac8:	b8 e2       	ldi	r27, 0x28	; 40
    1aca:	01 c0       	rjmp	.+2      	; 0x1ace <pvPortMalloc+0xe0>
    1acc:	df 01       	movw	r26, r30
    1ace:	ed 91       	ld	r30, X+
    1ad0:	fc 91       	ld	r31, X
    1ad2:	11 97       	sbiw	r26, 0x01	; 1
    1ad4:	82 81       	ldd	r24, Z+2	; 0x02
    1ad6:	93 81       	ldd	r25, Z+3	; 0x03
    1ad8:	82 17       	cp	r24, r18
    1ada:	93 07       	cpc	r25, r19
    1adc:	b8 f3       	brcs	.-18     	; 0x1acc <pvPortMalloc+0xde>
    1ade:	eb 01       	movw	r28, r22
    1ae0:	e8 83       	st	Y, r30
    1ae2:	f9 83       	std	Y+1, r31	; 0x01
    1ae4:	6d 93       	st	X+, r22
    1ae6:	7c 93       	st	X, r23

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
		{
			xWantedSize += heapSTRUCT_SIZE;
    1ae8:	9a 01       	movw	r18, r20

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1aea:	80 91 0e 20 	lds	r24, 0x200E	; 0x80200e <xFreeBytesRemaining>
    1aee:	90 91 0f 20 	lds	r25, 0x200F	; 0x80200f <xFreeBytesRemaining+0x1>
    1af2:	82 1b       	sub	r24, r18
    1af4:	93 0b       	sbc	r25, r19
    1af6:	80 93 0e 20 	sts	0x200E, r24	; 0x80200e <xFreeBytesRemaining>
    1afa:	90 93 0f 20 	sts	0x200F, r25	; 0x80200f <xFreeBytesRemaining+0x1>
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1afe:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
    1b02:	01 15       	cp	r16, r1
    1b04:	11 05       	cpc	r17, r1
    1b06:	41 f0       	breq	.+16     	; 0x1b18 <pvPortMalloc+0x12a>
		}
	}
	#endif

	return pvReturn;
}
    1b08:	c8 01       	movw	r24, r16
    1b0a:	df 91       	pop	r29
    1b0c:	cf 91       	pop	r28
    1b0e:	1f 91       	pop	r17
    1b10:	0f 91       	pop	r16
    1b12:	08 95       	ret
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1b14:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>
	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
    1b18:	0e 94 f1 1c 	call	0x39e2	; 0x39e2 <vApplicationMallocFailedHook>
    1b1c:	00 e0       	ldi	r16, 0x00	; 0
    1b1e:	10 e0       	ldi	r17, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
}
    1b20:	c8 01       	movw	r24, r16
    1b22:	df 91       	pop	r29
    1b24:	cf 91       	pop	r28
    1b26:	1f 91       	pop	r17
    1b28:	0f 91       	pop	r16
    1b2a:	08 95       	ret

00001b2c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1b2c:	cf 93       	push	r28
    1b2e:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    1b30:	00 97       	sbiw	r24, 0x00	; 0
    1b32:	21 f1       	breq	.+72     	; 0x1b7c <vPortFree+0x50>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1b34:	ec 01       	movw	r28, r24
    1b36:	24 97       	sbiw	r28, 0x04	; 4

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1b38:	0e 94 6f 18 	call	0x30de	; 0x30de <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    1b3c:	4a 81       	ldd	r20, Y+2	; 0x02
    1b3e:	5b 81       	ldd	r21, Y+3	; 0x03
    1b40:	a0 e2       	ldi	r26, 0x20	; 32
    1b42:	b8 e2       	ldi	r27, 0x28	; 40
    1b44:	01 c0       	rjmp	.+2      	; 0x1b48 <vPortFree+0x1c>
    1b46:	df 01       	movw	r26, r30
    1b48:	ed 91       	ld	r30, X+
    1b4a:	fc 91       	ld	r31, X
    1b4c:	11 97       	sbiw	r26, 0x01	; 1
    1b4e:	22 81       	ldd	r18, Z+2	; 0x02
    1b50:	33 81       	ldd	r19, Z+3	; 0x03
    1b52:	24 17       	cp	r18, r20
    1b54:	35 07       	cpc	r19, r21
    1b56:	b8 f3       	brcs	.-18     	; 0x1b46 <vPortFree+0x1a>
    1b58:	e8 83       	st	Y, r30
    1b5a:	f9 83       	std	Y+1, r31	; 0x01
    1b5c:	cd 93       	st	X+, r28
    1b5e:	dc 93       	st	X, r29
			xFreeBytesRemaining += pxLink->xBlockSize;
    1b60:	80 91 0e 20 	lds	r24, 0x200E	; 0x80200e <xFreeBytesRemaining>
    1b64:	90 91 0f 20 	lds	r25, 0x200F	; 0x80200f <xFreeBytesRemaining+0x1>
    1b68:	48 0f       	add	r20, r24
    1b6a:	59 1f       	adc	r21, r25
    1b6c:	40 93 0e 20 	sts	0x200E, r20	; 0x80200e <xFreeBytesRemaining>
    1b70:	50 93 0f 20 	sts	0x200F, r21	; 0x80200f <xFreeBytesRemaining+0x1>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
	}
}
    1b74:	df 91       	pop	r29
    1b76:	cf 91       	pop	r28
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
			xFreeBytesRemaining += pxLink->xBlockSize;
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
    1b78:	0c 94 6b 19 	jmp	0x32d6	; 0x32d6 <xTaskResumeAll>
	}
}
    1b7c:	df 91       	pop	r29
    1b7e:	cf 91       	pop	r28
    1b80:	08 95       	ret

00001b82 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1b82:	80 91 0e 20 	lds	r24, 0x200E	; 0x80200e <xFreeBytesRemaining>
    1b86:	90 91 0f 20 	lds	r25, 0x200F	; 0x80200f <xFreeBytesRemaining+0x1>
    1b8a:	08 95       	ret

00001b8c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1b8c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b8e:	03 96       	adiw	r24, 0x03	; 3
    1b90:	81 83       	std	Z+1, r24	; 0x01
    1b92:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1b94:	2f ef       	ldi	r18, 0xFF	; 255
    1b96:	3f ef       	ldi	r19, 0xFF	; 255
    1b98:	23 83       	std	Z+3, r18	; 0x03
    1b9a:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b9c:	85 83       	std	Z+5, r24	; 0x05
    1b9e:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1ba0:	87 83       	std	Z+7, r24	; 0x07
    1ba2:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1ba4:	10 82       	st	Z, r1
    1ba6:	08 95       	ret

00001ba8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1ba8:	fc 01       	movw	r30, r24
    1baa:	10 86       	std	Z+8, r1	; 0x08
    1bac:	11 86       	std	Z+9, r1	; 0x09
    1bae:	08 95       	ret

00001bb0 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1bb0:	cf 93       	push	r28
    1bb2:	df 93       	push	r29
    1bb4:	9c 01       	movw	r18, r24
    1bb6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1bb8:	dc 01       	movw	r26, r24
    1bba:	11 96       	adiw	r26, 0x01	; 1
    1bbc:	cd 91       	ld	r28, X+
    1bbe:	dc 91       	ld	r29, X
    1bc0:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1bc2:	c2 83       	std	Z+2, r28	; 0x02
    1bc4:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1bc6:	8c 81       	ldd	r24, Y+4	; 0x04
    1bc8:	9d 81       	ldd	r25, Y+5	; 0x05
    1bca:	84 83       	std	Z+4, r24	; 0x04
    1bcc:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1bce:	8c 81       	ldd	r24, Y+4	; 0x04
    1bd0:	9d 81       	ldd	r25, Y+5	; 0x05
    1bd2:	dc 01       	movw	r26, r24
    1bd4:	12 96       	adiw	r26, 0x02	; 2
    1bd6:	6d 93       	st	X+, r22
    1bd8:	7c 93       	st	X, r23
    1bda:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    1bdc:	6c 83       	std	Y+4, r22	; 0x04
    1bde:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1be0:	20 87       	std	Z+8, r18	; 0x08
    1be2:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    1be4:	f9 01       	movw	r30, r18
    1be6:	80 81       	ld	r24, Z
    1be8:	8f 5f       	subi	r24, 0xFF	; 255
    1bea:	80 83       	st	Z, r24
}
    1bec:	df 91       	pop	r29
    1bee:	cf 91       	pop	r28
    1bf0:	08 95       	ret

00001bf2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1bf2:	cf 93       	push	r28
    1bf4:	df 93       	push	r29
    1bf6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1bf8:	48 81       	ld	r20, Y
    1bfa:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1bfc:	4f 3f       	cpi	r20, 0xFF	; 255
    1bfe:	2f ef       	ldi	r18, 0xFF	; 255
    1c00:	52 07       	cpc	r21, r18
    1c02:	01 f1       	breq	.+64     	; 0x1c44 <vListInsert+0x52>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1c04:	dc 01       	movw	r26, r24
    1c06:	13 96       	adiw	r26, 0x03	; 3
    1c08:	01 c0       	rjmp	.+2      	; 0x1c0c <vListInsert+0x1a>
    1c0a:	df 01       	movw	r26, r30
    1c0c:	12 96       	adiw	r26, 0x02	; 2
    1c0e:	ed 91       	ld	r30, X+
    1c10:	fc 91       	ld	r31, X
    1c12:	13 97       	sbiw	r26, 0x03	; 3
    1c14:	20 81       	ld	r18, Z
    1c16:	31 81       	ldd	r19, Z+1	; 0x01
    1c18:	42 17       	cp	r20, r18
    1c1a:	53 07       	cpc	r21, r19
    1c1c:	b0 f7       	brcc	.-20     	; 0x1c0a <vListInsert+0x18>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c1e:	ea 83       	std	Y+2, r30	; 0x02
    1c20:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c22:	c4 83       	std	Z+4, r28	; 0x04
    1c24:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    1c26:	ac 83       	std	Y+4, r26	; 0x04
    1c28:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    1c2a:	12 96       	adiw	r26, 0x02	; 2
    1c2c:	cd 93       	st	X+, r28
    1c2e:	dc 93       	st	X, r29
    1c30:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1c32:	88 87       	std	Y+8, r24	; 0x08
    1c34:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    1c36:	fc 01       	movw	r30, r24
    1c38:	20 81       	ld	r18, Z
    1c3a:	2f 5f       	subi	r18, 0xFF	; 255
    1c3c:	20 83       	st	Z, r18
}
    1c3e:	df 91       	pop	r29
    1c40:	cf 91       	pop	r28
    1c42:	08 95       	ret
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c44:	fc 01       	movw	r30, r24
    1c46:	a7 81       	ldd	r26, Z+7	; 0x07
    1c48:	b0 85       	ldd	r27, Z+8	; 0x08
    1c4a:	12 96       	adiw	r26, 0x02	; 2
    1c4c:	ed 91       	ld	r30, X+
    1c4e:	fc 91       	ld	r31, X
    1c50:	13 97       	sbiw	r26, 0x03	; 3
    1c52:	e5 cf       	rjmp	.-54     	; 0x1c1e <vListInsert+0x2c>

00001c54 <uxListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1c54:	cf 93       	push	r28
    1c56:	df 93       	push	r29
    1c58:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1c5a:	a0 85       	ldd	r26, Z+8	; 0x08
    1c5c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1c5e:	22 81       	ldd	r18, Z+2	; 0x02
    1c60:	33 81       	ldd	r19, Z+3	; 0x03
    1c62:	84 81       	ldd	r24, Z+4	; 0x04
    1c64:	95 81       	ldd	r25, Z+5	; 0x05
    1c66:	e9 01       	movw	r28, r18
    1c68:	8c 83       	std	Y+4, r24	; 0x04
    1c6a:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1c6c:	84 81       	ldd	r24, Z+4	; 0x04
    1c6e:	95 81       	ldd	r25, Z+5	; 0x05
    1c70:	ec 01       	movw	r28, r24
    1c72:	2a 83       	std	Y+2, r18	; 0x02
    1c74:	3b 83       	std	Y+3, r19	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1c76:	11 96       	adiw	r26, 0x01	; 1
    1c78:	2d 91       	ld	r18, X+
    1c7a:	3c 91       	ld	r19, X
    1c7c:	12 97       	sbiw	r26, 0x02	; 2
    1c7e:	e2 17       	cp	r30, r18
    1c80:	f3 07       	cpc	r31, r19
    1c82:	49 f0       	breq	.+18     	; 0x1c96 <uxListRemove+0x42>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1c84:	10 86       	std	Z+8, r1	; 0x08
    1c86:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    1c88:	8c 91       	ld	r24, X
    1c8a:	81 50       	subi	r24, 0x01	; 1
    1c8c:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1c8e:	8c 91       	ld	r24, X
}
    1c90:	df 91       	pop	r29
    1c92:	cf 91       	pop	r28
    1c94:	08 95       	ret
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1c96:	11 96       	adiw	r26, 0x01	; 1
    1c98:	8d 93       	st	X+, r24
    1c9a:	9c 93       	st	X, r25
    1c9c:	12 97       	sbiw	r26, 0x02	; 2
    1c9e:	f2 cf       	rjmp	.-28     	; 0x1c84 <uxListRemove+0x30>

00001ca0 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1ca0:	31 e1       	ldi	r19, 0x11	; 17
    1ca2:	fc 01       	movw	r30, r24
    1ca4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1ca6:	31 97       	sbiw	r30, 0x01	; 1
    1ca8:	22 e2       	ldi	r18, 0x22	; 34
    1caa:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    1cac:	31 97       	sbiw	r30, 0x01	; 1
    1cae:	a3 e3       	ldi	r26, 0x33	; 51
    1cb0:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint32_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1cb2:	31 97       	sbiw	r30, 0x01	; 1
    1cb4:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1cb6:	31 97       	sbiw	r30, 0x01	; 1
    1cb8:	70 83       	st	Z, r23
	pxTopOfStack--;

#if defined(__AVR_3_BYTE_PC__) && __AVR_3_BYTE_PC__   //MCU's with more than 128kB of program memory: PC is 3 bytes
	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1cba:	31 97       	sbiw	r30, 0x01	; 1
    1cbc:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1cbe:	31 97       	sbiw	r30, 0x01	; 1
    1cc0:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1cc2:	31 97       	sbiw	r30, 0x01	; 1
    1cc4:	60 e8       	ldi	r22, 0x80	; 128
    1cc6:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1cc8:	31 97       	sbiw	r30, 0x01	; 1
    1cca:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1ccc:	31 97       	sbiw	r30, 0x01	; 1
    1cce:	62 e0       	ldi	r22, 0x02	; 2
    1cd0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1cd2:	31 97       	sbiw	r30, 0x01	; 1
    1cd4:	63 e0       	ldi	r22, 0x03	; 3
    1cd6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1cd8:	31 97       	sbiw	r30, 0x01	; 1
    1cda:	64 e0       	ldi	r22, 0x04	; 4
    1cdc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1cde:	31 97       	sbiw	r30, 0x01	; 1
    1ce0:	65 e0       	ldi	r22, 0x05	; 5
    1ce2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1ce4:	31 97       	sbiw	r30, 0x01	; 1
    1ce6:	66 e0       	ldi	r22, 0x06	; 6
    1ce8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1cea:	31 97       	sbiw	r30, 0x01	; 1
    1cec:	67 e0       	ldi	r22, 0x07	; 7
    1cee:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1cf0:	31 97       	sbiw	r30, 0x01	; 1
    1cf2:	68 e0       	ldi	r22, 0x08	; 8
    1cf4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1cf6:	31 97       	sbiw	r30, 0x01	; 1
    1cf8:	69 e0       	ldi	r22, 0x09	; 9
    1cfa:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1cfc:	31 97       	sbiw	r30, 0x01	; 1
    1cfe:	60 e1       	ldi	r22, 0x10	; 16
    1d00:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1d02:	31 97       	sbiw	r30, 0x01	; 1
    1d04:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1d06:	31 97       	sbiw	r30, 0x01	; 1
    1d08:	32 e1       	ldi	r19, 0x12	; 18
    1d0a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1d0c:	31 97       	sbiw	r30, 0x01	; 1
    1d0e:	33 e1       	ldi	r19, 0x13	; 19
    1d10:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1d12:	31 97       	sbiw	r30, 0x01	; 1
    1d14:	34 e1       	ldi	r19, 0x14	; 20
    1d16:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1d18:	31 97       	sbiw	r30, 0x01	; 1
    1d1a:	35 e1       	ldi	r19, 0x15	; 21
    1d1c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1d1e:	31 97       	sbiw	r30, 0x01	; 1
    1d20:	36 e1       	ldi	r19, 0x16	; 22
    1d22:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1d24:	31 97       	sbiw	r30, 0x01	; 1
    1d26:	37 e1       	ldi	r19, 0x17	; 23
    1d28:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1d2a:	31 97       	sbiw	r30, 0x01	; 1
    1d2c:	38 e1       	ldi	r19, 0x18	; 24
    1d2e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1d30:	31 97       	sbiw	r30, 0x01	; 1
    1d32:	39 e1       	ldi	r19, 0x19	; 25
    1d34:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1d36:	31 97       	sbiw	r30, 0x01	; 1
    1d38:	30 e2       	ldi	r19, 0x20	; 32
    1d3a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1d3c:	31 97       	sbiw	r30, 0x01	; 1
    1d3e:	31 e2       	ldi	r19, 0x21	; 33
    1d40:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1d42:	31 97       	sbiw	r30, 0x01	; 1
    1d44:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1d46:	31 97       	sbiw	r30, 0x01	; 1
    1d48:	23 e2       	ldi	r18, 0x23	; 35
    1d4a:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1d4c:	31 97       	sbiw	r30, 0x01	; 1
    1d4e:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1d50:	31 97       	sbiw	r30, 0x01	; 1
    1d52:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1d54:	31 97       	sbiw	r30, 0x01	; 1
    1d56:	26 e2       	ldi	r18, 0x26	; 38
    1d58:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1d5a:	31 97       	sbiw	r30, 0x01	; 1
    1d5c:	27 e2       	ldi	r18, 0x27	; 39
    1d5e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1d60:	31 97       	sbiw	r30, 0x01	; 1
    1d62:	28 e2       	ldi	r18, 0x28	; 40
    1d64:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1d66:	31 97       	sbiw	r30, 0x01	; 1
    1d68:	29 e2       	ldi	r18, 0x29	; 41
    1d6a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1d6c:	31 97       	sbiw	r30, 0x01	; 1
    1d6e:	20 e3       	ldi	r18, 0x30	; 48
    1d70:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1d72:	31 97       	sbiw	r30, 0x01	; 1
    1d74:	21 e3       	ldi	r18, 0x31	; 49
    1d76:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    1d78:	87 97       	sbiw	r24, 0x27	; 39
    1d7a:	08 95       	ret

00001d7c <xPortStartScheduler>:
 */

static void prvSetupTimerInterrupt( void )
{
	//TCC0 is used as tick timer
	TCC0.CTRLA=0b00000001; //DIV1
    1d7c:	e0 e0       	ldi	r30, 0x00	; 0
    1d7e:	f8 e0       	ldi	r31, 0x08	; 8
    1d80:	81 e0       	ldi	r24, 0x01	; 1
    1d82:	80 83       	st	Z, r24
	TCC0.INTCTRLA=0b00000001; //OVF priority LOW
    1d84:	86 83       	std	Z+6, r24	; 0x06
	TCC0.PER=configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1d86:	80 e0       	ldi	r24, 0x00	; 0
    1d88:	9d e7       	ldi	r25, 0x7D	; 125
    1d8a:	86 a3       	std	Z+38, r24	; 0x26
    1d8c:	97 a3       	std	Z+39, r25	; 0x27
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1d8e:	a0 91 8c 68 	lds	r26, 0x688C	; 0x80688c <pxCurrentTCB>
    1d92:	b0 91 8d 68 	lds	r27, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    1d96:	cd 91       	ld	r28, X+
    1d98:	cd bf       	out	0x3d, r28	; 61
    1d9a:	dd 91       	ld	r29, X+
    1d9c:	de bf       	out	0x3e, r29	; 62
    1d9e:	ff 91       	pop	r31
    1da0:	ef 91       	pop	r30
    1da2:	df 91       	pop	r29
    1da4:	cf 91       	pop	r28
    1da6:	bf 91       	pop	r27
    1da8:	af 91       	pop	r26
    1daa:	9f 91       	pop	r25
    1dac:	8f 91       	pop	r24
    1dae:	7f 91       	pop	r23
    1db0:	6f 91       	pop	r22
    1db2:	5f 91       	pop	r21
    1db4:	4f 91       	pop	r20
    1db6:	3f 91       	pop	r19
    1db8:	2f 91       	pop	r18
    1dba:	1f 91       	pop	r17
    1dbc:	0f 91       	pop	r16
    1dbe:	ff 90       	pop	r15
    1dc0:	ef 90       	pop	r14
    1dc2:	df 90       	pop	r13
    1dc4:	cf 90       	pop	r12
    1dc6:	bf 90       	pop	r11
    1dc8:	af 90       	pop	r10
    1dca:	9f 90       	pop	r9
    1dcc:	8f 90       	pop	r8
    1dce:	7f 90       	pop	r7
    1dd0:	6f 90       	pop	r6
    1dd2:	5f 90       	pop	r5
    1dd4:	4f 90       	pop	r4
    1dd6:	3f 90       	pop	r3
    1dd8:	2f 90       	pop	r2
    1dda:	1f 90       	pop	r1
    1ddc:	0f 90       	pop	r0
    1dde:	0f be       	out	0x3f, r0	; 63
    1de0:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1de2:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1de4:	81 e0       	ldi	r24, 0x01	; 1
    1de6:	08 95       	ret

00001de8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1de8:	0f 92       	push	r0
    1dea:	0f b6       	in	r0, 0x3f	; 63
    1dec:	f8 94       	cli
    1dee:	0f 92       	push	r0
    1df0:	1f 92       	push	r1
    1df2:	11 24       	eor	r1, r1
    1df4:	2f 92       	push	r2
    1df6:	3f 92       	push	r3
    1df8:	4f 92       	push	r4
    1dfa:	5f 92       	push	r5
    1dfc:	6f 92       	push	r6
    1dfe:	7f 92       	push	r7
    1e00:	8f 92       	push	r8
    1e02:	9f 92       	push	r9
    1e04:	af 92       	push	r10
    1e06:	bf 92       	push	r11
    1e08:	cf 92       	push	r12
    1e0a:	df 92       	push	r13
    1e0c:	ef 92       	push	r14
    1e0e:	ff 92       	push	r15
    1e10:	0f 93       	push	r16
    1e12:	1f 93       	push	r17
    1e14:	2f 93       	push	r18
    1e16:	3f 93       	push	r19
    1e18:	4f 93       	push	r20
    1e1a:	5f 93       	push	r21
    1e1c:	6f 93       	push	r22
    1e1e:	7f 93       	push	r23
    1e20:	8f 93       	push	r24
    1e22:	9f 93       	push	r25
    1e24:	af 93       	push	r26
    1e26:	bf 93       	push	r27
    1e28:	cf 93       	push	r28
    1e2a:	df 93       	push	r29
    1e2c:	ef 93       	push	r30
    1e2e:	ff 93       	push	r31
    1e30:	a0 91 8c 68 	lds	r26, 0x688C	; 0x80688c <pxCurrentTCB>
    1e34:	b0 91 8d 68 	lds	r27, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    1e38:	0d b6       	in	r0, 0x3d	; 61
    1e3a:	0d 92       	st	X+, r0
    1e3c:	0e b6       	in	r0, 0x3e	; 62
    1e3e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1e40:	0e 94 75 1a 	call	0x34ea	; 0x34ea <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1e44:	a0 91 8c 68 	lds	r26, 0x688C	; 0x80688c <pxCurrentTCB>
    1e48:	b0 91 8d 68 	lds	r27, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    1e4c:	cd 91       	ld	r28, X+
    1e4e:	cd bf       	out	0x3d, r28	; 61
    1e50:	dd 91       	ld	r29, X+
    1e52:	de bf       	out	0x3e, r29	; 62
    1e54:	ff 91       	pop	r31
    1e56:	ef 91       	pop	r30
    1e58:	df 91       	pop	r29
    1e5a:	cf 91       	pop	r28
    1e5c:	bf 91       	pop	r27
    1e5e:	af 91       	pop	r26
    1e60:	9f 91       	pop	r25
    1e62:	8f 91       	pop	r24
    1e64:	7f 91       	pop	r23
    1e66:	6f 91       	pop	r22
    1e68:	5f 91       	pop	r21
    1e6a:	4f 91       	pop	r20
    1e6c:	3f 91       	pop	r19
    1e6e:	2f 91       	pop	r18
    1e70:	1f 91       	pop	r17
    1e72:	0f 91       	pop	r16
    1e74:	ff 90       	pop	r15
    1e76:	ef 90       	pop	r14
    1e78:	df 90       	pop	r13
    1e7a:	cf 90       	pop	r12
    1e7c:	bf 90       	pop	r11
    1e7e:	af 90       	pop	r10
    1e80:	9f 90       	pop	r9
    1e82:	8f 90       	pop	r8
    1e84:	7f 90       	pop	r7
    1e86:	6f 90       	pop	r6
    1e88:	5f 90       	pop	r5
    1e8a:	4f 90       	pop	r4
    1e8c:	3f 90       	pop	r3
    1e8e:	2f 90       	pop	r2
    1e90:	1f 90       	pop	r1
    1e92:	0f 90       	pop	r0
    1e94:	0f be       	out	0x3f, r0	; 63
    1e96:	0f 90       	pop	r0
	asm volatile ( "ret" );
    1e98:	08 95       	ret

00001e9a <vPortYieldISR>:
}

void vPortYieldISR( void ) __attribute__ ( ( naked ) );
void vPortYieldISR( void )
{
	portSAVE_CONTEXT();
    1e9a:	0f 92       	push	r0
    1e9c:	0f b6       	in	r0, 0x3f	; 63
    1e9e:	f8 94       	cli
    1ea0:	0f 92       	push	r0
    1ea2:	1f 92       	push	r1
    1ea4:	11 24       	eor	r1, r1
    1ea6:	2f 92       	push	r2
    1ea8:	3f 92       	push	r3
    1eaa:	4f 92       	push	r4
    1eac:	5f 92       	push	r5
    1eae:	6f 92       	push	r6
    1eb0:	7f 92       	push	r7
    1eb2:	8f 92       	push	r8
    1eb4:	9f 92       	push	r9
    1eb6:	af 92       	push	r10
    1eb8:	bf 92       	push	r11
    1eba:	cf 92       	push	r12
    1ebc:	df 92       	push	r13
    1ebe:	ef 92       	push	r14
    1ec0:	ff 92       	push	r15
    1ec2:	0f 93       	push	r16
    1ec4:	1f 93       	push	r17
    1ec6:	2f 93       	push	r18
    1ec8:	3f 93       	push	r19
    1eca:	4f 93       	push	r20
    1ecc:	5f 93       	push	r21
    1ece:	6f 93       	push	r22
    1ed0:	7f 93       	push	r23
    1ed2:	8f 93       	push	r24
    1ed4:	9f 93       	push	r25
    1ed6:	af 93       	push	r26
    1ed8:	bf 93       	push	r27
    1eda:	cf 93       	push	r28
    1edc:	df 93       	push	r29
    1ede:	ef 93       	push	r30
    1ee0:	ff 93       	push	r31
    1ee2:	a0 91 8c 68 	lds	r26, 0x688C	; 0x80688c <pxCurrentTCB>
    1ee6:	b0 91 8d 68 	lds	r27, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    1eea:	0d b6       	in	r0, 0x3d	; 61
    1eec:	0d 92       	st	X+, r0
    1eee:	0e b6       	in	r0, 0x3e	; 62
    1ef0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1ef2:	0e 94 75 1a 	call	0x34ea	; 0x34ea <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1ef6:	a0 91 8c 68 	lds	r26, 0x688C	; 0x80688c <pxCurrentTCB>
    1efa:	b0 91 8d 68 	lds	r27, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    1efe:	cd 91       	ld	r28, X+
    1f00:	cd bf       	out	0x3d, r28	; 61
    1f02:	dd 91       	ld	r29, X+
    1f04:	de bf       	out	0x3e, r29	; 62
    1f06:	ff 91       	pop	r31
    1f08:	ef 91       	pop	r30
    1f0a:	df 91       	pop	r29
    1f0c:	cf 91       	pop	r28
    1f0e:	bf 91       	pop	r27
    1f10:	af 91       	pop	r26
    1f12:	9f 91       	pop	r25
    1f14:	8f 91       	pop	r24
    1f16:	7f 91       	pop	r23
    1f18:	6f 91       	pop	r22
    1f1a:	5f 91       	pop	r21
    1f1c:	4f 91       	pop	r20
    1f1e:	3f 91       	pop	r19
    1f20:	2f 91       	pop	r18
    1f22:	1f 91       	pop	r17
    1f24:	0f 91       	pop	r16
    1f26:	ff 90       	pop	r15
    1f28:	ef 90       	pop	r14
    1f2a:	df 90       	pop	r13
    1f2c:	cf 90       	pop	r12
    1f2e:	bf 90       	pop	r11
    1f30:	af 90       	pop	r10
    1f32:	9f 90       	pop	r9
    1f34:	8f 90       	pop	r8
    1f36:	7f 90       	pop	r7
    1f38:	6f 90       	pop	r6
    1f3a:	5f 90       	pop	r5
    1f3c:	4f 90       	pop	r4
    1f3e:	3f 90       	pop	r3
    1f40:	2f 90       	pop	r2
    1f42:	1f 90       	pop	r1
    1f44:	0f 90       	pop	r0
    1f46:	0f be       	out	0x3f, r0	; 63
    1f48:	0f 90       	pop	r0
	asm volatile ( "reti" );
    1f4a:	18 95       	reti

00001f4c <__vector_14>:
	 * the context is saved at the start of the ISR.  The tick
	 * count is incremented after the context is saved.
	 */	
	ISR(TCC0_OVF_vect,ISR_NAKED)
	{
		portSAVE_CONTEXT();
    1f4c:	0f 92       	push	r0
    1f4e:	0f b6       	in	r0, 0x3f	; 63
    1f50:	f8 94       	cli
    1f52:	0f 92       	push	r0
    1f54:	1f 92       	push	r1
    1f56:	11 24       	eor	r1, r1
    1f58:	2f 92       	push	r2
    1f5a:	3f 92       	push	r3
    1f5c:	4f 92       	push	r4
    1f5e:	5f 92       	push	r5
    1f60:	6f 92       	push	r6
    1f62:	7f 92       	push	r7
    1f64:	8f 92       	push	r8
    1f66:	9f 92       	push	r9
    1f68:	af 92       	push	r10
    1f6a:	bf 92       	push	r11
    1f6c:	cf 92       	push	r12
    1f6e:	df 92       	push	r13
    1f70:	ef 92       	push	r14
    1f72:	ff 92       	push	r15
    1f74:	0f 93       	push	r16
    1f76:	1f 93       	push	r17
    1f78:	2f 93       	push	r18
    1f7a:	3f 93       	push	r19
    1f7c:	4f 93       	push	r20
    1f7e:	5f 93       	push	r21
    1f80:	6f 93       	push	r22
    1f82:	7f 93       	push	r23
    1f84:	8f 93       	push	r24
    1f86:	9f 93       	push	r25
    1f88:	af 93       	push	r26
    1f8a:	bf 93       	push	r27
    1f8c:	cf 93       	push	r28
    1f8e:	df 93       	push	r29
    1f90:	ef 93       	push	r30
    1f92:	ff 93       	push	r31
    1f94:	a0 91 8c 68 	lds	r26, 0x688C	; 0x80688c <pxCurrentTCB>
    1f98:	b0 91 8d 68 	lds	r27, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    1f9c:	0d b6       	in	r0, 0x3d	; 61
    1f9e:	0d 92       	st	X+, r0
    1fa0:	0e b6       	in	r0, 0x3e	; 62
    1fa2:	0d 92       	st	X+, r0
		StatsTimer+=TCC0.PER;
    1fa4:	20 91 26 08 	lds	r18, 0x0826	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
    1fa8:	30 91 27 08 	lds	r19, 0x0827	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
    1fac:	80 91 a2 68 	lds	r24, 0x68A2	; 0x8068a2 <StatsTimer>
    1fb0:	90 91 a3 68 	lds	r25, 0x68A3	; 0x8068a3 <StatsTimer+0x1>
    1fb4:	a0 91 a4 68 	lds	r26, 0x68A4	; 0x8068a4 <StatsTimer+0x2>
    1fb8:	b0 91 a5 68 	lds	r27, 0x68A5	; 0x8068a5 <StatsTimer+0x3>
    1fbc:	82 0f       	add	r24, r18
    1fbe:	93 1f       	adc	r25, r19
    1fc0:	a1 1d       	adc	r26, r1
    1fc2:	b1 1d       	adc	r27, r1
    1fc4:	80 93 a2 68 	sts	0x68A2, r24	; 0x8068a2 <StatsTimer>
    1fc8:	90 93 a3 68 	sts	0x68A3, r25	; 0x8068a3 <StatsTimer+0x1>
    1fcc:	a0 93 a4 68 	sts	0x68A4, r26	; 0x8068a4 <StatsTimer+0x2>
    1fd0:	b0 93 a5 68 	sts	0x68A5, r27	; 0x8068a5 <StatsTimer+0x3>
		xTaskIncrementTick();
    1fd4:	0e 94 91 18 	call	0x3122	; 0x3122 <xTaskIncrementTick>
		vTaskSwitchContext();
    1fd8:	0e 94 75 1a 	call	0x34ea	; 0x34ea <vTaskSwitchContext>
		portRESTORE_CONTEXT();
    1fdc:	a0 91 8c 68 	lds	r26, 0x688C	; 0x80688c <pxCurrentTCB>
    1fe0:	b0 91 8d 68 	lds	r27, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    1fe4:	cd 91       	ld	r28, X+
    1fe6:	cd bf       	out	0x3d, r28	; 61
    1fe8:	dd 91       	ld	r29, X+
    1fea:	de bf       	out	0x3e, r29	; 62
    1fec:	ff 91       	pop	r31
    1fee:	ef 91       	pop	r30
    1ff0:	df 91       	pop	r29
    1ff2:	cf 91       	pop	r28
    1ff4:	bf 91       	pop	r27
    1ff6:	af 91       	pop	r26
    1ff8:	9f 91       	pop	r25
    1ffa:	8f 91       	pop	r24
    1ffc:	7f 91       	pop	r23
    1ffe:	6f 91       	pop	r22
    2000:	5f 91       	pop	r21
    2002:	4f 91       	pop	r20
    2004:	3f 91       	pop	r19
    2006:	2f 91       	pop	r18
    2008:	1f 91       	pop	r17
    200a:	0f 91       	pop	r16
    200c:	ff 90       	pop	r15
    200e:	ef 90       	pop	r14
    2010:	df 90       	pop	r13
    2012:	cf 90       	pop	r12
    2014:	bf 90       	pop	r11
    2016:	af 90       	pop	r10
    2018:	9f 90       	pop	r9
    201a:	8f 90       	pop	r8
    201c:	7f 90       	pop	r7
    201e:	6f 90       	pop	r6
    2020:	5f 90       	pop	r5
    2022:	4f 90       	pop	r4
    2024:	3f 90       	pop	r3
    2026:	2f 90       	pop	r2
    2028:	1f 90       	pop	r1
    202a:	0f 90       	pop	r0
    202c:	0f be       	out	0x3f, r0	; 63
    202e:	0f 90       	pop	r0

		asm volatile ( "reti" );
    2030:	18 95       	reti

00002032 <vConfigureTimerForRunTimeStats>:
 */

volatile uint32_t StatsTimer;

void vConfigureTimerForRunTimeStats(void)
{
    2032:	08 95       	ret

00002034 <__vector_20>:
	//TCC1.CTRLA=0b0111; //DIV1024	
	//TCC1.INTCTRLA=0b00000001; //OVF priority LOW
}

ISR(TCC1_OVF_vect)
{
    2034:	1f 92       	push	r1
    2036:	0f 92       	push	r0
    2038:	0f b6       	in	r0, 0x3f	; 63
    203a:	0f 92       	push	r0
    203c:	11 24       	eor	r1, r1
	//StatsTimer++;
}
    203e:	0f 90       	pop	r0
    2040:	0f be       	out	0x3f, r0	; 63
    2042:	0f 90       	pop	r0
    2044:	1f 90       	pop	r1
    2046:	18 95       	reti

00002048 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2048:	0f 93       	push	r16
    204a:	1f 93       	push	r17
    204c:	cf 93       	push	r28
    204e:	df 93       	push	r29
    2050:	ec 01       	movw	r28, r24
    2052:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2054:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2056:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2058:	44 23       	and	r20, r20
    205a:	99 f0       	breq	.+38     	; 0x2082 <prvCopyDataToQueue+0x3a>
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    205c:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    205e:	01 11       	cpse	r16, r1
    2060:	18 c0       	rjmp	.+48     	; 0x2092 <prvCopyDataToQueue+0x4a>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2062:	8a 81       	ldd	r24, Y+2	; 0x02
    2064:	9b 81       	ldd	r25, Y+3	; 0x03
    2066:	0e 94 ad 2a 	call	0x555a	; 0x555a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    206a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    206c:	8a 81       	ldd	r24, Y+2	; 0x02
    206e:	9b 81       	ldd	r25, Y+3	; 0x03
    2070:	82 0f       	add	r24, r18
    2072:	91 1d       	adc	r25, r1
    2074:	8a 83       	std	Y+2, r24	; 0x02
    2076:	9b 83       	std	Y+3, r25	; 0x03
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2078:	2c 81       	ldd	r18, Y+4	; 0x04
    207a:	3d 81       	ldd	r19, Y+5	; 0x05
    207c:	82 17       	cp	r24, r18
    207e:	93 07       	cpc	r25, r19
    2080:	40 f5       	brcc	.+80     	; 0x20d2 <prvCopyDataToQueue+0x8a>
    2082:	1f 5f       	subi	r17, 0xFF	; 255
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2084:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    2086:	80 e0       	ldi	r24, 0x00	; 0
    2088:	df 91       	pop	r29
    208a:	cf 91       	pop	r28
    208c:	1f 91       	pop	r17
    208e:	0f 91       	pop	r16
    2090:	08 95       	ret
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2092:	8e 81       	ldd	r24, Y+6	; 0x06
    2094:	9f 81       	ldd	r25, Y+7	; 0x07
    2096:	0e 94 ad 2a 	call	0x555a	; 0x555a <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    209a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    209c:	90 e0       	ldi	r25, 0x00	; 0
    209e:	91 95       	neg	r25
    20a0:	81 95       	neg	r24
    20a2:	91 09       	sbc	r25, r1
    20a4:	2e 81       	ldd	r18, Y+6	; 0x06
    20a6:	3f 81       	ldd	r19, Y+7	; 0x07
    20a8:	28 0f       	add	r18, r24
    20aa:	39 1f       	adc	r19, r25
    20ac:	2e 83       	std	Y+6, r18	; 0x06
    20ae:	3f 83       	std	Y+7, r19	; 0x07
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    20b0:	48 81       	ld	r20, Y
    20b2:	59 81       	ldd	r21, Y+1	; 0x01
    20b4:	24 17       	cp	r18, r20
    20b6:	35 07       	cpc	r19, r21
    20b8:	30 f4       	brcc	.+12     	; 0x20c6 <prvCopyDataToQueue+0x7e>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    20ba:	2c 81       	ldd	r18, Y+4	; 0x04
    20bc:	3d 81       	ldd	r19, Y+5	; 0x05
    20be:	82 0f       	add	r24, r18
    20c0:	93 1f       	adc	r25, r19
    20c2:	8e 83       	std	Y+6, r24	; 0x06
    20c4:	9f 83       	std	Y+7, r25	; 0x07
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    20c6:	02 30       	cpi	r16, 0x02	; 2
    20c8:	e1 f6       	brne	.-72     	; 0x2082 <prvCopyDataToQueue+0x3a>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    20ca:	11 11       	cpse	r17, r1
    20cc:	db cf       	rjmp	.-74     	; 0x2084 <prvCopyDataToQueue+0x3c>
    20ce:	11 e0       	ldi	r17, 0x01	; 1
    20d0:	d9 cf       	rjmp	.-78     	; 0x2084 <prvCopyDataToQueue+0x3c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    20d2:	88 81       	ld	r24, Y
    20d4:	99 81       	ldd	r25, Y+1	; 0x01
    20d6:	8a 83       	std	Y+2, r24	; 0x02
    20d8:	9b 83       	std	Y+3, r25	; 0x03
    20da:	1f 5f       	subi	r17, 0xFF	; 255
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    20dc:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    20de:	80 e0       	ldi	r24, 0x00	; 0
    20e0:	df 91       	pop	r29
    20e2:	cf 91       	pop	r28
    20e4:	1f 91       	pop	r17
    20e6:	0f 91       	pop	r16
    20e8:	08 95       	ret

000020ea <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    20ea:	fc 01       	movw	r30, r24
    20ec:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    20ee:	44 8d       	ldd	r20, Z+28	; 0x1c
    20f0:	44 23       	and	r20, r20
    20f2:	91 f0       	breq	.+36     	; 0x2118 <prvCopyDataFromQueue+0x2e>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    20f4:	50 e0       	ldi	r21, 0x00	; 0
    20f6:	66 81       	ldd	r22, Z+6	; 0x06
    20f8:	77 81       	ldd	r23, Z+7	; 0x07
    20fa:	64 0f       	add	r22, r20
    20fc:	75 1f       	adc	r23, r21
    20fe:	66 83       	std	Z+6, r22	; 0x06
    2100:	77 83       	std	Z+7, r23	; 0x07
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2102:	24 81       	ldd	r18, Z+4	; 0x04
    2104:	35 81       	ldd	r19, Z+5	; 0x05
    2106:	62 17       	cp	r22, r18
    2108:	73 07       	cpc	r23, r19
    210a:	20 f0       	brcs	.+8      	; 0x2114 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    210c:	60 81       	ld	r22, Z
    210e:	71 81       	ldd	r23, Z+1	; 0x01
    2110:	66 83       	std	Z+6, r22	; 0x06
    2112:	77 83       	std	Z+7, r23	; 0x07
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2114:	0c 94 ad 2a 	jmp	0x555a	; 0x555a <memcpy>
    2118:	08 95       	ret

0000211a <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    211a:	ef 92       	push	r14
    211c:	ff 92       	push	r15
    211e:	0f 93       	push	r16
    2120:	1f 93       	push	r17
    2122:	cf 93       	push	r28
    2124:	8c 01       	movw	r16, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2126:	0f b6       	in	r0, 0x3f	; 63
    2128:	f8 94       	cli
    212a:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    212c:	fc 01       	movw	r30, r24
    212e:	c6 8d       	ldd	r28, Z+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    2130:	1c 16       	cp	r1, r28
    2132:	c4 f4       	brge	.+48     	; 0x2164 <prvUnlockQueue+0x4a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2134:	fc 01       	movw	r30, r24
    2136:	81 89       	ldd	r24, Z+17	; 0x11
    2138:	88 23       	and	r24, r24
    213a:	a1 f0       	breq	.+40     	; 0x2164 <prvUnlockQueue+0x4a>
    213c:	78 01       	movw	r14, r16
    213e:	f1 e1       	ldi	r31, 0x11	; 17
    2140:	ef 0e       	add	r14, r31
    2142:	f1 1c       	adc	r15, r1
    2144:	06 c0       	rjmp	.+12     	; 0x2152 <prvUnlockQueue+0x38>
    2146:	c1 50       	subi	r28, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    2148:	69 f0       	breq	.+26     	; 0x2164 <prvUnlockQueue+0x4a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    214a:	f8 01       	movw	r30, r16
    214c:	81 89       	ldd	r24, Z+17	; 0x11
    214e:	88 23       	and	r24, r24
    2150:	49 f0       	breq	.+18     	; 0x2164 <prvUnlockQueue+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2152:	c7 01       	movw	r24, r14
    2154:	0e 94 9f 1a 	call	0x353e	; 0x353e <xTaskRemoveFromEventList>
    2158:	88 23       	and	r24, r24
    215a:	a9 f3       	breq	.-22     	; 0x2146 <prvUnlockQueue+0x2c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    215c:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <vTaskMissedYield>
    2160:	c1 50       	subi	r28, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    2162:	99 f7       	brne	.-26     	; 0x214a <prvUnlockQueue+0x30>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    2164:	8f ef       	ldi	r24, 0xFF	; 255
    2166:	f8 01       	movw	r30, r16
    2168:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    216a:	0f 90       	pop	r0
    216c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    216e:	0f b6       	in	r0, 0x3f	; 63
    2170:	f8 94       	cli
    2172:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    2174:	c5 8d       	ldd	r28, Z+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2176:	1c 16       	cp	r1, r28
    2178:	c4 f4       	brge	.+48     	; 0x21aa <prvUnlockQueue+0x90>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    217a:	f8 01       	movw	r30, r16
    217c:	80 85       	ldd	r24, Z+8	; 0x08
    217e:	88 23       	and	r24, r24
    2180:	a1 f0       	breq	.+40     	; 0x21aa <prvUnlockQueue+0x90>
    2182:	78 01       	movw	r14, r16
    2184:	f8 e0       	ldi	r31, 0x08	; 8
    2186:	ef 0e       	add	r14, r31
    2188:	f1 1c       	adc	r15, r1
    218a:	06 c0       	rjmp	.+12     	; 0x2198 <prvUnlockQueue+0x7e>
    218c:	c1 50       	subi	r28, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    218e:	69 f0       	breq	.+26     	; 0x21aa <prvUnlockQueue+0x90>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2190:	f8 01       	movw	r30, r16
    2192:	80 85       	ldd	r24, Z+8	; 0x08
    2194:	88 23       	and	r24, r24
    2196:	49 f0       	breq	.+18     	; 0x21aa <prvUnlockQueue+0x90>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2198:	c7 01       	movw	r24, r14
    219a:	0e 94 9f 1a 	call	0x353e	; 0x353e <xTaskRemoveFromEventList>
    219e:	88 23       	and	r24, r24
    21a0:	a9 f3       	breq	.-22     	; 0x218c <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
    21a2:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <vTaskMissedYield>
    21a6:	c1 50       	subi	r28, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    21a8:	99 f7       	brne	.-26     	; 0x2190 <prvUnlockQueue+0x76>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    21aa:	8f ef       	ldi	r24, 0xFF	; 255
    21ac:	f8 01       	movw	r30, r16
    21ae:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    21b0:	0f 90       	pop	r0
    21b2:	0f be       	out	0x3f, r0	; 63
}
    21b4:	cf 91       	pop	r28
    21b6:	1f 91       	pop	r17
    21b8:	0f 91       	pop	r16
    21ba:	ff 90       	pop	r15
    21bc:	ef 90       	pop	r14
    21be:	08 95       	ret

000021c0 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    21c0:	1f 93       	push	r17
    21c2:	cf 93       	push	r28
    21c4:	df 93       	push	r29
    21c6:	ec 01       	movw	r28, r24
    21c8:	16 2f       	mov	r17, r22
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
    21ca:	89 2b       	or	r24, r25
    21cc:	09 f4       	brne	.+2      	; 0x21d0 <xQueueGenericReset+0x10>
    21ce:	3e c0       	rjmp	.+124    	; 0x224c <xQueueGenericReset+0x8c>

	taskENTER_CRITICAL();
    21d0:	0f b6       	in	r0, 0x3f	; 63
    21d2:	f8 94       	cli
    21d4:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    21d6:	48 81       	ld	r20, Y
    21d8:	59 81       	ldd	r21, Y+1	; 0x01
    21da:	8b 8d       	ldd	r24, Y+27	; 0x1b
    21dc:	6c 8d       	ldd	r22, Y+28	; 0x1c
    21de:	9a 01       	movw	r18, r20
    21e0:	86 9f       	mul	r24, r22
    21e2:	20 0d       	add	r18, r0
    21e4:	31 1d       	adc	r19, r1
    21e6:	11 24       	eor	r1, r1
    21e8:	2c 83       	std	Y+4, r18	; 0x04
    21ea:	3d 83       	std	Y+5, r19	; 0x05
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    21ec:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    21ee:	4a 83       	std	Y+2, r20	; 0x02
    21f0:	5b 83       	std	Y+3, r21	; 0x03
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    21f2:	90 e0       	ldi	r25, 0x00	; 0
    21f4:	01 97       	sbiw	r24, 0x01	; 1
    21f6:	68 9f       	mul	r22, r24
    21f8:	90 01       	movw	r18, r0
    21fa:	69 9f       	mul	r22, r25
    21fc:	30 0d       	add	r19, r0
    21fe:	11 24       	eor	r1, r1
    2200:	ca 01       	movw	r24, r20
    2202:	82 0f       	add	r24, r18
    2204:	93 1f       	adc	r25, r19
    2206:	8e 83       	std	Y+6, r24	; 0x06
    2208:	9f 83       	std	Y+7, r25	; 0x07
		pxQueue->cRxLock = queueUNLOCKED;
    220a:	8f ef       	ldi	r24, 0xFF	; 255
    220c:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    220e:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    2210:	11 11       	cpse	r17, r1
    2212:	13 c0       	rjmp	.+38     	; 0x223a <xQueueGenericReset+0x7a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2214:	88 85       	ldd	r24, Y+8	; 0x08
    2216:	81 11       	cpse	r24, r1
    2218:	07 c0       	rjmp	.+14     	; 0x2228 <xQueueGenericReset+0x68>
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
		}
	}
	taskEXIT_CRITICAL();
    221a:	0f 90       	pop	r0
    221c:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    221e:	81 e0       	ldi	r24, 0x01	; 1
    2220:	df 91       	pop	r29
    2222:	cf 91       	pop	r28
    2224:	1f 91       	pop	r17
    2226:	08 95       	ret
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2228:	ce 01       	movw	r24, r28
    222a:	08 96       	adiw	r24, 0x08	; 8
    222c:	0e 94 9f 1a 	call	0x353e	; 0x353e <xTaskRemoveFromEventList>
    2230:	88 23       	and	r24, r24
    2232:	99 f3       	breq	.-26     	; 0x221a <xQueueGenericReset+0x5a>
				{
					queueYIELD_IF_USING_PREEMPTION();
    2234:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vPortYield>
    2238:	f0 cf       	rjmp	.-32     	; 0x221a <xQueueGenericReset+0x5a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    223a:	ce 01       	movw	r24, r28
    223c:	08 96       	adiw	r24, 0x08	; 8
    223e:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2242:	ce 01       	movw	r24, r28
    2244:	41 96       	adiw	r24, 0x11	; 17
    2246:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <vListInitialise>
    224a:	e7 cf       	rjmp	.-50     	; 0x221a <xQueueGenericReset+0x5a>

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
    224c:	63 e0       	ldi	r22, 0x03	; 3
    224e:	71 e0       	ldi	r23, 0x01	; 1
    2250:	8b e8       	ldi	r24, 0x8B	; 139
    2252:	92 e2       	ldi	r25, 0x22	; 34
    2254:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    2258:	bb cf       	rjmp	.-138    	; 0x21d0 <xQueueGenericReset+0x10>

0000225a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    225a:	ff 92       	push	r15
    225c:	0f 93       	push	r16
    225e:	1f 93       	push	r17
    2260:	cf 93       	push	r28
    2262:	df 93       	push	r29
    2264:	18 2f       	mov	r17, r24
    2266:	06 2f       	mov	r16, r22
    2268:	f4 2e       	mov	r15, r20
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    226a:	88 23       	and	r24, r24
    226c:	99 f1       	breq	.+102    	; 0x22d4 <xQueueGenericCreate+0x7a>

		if( uxItemSize == ( UBaseType_t ) 0 )
    226e:	00 23       	and	r16, r16
    2270:	d1 f0       	breq	.+52     	; 0x22a6 <xQueueGenericCreate+0x4c>
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    2272:	10 9f       	mul	r17, r16
    2274:	c0 01       	movw	r24, r0
    2276:	11 24       	eor	r1, r1
    2278:	81 96       	adiw	r24, 0x21	; 33
    227a:	0e 94 f7 0c 	call	0x19ee	; 0x19ee <pvPortMalloc>
    227e:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    2280:	00 97       	sbiw	r24, 0x00	; 0
    2282:	51 f0       	breq	.+20     	; 0x2298 <xQueueGenericCreate+0x3e>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    2284:	81 96       	adiw	r24, 0x21	; 33
    2286:	88 83       	st	Y, r24
    2288:	99 83       	std	Y+1, r25	; 0x01
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    228a:	1b 8f       	std	Y+27, r17	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    228c:	0c 8f       	std	Y+28, r16	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    228e:	61 e0       	ldi	r22, 0x01	; 1
    2290:	ce 01       	movw	r24, r28
    2292:	0e 94 e0 10 	call	0x21c0	; 0x21c0 <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
    2296:	f8 a2       	std	Y+32, r15	; 0x20
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    2298:	ce 01       	movw	r24, r28
    229a:	df 91       	pop	r29
    229c:	cf 91       	pop	r28
    229e:	1f 91       	pop	r17
    22a0:	0f 91       	pop	r16
    22a2:	ff 90       	pop	r15
    22a4:	08 95       	ret
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    22a6:	81 e2       	ldi	r24, 0x21	; 33
    22a8:	90 e0       	ldi	r25, 0x00	; 0
    22aa:	0e 94 f7 0c 	call	0x19ee	; 0x19ee <pvPortMalloc>
    22ae:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    22b0:	89 2b       	or	r24, r25
    22b2:	91 f3       	breq	.-28     	; 0x2298 <xQueueGenericCreate+0x3e>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    22b4:	c8 83       	st	Y, r28
    22b6:	d9 83       	std	Y+1, r29	; 0x01
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    22b8:	1b 8f       	std	Y+27, r17	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    22ba:	0c 8f       	std	Y+28, r16	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    22bc:	61 e0       	ldi	r22, 0x01	; 1
    22be:	ce 01       	movw	r24, r28
    22c0:	0e 94 e0 10 	call	0x21c0	; 0x21c0 <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
    22c4:	f8 a2       	std	Y+32, r15	; 0x20
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    22c6:	ce 01       	movw	r24, r28
    22c8:	df 91       	pop	r29
    22ca:	cf 91       	pop	r28
    22cc:	1f 91       	pop	r17
    22ce:	0f 91       	pop	r16
    22d0:	ff 90       	pop	r15
    22d2:	08 95       	ret
	{
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    22d4:	66 e7       	ldi	r22, 0x76	; 118
    22d6:	71 e0       	ldi	r23, 0x01	; 1
    22d8:	8b e8       	ldi	r24, 0x8B	; 139
    22da:	92 e2       	ldi	r25, 0x22	; 34
    22dc:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    22e0:	c6 cf       	rjmp	.-116    	; 0x226e <xQueueGenericCreate+0x14>

000022e2 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    22e2:	bf 92       	push	r11
    22e4:	cf 92       	push	r12
    22e6:	df 92       	push	r13
    22e8:	ef 92       	push	r14
    22ea:	ff 92       	push	r15
    22ec:	0f 93       	push	r16
    22ee:	1f 93       	push	r17
    22f0:	cf 93       	push	r28
    22f2:	df 93       	push	r29
    22f4:	cd b7       	in	r28, 0x3d	; 61
    22f6:	de b7       	in	r29, 0x3e	; 62
    22f8:	25 97       	sbiw	r28, 0x05	; 5
    22fa:	cd bf       	out	0x3d, r28	; 61
    22fc:	de bf       	out	0x3e, r29	; 62
    22fe:	8c 01       	movw	r16, r24
    2300:	6b 01       	movw	r12, r22
    2302:	4c 83       	std	Y+4, r20	; 0x04
    2304:	5d 83       	std	Y+5, r21	; 0x05
    2306:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
    2308:	89 2b       	or	r24, r25
    230a:	09 f4       	brne	.+2      	; 0x230e <xQueueGenericSend+0x2c>
    230c:	b2 c0       	rjmp	.+356    	; 0x2472 <xQueueGenericSend+0x190>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    230e:	c1 14       	cp	r12, r1
    2310:	d1 04       	cpc	r13, r1
    2312:	09 f4       	brne	.+2      	; 0x2316 <xQueueGenericSend+0x34>
    2314:	a2 c0       	rjmp	.+324    	; 0x245a <xQueueGenericSend+0x178>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    2316:	f2 e0       	ldi	r31, 0x02	; 2
    2318:	bf 16       	cp	r11, r31
    231a:	09 f4       	brne	.+2      	; 0x231e <xQueueGenericSend+0x3c>
    231c:	7d c0       	rjmp	.+250    	; 0x2418 <xQueueGenericSend+0x136>
    231e:	f8 01       	movw	r30, r16
    2320:	83 8d       	ldd	r24, Z+27	; 0x1b

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    2322:	20 e0       	ldi	r18, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2324:	78 01       	movw	r14, r16
    2326:	f8 e0       	ldi	r31, 0x08	; 8
    2328:	ef 0e       	add	r14, r31
    232a:	f1 1c       	adc	r15, r1
    232c:	10 c0       	rjmp	.+32     	; 0x234e <xQueueGenericSend+0x6c>
    232e:	6c 81       	ldd	r22, Y+4	; 0x04
    2330:	7d 81       	ldd	r23, Y+5	; 0x05
    2332:	c7 01       	movw	r24, r14
    2334:	0e 94 7f 1a 	call	0x34fe	; 0x34fe <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2338:	c8 01       	movw	r24, r16
    233a:	0e 94 8d 10 	call	0x211a	; 0x211a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    233e:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>
    2342:	88 23       	and	r24, r24
    2344:	09 f4       	brne	.+2      	; 0x2348 <xQueueGenericSend+0x66>
    2346:	4a c0       	rjmp	.+148    	; 0x23dc <xQueueGenericSend+0xfa>
    2348:	f8 01       	movw	r30, r16
    234a:	83 8d       	ldd	r24, Z+27	; 0x1b
    234c:	21 e0       	ldi	r18, 0x01	; 1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    234e:	0f b6       	in	r0, 0x3f	; 63
    2350:	f8 94       	cli
    2352:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2354:	f8 01       	movw	r30, r16
    2356:	92 8d       	ldd	r25, Z+26	; 0x1a
    2358:	98 17       	cp	r25, r24
    235a:	08 f4       	brcc	.+2      	; 0x235e <xQueueGenericSend+0x7c>
    235c:	42 c0       	rjmp	.+132    	; 0x23e2 <xQueueGenericSend+0x100>
    235e:	f2 e0       	ldi	r31, 0x02	; 2
    2360:	bf 16       	cp	r11, r31
    2362:	09 f4       	brne	.+2      	; 0x2366 <xQueueGenericSend+0x84>
    2364:	3e c0       	rjmp	.+124    	; 0x23e2 <xQueueGenericSend+0x100>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2366:	8c 81       	ldd	r24, Y+4	; 0x04
    2368:	9d 81       	ldd	r25, Y+5	; 0x05
    236a:	89 2b       	or	r24, r25
    236c:	09 f4       	brne	.+2      	; 0x2370 <xQueueGenericSend+0x8e>
    236e:	60 c0       	rjmp	.+192    	; 0x2430 <xQueueGenericSend+0x14e>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    2370:	22 23       	and	r18, r18
    2372:	59 f1       	breq	.+86     	; 0x23ca <xQueueGenericSend+0xe8>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2374:	0f 90       	pop	r0
    2376:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2378:	0e 94 6f 18 	call	0x30de	; 0x30de <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    237c:	0f b6       	in	r0, 0x3f	; 63
    237e:	f8 94       	cli
    2380:	0f 92       	push	r0
    2382:	f8 01       	movw	r30, r16
    2384:	85 8d       	ldd	r24, Z+29	; 0x1d
    2386:	8f 3f       	cpi	r24, 0xFF	; 255
    2388:	39 f1       	breq	.+78     	; 0x23d8 <xQueueGenericSend+0xf6>
    238a:	f8 01       	movw	r30, r16
    238c:	86 8d       	ldd	r24, Z+30	; 0x1e
    238e:	8f 3f       	cpi	r24, 0xFF	; 255
    2390:	09 f1       	breq	.+66     	; 0x23d4 <xQueueGenericSend+0xf2>
    2392:	0f 90       	pop	r0
    2394:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2396:	be 01       	movw	r22, r28
    2398:	6c 5f       	subi	r22, 0xFC	; 252
    239a:	7f 4f       	sbci	r23, 0xFF	; 255
    239c:	ce 01       	movw	r24, r28
    239e:	01 96       	adiw	r24, 0x01	; 1
    23a0:	0e 94 01 1b 	call	0x3602	; 0x3602 <xTaskCheckForTimeOut>
    23a4:	81 11       	cpse	r24, r1
    23a6:	48 c0       	rjmp	.+144    	; 0x2438 <xQueueGenericSend+0x156>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    23a8:	0f b6       	in	r0, 0x3f	; 63
    23aa:	f8 94       	cli
    23ac:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    23ae:	f8 01       	movw	r30, r16
    23b0:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    23b2:	0f 90       	pop	r0
    23b4:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    23b6:	83 8d       	ldd	r24, Z+27	; 0x1b
    23b8:	98 17       	cp	r25, r24
    23ba:	09 f4       	brne	.+2      	; 0x23be <xQueueGenericSend+0xdc>
    23bc:	b8 cf       	rjmp	.-144    	; 0x232e <xQueueGenericSend+0x4c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    23be:	c8 01       	movw	r24, r16
    23c0:	0e 94 8d 10 	call	0x211a	; 0x211a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    23c4:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>
    23c8:	bf cf       	rjmp	.-130    	; 0x2348 <xQueueGenericSend+0x66>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    23ca:	ce 01       	movw	r24, r28
    23cc:	01 96       	adiw	r24, 0x01	; 1
    23ce:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <vTaskInternalSetTimeOutState>
    23d2:	d0 cf       	rjmp	.-96     	; 0x2374 <xQueueGenericSend+0x92>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    23d4:	16 8e       	std	Z+30, r1	; 0x1e
    23d6:	dd cf       	rjmp	.-70     	; 0x2392 <xQueueGenericSend+0xb0>
    23d8:	15 8e       	std	Z+29, r1	; 0x1d
    23da:	d7 cf       	rjmp	.-82     	; 0x238a <xQueueGenericSend+0xa8>
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
				{
					portYIELD_WITHIN_API();
    23dc:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vPortYield>
    23e0:	b3 cf       	rjmp	.-154    	; 0x2348 <xQueueGenericSend+0x66>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    23e2:	4b 2d       	mov	r20, r11
    23e4:	b6 01       	movw	r22, r12
    23e6:	c8 01       	movw	r24, r16
    23e8:	0e 94 24 10 	call	0x2048	; 0x2048 <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    23ec:	f8 01       	movw	r30, r16
    23ee:	91 89       	ldd	r25, Z+17	; 0x11
    23f0:	91 11       	cpse	r25, r1
    23f2:	2c c0       	rjmp	.+88     	; 0x244c <xQueueGenericSend+0x16a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    23f4:	81 11       	cpse	r24, r1
    23f6:	27 c0       	rjmp	.+78     	; 0x2446 <xQueueGenericSend+0x164>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    23f8:	0f 90       	pop	r0
    23fa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    23fc:	81 e0       	ldi	r24, 0x01	; 1

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	} /*lint -restore */
}
    23fe:	25 96       	adiw	r28, 0x05	; 5
    2400:	cd bf       	out	0x3d, r28	; 61
    2402:	de bf       	out	0x3e, r29	; 62
    2404:	df 91       	pop	r29
    2406:	cf 91       	pop	r28
    2408:	1f 91       	pop	r17
    240a:	0f 91       	pop	r16
    240c:	ff 90       	pop	r15
    240e:	ef 90       	pop	r14
    2410:	df 90       	pop	r13
    2412:	cf 90       	pop	r12
    2414:	bf 90       	pop	r11
    2416:	08 95       	ret
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    2418:	f8 01       	movw	r30, r16
    241a:	83 8d       	ldd	r24, Z+27	; 0x1b
    241c:	81 30       	cpi	r24, 0x01	; 1
    241e:	09 f4       	brne	.+2      	; 0x2422 <xQueueGenericSend+0x140>
    2420:	80 cf       	rjmp	.-256    	; 0x2322 <xQueueGenericSend+0x40>
    2422:	63 ef       	ldi	r22, 0xF3	; 243
    2424:	72 e0       	ldi	r23, 0x02	; 2
    2426:	8b e8       	ldi	r24, 0x8B	; 139
    2428:	92 e2       	ldi	r25, 0x22	; 34
    242a:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    242e:	77 cf       	rjmp	.-274    	; 0x231e <xQueueGenericSend+0x3c>
			{
				if( xTicksToWait == ( TickType_t ) 0 )
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2430:	0f 90       	pop	r0
    2432:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2434:	80 e0       	ldi	r24, 0x00	; 0
    2436:	e3 cf       	rjmp	.-58     	; 0x23fe <xQueueGenericSend+0x11c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2438:	c8 01       	movw	r24, r16
    243a:	0e 94 8d 10 	call	0x211a	; 0x211a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    243e:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2442:	80 e0       	ldi	r24, 0x00	; 0
    2444:	dc cf       	rjmp	.-72     	; 0x23fe <xQueueGenericSend+0x11c>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2446:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vPortYield>
    244a:	d6 cf       	rjmp	.-84     	; 0x23f8 <xQueueGenericSend+0x116>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    244c:	c8 01       	movw	r24, r16
    244e:	41 96       	adiw	r24, 0x11	; 17
    2450:	0e 94 9f 1a 	call	0x353e	; 0x353e <xTaskRemoveFromEventList>
    2454:	88 23       	and	r24, r24
    2456:	81 f2       	breq	.-96     	; 0x23f8 <xQueueGenericSend+0x116>
    2458:	f6 cf       	rjmp	.-20     	; 0x2446 <xQueueGenericSend+0x164>
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    245a:	f8 01       	movw	r30, r16
    245c:	84 8d       	ldd	r24, Z+28	; 0x1c
    245e:	88 23       	and	r24, r24
    2460:	09 f4       	brne	.+2      	; 0x2464 <xQueueGenericSend+0x182>
    2462:	59 cf       	rjmp	.-334    	; 0x2316 <xQueueGenericSend+0x34>
    2464:	62 ef       	ldi	r22, 0xF2	; 242
    2466:	72 e0       	ldi	r23, 0x02	; 2
    2468:	8b e8       	ldi	r24, 0x8B	; 139
    246a:	92 e2       	ldi	r25, 0x22	; 34
    246c:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    2470:	52 cf       	rjmp	.-348    	; 0x2316 <xQueueGenericSend+0x34>
{
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
    2472:	61 ef       	ldi	r22, 0xF1	; 241
    2474:	72 e0       	ldi	r23, 0x02	; 2
    2476:	8b e8       	ldi	r24, 0x8B	; 139
    2478:	92 e2       	ldi	r25, 0x22	; 34
    247a:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    247e:	47 cf       	rjmp	.-370    	; 0x230e <xQueueGenericSend+0x2c>

00002480 <xQueueGenericSendFromISR>:
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    2480:	cf 92       	push	r12
    2482:	df 92       	push	r13
    2484:	ef 92       	push	r14
    2486:	ff 92       	push	r15
    2488:	0f 93       	push	r16
    248a:	1f 93       	push	r17
    248c:	cf 93       	push	r28
    248e:	df 93       	push	r29
    2490:	ec 01       	movw	r28, r24
    2492:	8b 01       	movw	r16, r22
    2494:	6a 01       	movw	r12, r20
    2496:	f2 2e       	mov	r15, r18
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
    2498:	89 2b       	or	r24, r25
    249a:	09 f4       	brne	.+2      	; 0x249e <xQueueGenericSendFromISR+0x1e>
    249c:	45 c0       	rjmp	.+138    	; 0x2528 <xQueueGenericSendFromISR+0xa8>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    249e:	01 15       	cp	r16, r1
    24a0:	11 05       	cpc	r17, r1
    24a2:	c1 f1       	breq	.+112    	; 0x2514 <xQueueGenericSendFromISR+0x94>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    24a4:	82 e0       	ldi	r24, 0x02	; 2
    24a6:	f8 16       	cp	r15, r24
    24a8:	71 f0       	breq	.+28     	; 0x24c6 <xQueueGenericSendFromISR+0x46>
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    24aa:	9a 8d       	ldd	r25, Y+26	; 0x1a
    24ac:	8b 8d       	ldd	r24, Y+27	; 0x1b
    24ae:	98 17       	cp	r25, r24
    24b0:	a0 f0       	brcs	.+40     	; 0x24da <xQueueGenericSendFromISR+0x5a>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    24b2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    24b4:	df 91       	pop	r29
    24b6:	cf 91       	pop	r28
    24b8:	1f 91       	pop	r17
    24ba:	0f 91       	pop	r16
    24bc:	ff 90       	pop	r15
    24be:	ef 90       	pop	r14
    24c0:	df 90       	pop	r13
    24c2:	cf 90       	pop	r12
    24c4:	08 95       	ret
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    24c6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    24c8:	81 30       	cpi	r24, 0x01	; 1
    24ca:	31 f0       	breq	.+12     	; 0x24d8 <xQueueGenericSendFromISR+0x58>
    24cc:	65 ec       	ldi	r22, 0xC5	; 197
    24ce:	73 e0       	ldi	r23, 0x03	; 3
    24d0:	8b e8       	ldi	r24, 0x8B	; 139
    24d2:	92 e2       	ldi	r25, 0x22	; 34
    24d4:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    24d8:	8a 8d       	ldd	r24, Y+26	; 0x1a
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    24da:	ee 8c       	ldd	r14, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    24dc:	4f 2d       	mov	r20, r15
    24de:	b8 01       	movw	r22, r16
    24e0:	ce 01       	movw	r24, r28
    24e2:	0e 94 24 10 	call	0x2048	; 0x2048 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    24e6:	ef ef       	ldi	r30, 0xFF	; 255
    24e8:	ee 16       	cp	r14, r30
    24ea:	21 f0       	breq	.+8      	; 0x24f4 <xQueueGenericSendFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    24ec:	e3 94       	inc	r14
    24ee:	ee 8e       	std	Y+30, r14	; 0x1e
			}

			xReturn = pdPASS;
    24f0:	81 e0       	ldi	r24, 0x01	; 1
    24f2:	e0 cf       	rjmp	.-64     	; 0x24b4 <xQueueGenericSendFromISR+0x34>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    24f4:	89 89       	ldd	r24, Y+17	; 0x11
    24f6:	88 23       	and	r24, r24
    24f8:	d9 f3       	breq	.-10     	; 0x24f0 <xQueueGenericSendFromISR+0x70>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    24fa:	ce 01       	movw	r24, r28
    24fc:	41 96       	adiw	r24, 0x11	; 17
    24fe:	0e 94 9f 1a 	call	0x353e	; 0x353e <xTaskRemoveFromEventList>
    2502:	88 23       	and	r24, r24
    2504:	a9 f3       	breq	.-22     	; 0x24f0 <xQueueGenericSendFromISR+0x70>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2506:	c1 14       	cp	r12, r1
    2508:	d1 04       	cpc	r13, r1
    250a:	91 f3       	breq	.-28     	; 0x24f0 <xQueueGenericSendFromISR+0x70>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    250c:	81 e0       	ldi	r24, 0x01	; 1
    250e:	f6 01       	movw	r30, r12
    2510:	80 83       	st	Z, r24
    2512:	d0 cf       	rjmp	.-96     	; 0x24b4 <xQueueGenericSendFromISR+0x34>
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    2514:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2516:	88 23       	and	r24, r24
    2518:	29 f2       	breq	.-118    	; 0x24a4 <xQueueGenericSendFromISR+0x24>
    251a:	64 ec       	ldi	r22, 0xC4	; 196
    251c:	73 e0       	ldi	r23, 0x03	; 3
    251e:	8b e8       	ldi	r24, 0x8B	; 139
    2520:	92 e2       	ldi	r25, 0x22	; 34
    2522:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    2526:	be cf       	rjmp	.-132    	; 0x24a4 <xQueueGenericSendFromISR+0x24>
{
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
    2528:	63 ec       	ldi	r22, 0xC3	; 195
    252a:	73 e0       	ldi	r23, 0x03	; 3
    252c:	8b e8       	ldi	r24, 0x8B	; 139
    252e:	92 e2       	ldi	r25, 0x22	; 34
    2530:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    2534:	b4 cf       	rjmp	.-152    	; 0x249e <xQueueGenericSendFromISR+0x1e>

00002536 <xQueueGiveFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2536:	0f 93       	push	r16
    2538:	1f 93       	push	r17
    253a:	cf 93       	push	r28
    253c:	df 93       	push	r29
    253e:	ec 01       	movw	r28, r24
    2540:	8b 01       	movw	r16, r22
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
    2542:	89 2b       	or	r24, r25
    2544:	09 f4       	brne	.+2      	; 0x2548 <xQueueGiveFromISR+0x12>
    2546:	43 c0       	rjmp	.+134    	; 0x25ce <xQueueGiveFromISR+0x98>

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    2548:	8c 8d       	ldd	r24, Y+28	; 0x1c
    254a:	81 11       	cpse	r24, r1
    254c:	1b c0       	rjmp	.+54     	; 0x2584 <xQueueGiveFromISR+0x4e>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
    254e:	88 81       	ld	r24, Y
    2550:	99 81       	ldd	r25, Y+1	; 0x01
    2552:	89 2b       	or	r24, r25
    2554:	09 f1       	breq	.+66     	; 0x2598 <xQueueGiveFromISR+0x62>
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2556:	8a 8d       	ldd	r24, Y+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    2558:	9b 8d       	ldd	r25, Y+27	; 0x1b
    255a:	89 17       	cp	r24, r25
    255c:	68 f4       	brcc	.+26     	; 0x2578 <xQueueGiveFromISR+0x42>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    255e:	9e 8d       	ldd	r25, Y+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2560:	8f 5f       	subi	r24, 0xFF	; 255
    2562:	8a 8f       	std	Y+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2564:	9f 3f       	cpi	r25, 0xFF	; 255
    2566:	19 f1       	breq	.+70     	; 0x25ae <xQueueGiveFromISR+0x78>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2568:	9f 5f       	subi	r25, 0xFF	; 255
    256a:	9e 8f       	std	Y+30, r25	; 0x1e
			}

			xReturn = pdPASS;
    256c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    256e:	df 91       	pop	r29
    2570:	cf 91       	pop	r28
    2572:	1f 91       	pop	r17
    2574:	0f 91       	pop	r16
    2576:	08 95       	ret
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2578:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    257a:	df 91       	pop	r29
    257c:	cf 91       	pop	r28
    257e:	1f 91       	pop	r17
    2580:	0f 91       	pop	r16
    2582:	08 95       	ret

	configASSERT( pxQueue );

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    2584:	64 e6       	ldi	r22, 0x64	; 100
    2586:	74 e0       	ldi	r23, 0x04	; 4
    2588:	8b e8       	ldi	r24, 0x8B	; 139
    258a:	92 e2       	ldi	r25, 0x22	; 34
    258c:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
    2590:	88 81       	ld	r24, Y
    2592:	99 81       	ldd	r25, Y+1	; 0x01
    2594:	89 2b       	or	r24, r25
    2596:	f9 f6       	brne	.-66     	; 0x2556 <xQueueGiveFromISR+0x20>
    2598:	8c 81       	ldd	r24, Y+4	; 0x04
    259a:	9d 81       	ldd	r25, Y+5	; 0x05
    259c:	89 2b       	or	r24, r25
    259e:	d9 f2       	breq	.-74     	; 0x2556 <xQueueGiveFromISR+0x20>
    25a0:	69 e6       	ldi	r22, 0x69	; 105
    25a2:	74 e0       	ldi	r23, 0x04	; 4
    25a4:	8b e8       	ldi	r24, 0x8B	; 139
    25a6:	92 e2       	ldi	r25, 0x22	; 34
    25a8:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    25ac:	d4 cf       	rjmp	.-88     	; 0x2556 <xQueueGiveFromISR+0x20>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    25ae:	89 89       	ldd	r24, Y+17	; 0x11
    25b0:	88 23       	and	r24, r24
    25b2:	e1 f2       	breq	.-72     	; 0x256c <xQueueGiveFromISR+0x36>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    25b4:	ce 01       	movw	r24, r28
    25b6:	41 96       	adiw	r24, 0x11	; 17
    25b8:	0e 94 9f 1a 	call	0x353e	; 0x353e <xTaskRemoveFromEventList>
    25bc:	88 23       	and	r24, r24
    25be:	b1 f2       	breq	.-84     	; 0x256c <xQueueGiveFromISR+0x36>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    25c0:	01 15       	cp	r16, r1
    25c2:	11 05       	cpc	r17, r1
    25c4:	99 f2       	breq	.-90     	; 0x256c <xQueueGiveFromISR+0x36>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    25c6:	81 e0       	ldi	r24, 0x01	; 1
    25c8:	f8 01       	movw	r30, r16
    25ca:	80 83       	st	Z, r24
    25cc:	d0 cf       	rjmp	.-96     	; 0x256e <xQueueGiveFromISR+0x38>
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
    25ce:	60 e6       	ldi	r22, 0x60	; 96
    25d0:	74 e0       	ldi	r23, 0x04	; 4
    25d2:	8b e8       	ldi	r24, 0x8B	; 139
    25d4:	92 e2       	ldi	r25, 0x22	; 34
    25d6:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    25da:	b6 cf       	rjmp	.-148    	; 0x2548 <xQueueGiveFromISR+0x12>

000025dc <xQueueReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    25dc:	af 92       	push	r10
    25de:	bf 92       	push	r11
    25e0:	cf 92       	push	r12
    25e2:	df 92       	push	r13
    25e4:	ff 92       	push	r15
    25e6:	0f 93       	push	r16
    25e8:	1f 93       	push	r17
    25ea:	cf 93       	push	r28
    25ec:	df 93       	push	r29
    25ee:	cd b7       	in	r28, 0x3d	; 61
    25f0:	de b7       	in	r29, 0x3e	; 62
    25f2:	25 97       	sbiw	r28, 0x05	; 5
    25f4:	cd bf       	out	0x3d, r28	; 61
    25f6:	de bf       	out	0x3e, r29	; 62
    25f8:	8c 01       	movw	r16, r24
    25fa:	5b 01       	movw	r10, r22
    25fc:	4c 83       	std	Y+4, r20	; 0x04
    25fe:	5d 83       	std	Y+5, r21	; 0x05
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    2600:	89 2b       	or	r24, r25
    2602:	09 f4       	brne	.+2      	; 0x2606 <xQueueReceive+0x2a>
    2604:	a1 c0       	rjmp	.+322    	; 0x2748 <xQueueReceive+0x16c>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    2606:	a1 14       	cp	r10, r1
    2608:	b1 04       	cpc	r11, r1
    260a:	09 f4       	brne	.+2      	; 0x260e <xQueueReceive+0x32>
    260c:	91 c0       	rjmp	.+290    	; 0x2730 <xQueueReceive+0x154>
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    260e:	20 e0       	ldi	r18, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2610:	68 01       	movw	r12, r16
    2612:	f1 e1       	ldi	r31, 0x11	; 17
    2614:	cf 0e       	add	r12, r31
    2616:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2618:	0f b6       	in	r0, 0x3f	; 63
    261a:	f8 94       	cli
    261c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    261e:	f8 01       	movw	r30, r16
    2620:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2622:	f1 10       	cpse	r15, r1
    2624:	6a c0       	rjmp	.+212    	; 0x26fa <xQueueReceive+0x11e>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2626:	8c 81       	ldd	r24, Y+4	; 0x04
    2628:	9d 81       	ldd	r25, Y+5	; 0x05
    262a:	89 2b       	or	r24, r25
    262c:	09 f4       	brne	.+2      	; 0x2630 <xQueueReceive+0x54>
    262e:	73 c0       	rjmp	.+230    	; 0x2716 <xQueueReceive+0x13a>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    2630:	22 23       	and	r18, r18
    2632:	09 f4       	brne	.+2      	; 0x2636 <xQueueReceive+0x5a>
    2634:	59 c0       	rjmp	.+178    	; 0x26e8 <xQueueReceive+0x10c>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2636:	0f 90       	pop	r0
    2638:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    263a:	0e 94 6f 18 	call	0x30de	; 0x30de <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    263e:	0f b6       	in	r0, 0x3f	; 63
    2640:	f8 94       	cli
    2642:	0f 92       	push	r0
    2644:	f8 01       	movw	r30, r16
    2646:	85 8d       	ldd	r24, Z+29	; 0x1d
    2648:	8f 3f       	cpi	r24, 0xFF	; 255
    264a:	09 f4       	brne	.+2      	; 0x264e <xQueueReceive+0x72>
    264c:	54 c0       	rjmp	.+168    	; 0x26f6 <xQueueReceive+0x11a>
    264e:	f8 01       	movw	r30, r16
    2650:	86 8d       	ldd	r24, Z+30	; 0x1e
    2652:	8f 3f       	cpi	r24, 0xFF	; 255
    2654:	09 f4       	brne	.+2      	; 0x2658 <xQueueReceive+0x7c>
    2656:	4d c0       	rjmp	.+154    	; 0x26f2 <xQueueReceive+0x116>
    2658:	0f 90       	pop	r0
    265a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    265c:	be 01       	movw	r22, r28
    265e:	6c 5f       	subi	r22, 0xFC	; 252
    2660:	7f 4f       	sbci	r23, 0xFF	; 255
    2662:	ce 01       	movw	r24, r28
    2664:	01 96       	adiw	r24, 0x01	; 1
    2666:	0e 94 01 1b 	call	0x3602	; 0x3602 <xTaskCheckForTimeOut>
    266a:	81 11       	cpse	r24, r1
    266c:	22 c0       	rjmp	.+68     	; 0x26b2 <xQueueReceive+0xd6>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    266e:	0f b6       	in	r0, 0x3f	; 63
    2670:	f8 94       	cli
    2672:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2674:	f8 01       	movw	r30, r16
    2676:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2678:	0f 90       	pop	r0
    267a:	0f be       	out	0x3f, r0	; 63
		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    267c:	81 11       	cpse	r24, r1
    267e:	12 c0       	rjmp	.+36     	; 0x26a4 <xQueueReceive+0xc8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2680:	6c 81       	ldd	r22, Y+4	; 0x04
    2682:	7d 81       	ldd	r23, Y+5	; 0x05
    2684:	c6 01       	movw	r24, r12
    2686:	0e 94 7f 1a 	call	0x34fe	; 0x34fe <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    268a:	c8 01       	movw	r24, r16
    268c:	0e 94 8d 10 	call	0x211a	; 0x211a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2690:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>
    2694:	88 23       	and	r24, r24
    2696:	11 f0       	breq	.+4      	; 0x269c <xQueueReceive+0xc0>
    2698:	21 e0       	ldi	r18, 0x01	; 1
    269a:	be cf       	rjmp	.-132    	; 0x2618 <xQueueReceive+0x3c>
				{
					portYIELD_WITHIN_API();
    269c:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vPortYield>
    26a0:	21 e0       	ldi	r18, 0x01	; 1
    26a2:	ba cf       	rjmp	.-140    	; 0x2618 <xQueueReceive+0x3c>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    26a4:	c8 01       	movw	r24, r16
    26a6:	0e 94 8d 10 	call	0x211a	; 0x211a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    26aa:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>
    26ae:	21 e0       	ldi	r18, 0x01	; 1
    26b0:	b3 cf       	rjmp	.-154    	; 0x2618 <xQueueReceive+0x3c>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    26b2:	c8 01       	movw	r24, r16
    26b4:	0e 94 8d 10 	call	0x211a	; 0x211a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    26b8:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    26bc:	0f b6       	in	r0, 0x3f	; 63
    26be:	f8 94       	cli
    26c0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    26c2:	f8 01       	movw	r30, r16
    26c4:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    26c6:	0f 90       	pop	r0
    26c8:	0f be       	out	0x3f, r0	; 63
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    26ca:	81 11       	cpse	r24, r1
    26cc:	e5 cf       	rjmp	.-54     	; 0x2698 <xQueueReceive+0xbc>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    26ce:	25 96       	adiw	r28, 0x05	; 5
    26d0:	cd bf       	out	0x3d, r28	; 61
    26d2:	de bf       	out	0x3e, r29	; 62
    26d4:	df 91       	pop	r29
    26d6:	cf 91       	pop	r28
    26d8:	1f 91       	pop	r17
    26da:	0f 91       	pop	r16
    26dc:	ff 90       	pop	r15
    26de:	df 90       	pop	r13
    26e0:	cf 90       	pop	r12
    26e2:	bf 90       	pop	r11
    26e4:	af 90       	pop	r10
    26e6:	08 95       	ret
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    26e8:	ce 01       	movw	r24, r28
    26ea:	01 96       	adiw	r24, 0x01	; 1
    26ec:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <vTaskInternalSetTimeOutState>
    26f0:	a2 cf       	rjmp	.-188    	; 0x2636 <xQueueReceive+0x5a>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    26f2:	16 8e       	std	Z+30, r1	; 0x1e
    26f4:	b1 cf       	rjmp	.-158    	; 0x2658 <xQueueReceive+0x7c>
    26f6:	15 8e       	std	Z+29, r1	; 0x1d
    26f8:	aa cf       	rjmp	.-172    	; 0x264e <xQueueReceive+0x72>
			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    26fa:	b5 01       	movw	r22, r10
    26fc:	c8 01       	movw	r24, r16
    26fe:	0e 94 75 10 	call	0x20ea	; 0x20ea <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2702:	fa 94       	dec	r15
    2704:	f8 01       	movw	r30, r16
    2706:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2708:	80 85       	ldd	r24, Z+8	; 0x08
    270a:	81 11       	cpse	r24, r1
    270c:	08 c0       	rjmp	.+16     	; 0x271e <xQueueReceive+0x142>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    270e:	0f 90       	pop	r0
    2710:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2712:	81 e0       	ldi	r24, 0x01	; 1
    2714:	dc cf       	rjmp	.-72     	; 0x26ce <xQueueReceive+0xf2>
			{
				if( xTicksToWait == ( TickType_t ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2716:	0f 90       	pop	r0
    2718:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    271a:	80 e0       	ldi	r24, 0x00	; 0
    271c:	d8 cf       	rjmp	.-80     	; 0x26ce <xQueueReceive+0xf2>
				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    271e:	c8 01       	movw	r24, r16
    2720:	08 96       	adiw	r24, 0x08	; 8
    2722:	0e 94 9f 1a 	call	0x353e	; 0x353e <xTaskRemoveFromEventList>
    2726:	88 23       	and	r24, r24
    2728:	91 f3       	breq	.-28     	; 0x270e <xQueueReceive+0x132>
					{
						queueYIELD_IF_USING_PREEMPTION();
    272a:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vPortYield>
    272e:	ef cf       	rjmp	.-34     	; 0x270e <xQueueReceive+0x132>
	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    2730:	f8 01       	movw	r30, r16
    2732:	84 8d       	ldd	r24, Z+28	; 0x1c
    2734:	88 23       	and	r24, r24
    2736:	09 f4       	brne	.+2      	; 0x273a <xQueueReceive+0x15e>
    2738:	6a cf       	rjmp	.-300    	; 0x260e <xQueueReceive+0x32>
    273a:	64 e0       	ldi	r22, 0x04	; 4
    273c:	75 e0       	ldi	r23, 0x05	; 5
    273e:	8b e8       	ldi	r24, 0x8B	; 139
    2740:	92 e2       	ldi	r25, 0x22	; 34
    2742:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    2746:	63 cf       	rjmp	.-314    	; 0x260e <xQueueReceive+0x32>
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    2748:	60 e0       	ldi	r22, 0x00	; 0
    274a:	75 e0       	ldi	r23, 0x05	; 5
    274c:	8b e8       	ldi	r24, 0x8B	; 139
    274e:	92 e2       	ldi	r25, 0x22	; 34
    2750:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    2754:	58 cf       	rjmp	.-336    	; 0x2606 <xQueueReceive+0x2a>

00002756 <xQueueSemaphoreTake>:
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    2756:	ef 92       	push	r14
    2758:	ff 92       	push	r15
    275a:	0f 93       	push	r16
    275c:	1f 93       	push	r17
    275e:	cf 93       	push	r28
    2760:	df 93       	push	r29
    2762:	cd b7       	in	r28, 0x3d	; 61
    2764:	de b7       	in	r29, 0x3e	; 62
    2766:	25 97       	sbiw	r28, 0x05	; 5
    2768:	cd bf       	out	0x3d, r28	; 61
    276a:	de bf       	out	0x3e, r29	; 62
    276c:	8c 01       	movw	r16, r24
    276e:	6c 83       	std	Y+4, r22	; 0x04
    2770:	7d 83       	std	Y+5, r23	; 0x05
#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
#endif

	/* Check the queue pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    2772:	89 2b       	or	r24, r25
    2774:	09 f4       	brne	.+2      	; 0x2778 <xQueueSemaphoreTake+0x22>
    2776:	94 c0       	rjmp	.+296    	; 0x28a0 <xQueueSemaphoreTake+0x14a>

	/* Check this really is a semaphore, in which case the item size will be
	0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    2778:	f8 01       	movw	r30, r16
    277a:	84 8d       	ldd	r24, Z+28	; 0x1c
    277c:	81 11       	cpse	r24, r1
    277e:	80 c0       	rjmp	.+256    	; 0x2880 <xQueueSemaphoreTake+0x12a>
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    2780:	20 e0       	ldi	r18, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2782:	78 01       	movw	r14, r16
    2784:	f1 e1       	ldi	r31, 0x11	; 17
    2786:	ef 0e       	add	r14, r31
    2788:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    278a:	0f b6       	in	r0, 0x3f	; 63
    278c:	f8 94       	cli
    278e:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2790:	f8 01       	movw	r30, r16
    2792:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2794:	81 11       	cpse	r24, r1
    2796:	67 c0       	rjmp	.+206    	; 0x2866 <xQueueSemaphoreTake+0x110>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2798:	8c 81       	ldd	r24, Y+4	; 0x04
    279a:	9d 81       	ldd	r25, Y+5	; 0x05
    279c:	89 2b       	or	r24, r25
    279e:	09 f4       	brne	.+2      	; 0x27a2 <xQueueSemaphoreTake+0x4c>
    27a0:	6b c0       	rjmp	.+214    	; 0x2878 <xQueueSemaphoreTake+0x122>
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    27a2:	22 23       	and	r18, r18
    27a4:	09 f4       	brne	.+2      	; 0x27a8 <xQueueSemaphoreTake+0x52>
    27a6:	56 c0       	rjmp	.+172    	; 0x2854 <xQueueSemaphoreTake+0xfe>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    27a8:	0f 90       	pop	r0
    27aa:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    27ac:	0e 94 6f 18 	call	0x30de	; 0x30de <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    27b0:	0f b6       	in	r0, 0x3f	; 63
    27b2:	f8 94       	cli
    27b4:	0f 92       	push	r0
    27b6:	f8 01       	movw	r30, r16
    27b8:	85 8d       	ldd	r24, Z+29	; 0x1d
    27ba:	8f 3f       	cpi	r24, 0xFF	; 255
    27bc:	09 f4       	brne	.+2      	; 0x27c0 <xQueueSemaphoreTake+0x6a>
    27be:	51 c0       	rjmp	.+162    	; 0x2862 <xQueueSemaphoreTake+0x10c>
    27c0:	f8 01       	movw	r30, r16
    27c2:	86 8d       	ldd	r24, Z+30	; 0x1e
    27c4:	8f 3f       	cpi	r24, 0xFF	; 255
    27c6:	09 f4       	brne	.+2      	; 0x27ca <xQueueSemaphoreTake+0x74>
    27c8:	4a c0       	rjmp	.+148    	; 0x285e <xQueueSemaphoreTake+0x108>
    27ca:	0f 90       	pop	r0
    27cc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    27ce:	be 01       	movw	r22, r28
    27d0:	6c 5f       	subi	r22, 0xFC	; 252
    27d2:	7f 4f       	sbci	r23, 0xFF	; 255
    27d4:	ce 01       	movw	r24, r28
    27d6:	01 96       	adiw	r24, 0x01	; 1
    27d8:	0e 94 01 1b 	call	0x3602	; 0x3602 <xTaskCheckForTimeOut>
    27dc:	81 11       	cpse	r24, r1
    27de:	22 c0       	rjmp	.+68     	; 0x2824 <xQueueSemaphoreTake+0xce>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    27e0:	0f b6       	in	r0, 0x3f	; 63
    27e2:	f8 94       	cli
    27e4:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    27e6:	f8 01       	movw	r30, r16
    27e8:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    27ea:	0f 90       	pop	r0
    27ec:	0f be       	out	0x3f, r0	; 63
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    27ee:	81 11       	cpse	r24, r1
    27f0:	12 c0       	rjmp	.+36     	; 0x2816 <xQueueSemaphoreTake+0xc0>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    27f2:	6c 81       	ldd	r22, Y+4	; 0x04
    27f4:	7d 81       	ldd	r23, Y+5	; 0x05
    27f6:	c7 01       	movw	r24, r14
    27f8:	0e 94 7f 1a 	call	0x34fe	; 0x34fe <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    27fc:	c8 01       	movw	r24, r16
    27fe:	0e 94 8d 10 	call	0x211a	; 0x211a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2802:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>
    2806:	88 23       	and	r24, r24
    2808:	11 f0       	breq	.+4      	; 0x280e <xQueueSemaphoreTake+0xb8>
    280a:	21 e0       	ldi	r18, 0x01	; 1
    280c:	be cf       	rjmp	.-132    	; 0x278a <xQueueSemaphoreTake+0x34>
				{
					portYIELD_WITHIN_API();
    280e:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vPortYield>
    2812:	21 e0       	ldi	r18, 0x01	; 1
    2814:	ba cf       	rjmp	.-140    	; 0x278a <xQueueSemaphoreTake+0x34>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    2816:	c8 01       	movw	r24, r16
    2818:	0e 94 8d 10 	call	0x211a	; 0x211a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    281c:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>
    2820:	21 e0       	ldi	r18, 0x01	; 1
    2822:	b3 cf       	rjmp	.-154    	; 0x278a <xQueueSemaphoreTake+0x34>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    2824:	c8 01       	movw	r24, r16
    2826:	0e 94 8d 10 	call	0x211a	; 0x211a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    282a:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    282e:	0f b6       	in	r0, 0x3f	; 63
    2830:	f8 94       	cli
    2832:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2834:	f8 01       	movw	r30, r16
    2836:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2838:	0f 90       	pop	r0
    283a:	0f be       	out	0x3f, r0	; 63

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    283c:	81 11       	cpse	r24, r1
    283e:	e5 cf       	rjmp	.-54     	; 0x280a <xQueueSemaphoreTake+0xb4>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    2840:	25 96       	adiw	r28, 0x05	; 5
    2842:	cd bf       	out	0x3d, r28	; 61
    2844:	de bf       	out	0x3e, r29	; 62
    2846:	df 91       	pop	r29
    2848:	cf 91       	pop	r28
    284a:	1f 91       	pop	r17
    284c:	0f 91       	pop	r16
    284e:	ff 90       	pop	r15
    2850:	ef 90       	pop	r14
    2852:	08 95       	ret
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2854:	ce 01       	movw	r24, r28
    2856:	01 96       	adiw	r24, 0x01	; 1
    2858:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <vTaskInternalSetTimeOutState>
    285c:	a5 cf       	rjmp	.-182    	; 0x27a8 <xQueueSemaphoreTake+0x52>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    285e:	16 8e       	std	Z+30, r1	; 0x1e
    2860:	b4 cf       	rjmp	.-152    	; 0x27ca <xQueueSemaphoreTake+0x74>
    2862:	15 8e       	std	Z+29, r1	; 0x1d
    2864:	ad cf       	rjmp	.-166    	; 0x27c0 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2866:	81 50       	subi	r24, 0x01	; 1
    2868:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    286a:	80 85       	ldd	r24, Z+8	; 0x08
    286c:	81 11       	cpse	r24, r1
    286e:	0f c0       	rjmp	.+30     	; 0x288e <xQueueSemaphoreTake+0x138>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2870:	0f 90       	pop	r0
    2872:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2874:	81 e0       	ldi	r24, 0x01	; 1
    2876:	e4 cf       	rjmp	.-56     	; 0x2840 <xQueueSemaphoreTake+0xea>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    2878:	0f 90       	pop	r0
    287a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    287c:	80 e0       	ldi	r24, 0x00	; 0
    287e:	e0 cf       	rjmp	.-64     	; 0x2840 <xQueueSemaphoreTake+0xea>
	/* Check the queue pointer is not NULL. */
	configASSERT( ( pxQueue ) );

	/* Check this really is a semaphore, in which case the item size will be
	0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    2880:	65 e9       	ldi	r22, 0x95	; 149
    2882:	75 e0       	ldi	r23, 0x05	; 5
    2884:	8b e8       	ldi	r24, 0x8B	; 139
    2886:	92 e2       	ldi	r25, 0x22	; 34
    2888:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    288c:	79 cf       	rjmp	.-270    	; 0x2780 <xQueueSemaphoreTake+0x2a>

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    288e:	c8 01       	movw	r24, r16
    2890:	08 96       	adiw	r24, 0x08	; 8
    2892:	0e 94 9f 1a 	call	0x353e	; 0x353e <xTaskRemoveFromEventList>
    2896:	88 23       	and	r24, r24
    2898:	59 f3       	breq	.-42     	; 0x2870 <xQueueSemaphoreTake+0x11a>
					{
						queueYIELD_IF_USING_PREEMPTION();
    289a:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vPortYield>
    289e:	e8 cf       	rjmp	.-48     	; 0x2870 <xQueueSemaphoreTake+0x11a>
#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
#endif

	/* Check the queue pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    28a0:	61 e9       	ldi	r22, 0x91	; 145
    28a2:	75 e0       	ldi	r23, 0x05	; 5
    28a4:	8b e8       	ldi	r24, 0x8B	; 139
    28a6:	92 e2       	ldi	r25, 0x22	; 34
    28a8:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    28ac:	65 cf       	rjmp	.-310    	; 0x2778 <xQueueSemaphoreTake+0x22>

000028ae <xQueuePeek>:
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    28ae:	cf 92       	push	r12
    28b0:	df 92       	push	r13
    28b2:	ef 92       	push	r14
    28b4:	ff 92       	push	r15
    28b6:	0f 93       	push	r16
    28b8:	1f 93       	push	r17
    28ba:	cf 93       	push	r28
    28bc:	df 93       	push	r29
    28be:	cd b7       	in	r28, 0x3d	; 61
    28c0:	de b7       	in	r29, 0x3e	; 62
    28c2:	25 97       	sbiw	r28, 0x05	; 5
    28c4:	cd bf       	out	0x3d, r28	; 61
    28c6:	de bf       	out	0x3e, r29	; 62
    28c8:	8c 01       	movw	r16, r24
    28ca:	6b 01       	movw	r12, r22
    28cc:	4c 83       	std	Y+4, r20	; 0x04
    28ce:	5d 83       	std	Y+5, r21	; 0x05
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    28d0:	89 2b       	or	r24, r25
    28d2:	09 f4       	brne	.+2      	; 0x28d6 <xQueuePeek+0x28>
    28d4:	a2 c0       	rjmp	.+324    	; 0x2a1a <xQueuePeek+0x16c>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    28d6:	c1 14       	cp	r12, r1
    28d8:	d1 04       	cpc	r13, r1
    28da:	09 f4       	brne	.+2      	; 0x28de <xQueuePeek+0x30>
    28dc:	92 c0       	rjmp	.+292    	; 0x2a02 <xQueuePeek+0x154>
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    28de:	20 e0       	ldi	r18, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    28e0:	78 01       	movw	r14, r16
    28e2:	f1 e1       	ldi	r31, 0x11	; 17
    28e4:	ef 0e       	add	r14, r31
    28e6:	f1 1c       	adc	r15, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    28e8:	0f b6       	in	r0, 0x3f	; 63
    28ea:	f8 94       	cli
    28ec:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    28ee:	f8 01       	movw	r30, r16
    28f0:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    28f2:	81 11       	cpse	r24, r1
    28f4:	69 c0       	rjmp	.+210    	; 0x29c8 <xQueuePeek+0x11a>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    28f6:	8c 81       	ldd	r24, Y+4	; 0x04
    28f8:	9d 81       	ldd	r25, Y+5	; 0x05
    28fa:	89 2b       	or	r24, r25
    28fc:	09 f4       	brne	.+2      	; 0x2900 <xQueuePeek+0x52>
    28fe:	74 c0       	rjmp	.+232    	; 0x29e8 <xQueuePeek+0x13a>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    2900:	22 23       	and	r18, r18
    2902:	09 f4       	brne	.+2      	; 0x2906 <xQueuePeek+0x58>
    2904:	58 c0       	rjmp	.+176    	; 0x29b6 <xQueuePeek+0x108>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2906:	0f 90       	pop	r0
    2908:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    290a:	0e 94 6f 18 	call	0x30de	; 0x30de <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    290e:	0f b6       	in	r0, 0x3f	; 63
    2910:	f8 94       	cli
    2912:	0f 92       	push	r0
    2914:	f8 01       	movw	r30, r16
    2916:	85 8d       	ldd	r24, Z+29	; 0x1d
    2918:	8f 3f       	cpi	r24, 0xFF	; 255
    291a:	09 f4       	brne	.+2      	; 0x291e <xQueuePeek+0x70>
    291c:	53 c0       	rjmp	.+166    	; 0x29c4 <xQueuePeek+0x116>
    291e:	f8 01       	movw	r30, r16
    2920:	86 8d       	ldd	r24, Z+30	; 0x1e
    2922:	8f 3f       	cpi	r24, 0xFF	; 255
    2924:	09 f4       	brne	.+2      	; 0x2928 <xQueuePeek+0x7a>
    2926:	4c c0       	rjmp	.+152    	; 0x29c0 <xQueuePeek+0x112>
    2928:	0f 90       	pop	r0
    292a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    292c:	be 01       	movw	r22, r28
    292e:	6c 5f       	subi	r22, 0xFC	; 252
    2930:	7f 4f       	sbci	r23, 0xFF	; 255
    2932:	ce 01       	movw	r24, r28
    2934:	01 96       	adiw	r24, 0x01	; 1
    2936:	0e 94 01 1b 	call	0x3602	; 0x3602 <xTaskCheckForTimeOut>
    293a:	81 11       	cpse	r24, r1
    293c:	22 c0       	rjmp	.+68     	; 0x2982 <xQueuePeek+0xd4>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    293e:	0f b6       	in	r0, 0x3f	; 63
    2940:	f8 94       	cli
    2942:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2944:	f8 01       	movw	r30, r16
    2946:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2948:	0f 90       	pop	r0
    294a:	0f be       	out	0x3f, r0	; 63
		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    294c:	81 11       	cpse	r24, r1
    294e:	12 c0       	rjmp	.+36     	; 0x2974 <xQueuePeek+0xc6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2950:	6c 81       	ldd	r22, Y+4	; 0x04
    2952:	7d 81       	ldd	r23, Y+5	; 0x05
    2954:	c7 01       	movw	r24, r14
    2956:	0e 94 7f 1a 	call	0x34fe	; 0x34fe <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    295a:	c8 01       	movw	r24, r16
    295c:	0e 94 8d 10 	call	0x211a	; 0x211a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2960:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>
    2964:	88 23       	and	r24, r24
    2966:	11 f0       	breq	.+4      	; 0x296c <xQueuePeek+0xbe>
    2968:	21 e0       	ldi	r18, 0x01	; 1
    296a:	be cf       	rjmp	.-132    	; 0x28e8 <xQueuePeek+0x3a>
				{
					portYIELD_WITHIN_API();
    296c:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vPortYield>
    2970:	21 e0       	ldi	r18, 0x01	; 1
    2972:	ba cf       	rjmp	.-140    	; 0x28e8 <xQueuePeek+0x3a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    2974:	c8 01       	movw	r24, r16
    2976:	0e 94 8d 10 	call	0x211a	; 0x211a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    297a:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>
    297e:	21 e0       	ldi	r18, 0x01	; 1
    2980:	b3 cf       	rjmp	.-154    	; 0x28e8 <xQueuePeek+0x3a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    2982:	c8 01       	movw	r24, r16
    2984:	0e 94 8d 10 	call	0x211a	; 0x211a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2988:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    298c:	0f b6       	in	r0, 0x3f	; 63
    298e:	f8 94       	cli
    2990:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2992:	f8 01       	movw	r30, r16
    2994:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2996:	0f 90       	pop	r0
    2998:	0f be       	out	0x3f, r0	; 63
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    299a:	81 11       	cpse	r24, r1
    299c:	e5 cf       	rjmp	.-54     	; 0x2968 <xQueuePeek+0xba>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    299e:	25 96       	adiw	r28, 0x05	; 5
    29a0:	cd bf       	out	0x3d, r28	; 61
    29a2:	de bf       	out	0x3e, r29	; 62
    29a4:	df 91       	pop	r29
    29a6:	cf 91       	pop	r28
    29a8:	1f 91       	pop	r17
    29aa:	0f 91       	pop	r16
    29ac:	ff 90       	pop	r15
    29ae:	ef 90       	pop	r14
    29b0:	df 90       	pop	r13
    29b2:	cf 90       	pop	r12
    29b4:	08 95       	ret
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    29b6:	ce 01       	movw	r24, r28
    29b8:	01 96       	adiw	r24, 0x01	; 1
    29ba:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <vTaskInternalSetTimeOutState>
    29be:	a3 cf       	rjmp	.-186    	; 0x2906 <xQueuePeek+0x58>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    29c0:	16 8e       	std	Z+30, r1	; 0x1e
    29c2:	b2 cf       	rjmp	.-156    	; 0x2928 <xQueuePeek+0x7a>
    29c4:	15 8e       	std	Z+29, r1	; 0x1d
    29c6:	ab cf       	rjmp	.-170    	; 0x291e <xQueuePeek+0x70>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    29c8:	e6 80       	ldd	r14, Z+6	; 0x06
    29ca:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    29cc:	b6 01       	movw	r22, r12
    29ce:	c8 01       	movw	r24, r16
    29d0:	0e 94 75 10 	call	0x20ea	; 0x20ea <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    29d4:	f8 01       	movw	r30, r16
    29d6:	e6 82       	std	Z+6, r14	; 0x06
    29d8:	f7 82       	std	Z+7, r15	; 0x07

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    29da:	81 89       	ldd	r24, Z+17	; 0x11
    29dc:	81 11       	cpse	r24, r1
    29de:	08 c0       	rjmp	.+16     	; 0x29f0 <xQueuePeek+0x142>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    29e0:	0f 90       	pop	r0
    29e2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    29e4:	81 e0       	ldi	r24, 0x01	; 1
    29e6:	db cf       	rjmp	.-74     	; 0x299e <xQueuePeek+0xf0>
			{
				if( xTicksToWait == ( TickType_t ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    29e8:	0f 90       	pop	r0
    29ea:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    29ec:	80 e0       	ldi	r24, 0x00	; 0
    29ee:	d7 cf       	rjmp	.-82     	; 0x299e <xQueuePeek+0xf0>

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    29f0:	c8 01       	movw	r24, r16
    29f2:	41 96       	adiw	r24, 0x11	; 17
    29f4:	0e 94 9f 1a 	call	0x353e	; 0x353e <xTaskRemoveFromEventList>
    29f8:	88 23       	and	r24, r24
    29fa:	91 f3       	breq	.-28     	; 0x29e0 <xQueuePeek+0x132>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    29fc:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vPortYield>
    2a00:	ef cf       	rjmp	.-34     	; 0x29e0 <xQueuePeek+0x132>
	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    2a02:	f8 01       	movw	r30, r16
    2a04:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a06:	88 23       	and	r24, r24
    2a08:	09 f4       	brne	.+2      	; 0x2a0c <xQueuePeek+0x15e>
    2a0a:	69 cf       	rjmp	.-302    	; 0x28de <xQueuePeek+0x30>
    2a0c:	6c e6       	ldi	r22, 0x6C	; 108
    2a0e:	76 e0       	ldi	r23, 0x06	; 6
    2a10:	8b e8       	ldi	r24, 0x8B	; 139
    2a12:	92 e2       	ldi	r25, 0x22	; 34
    2a14:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    2a18:	62 cf       	rjmp	.-316    	; 0x28de <xQueuePeek+0x30>
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
    2a1a:	68 e6       	ldi	r22, 0x68	; 104
    2a1c:	76 e0       	ldi	r23, 0x06	; 6
    2a1e:	8b e8       	ldi	r24, 0x8B	; 139
    2a20:	92 e2       	ldi	r25, 0x22	; 34
    2a22:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    2a26:	57 cf       	rjmp	.-338    	; 0x28d6 <xQueuePeek+0x28>

00002a28 <xQueueReceiveFromISR>:
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2a28:	cf 92       	push	r12
    2a2a:	df 92       	push	r13
    2a2c:	ef 92       	push	r14
    2a2e:	ff 92       	push	r15
    2a30:	0f 93       	push	r16
    2a32:	1f 93       	push	r17
    2a34:	cf 93       	push	r28
    2a36:	df 93       	push	r29
    2a38:	ec 01       	movw	r28, r24
    2a3a:	7b 01       	movw	r14, r22
    2a3c:	6a 01       	movw	r12, r20
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
    2a3e:	89 2b       	or	r24, r25
    2a40:	b9 f1       	breq	.+110    	; 0x2ab0 <xQueueReceiveFromISR+0x88>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    2a42:	e1 14       	cp	r14, r1
    2a44:	f1 04       	cpc	r15, r1
    2a46:	d1 f0       	breq	.+52     	; 0x2a7c <xQueueReceiveFromISR+0x54>
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2a48:	1a 8d       	ldd	r17, Y+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2a4a:	11 11       	cpse	r17, r1
    2a4c:	0a c0       	rjmp	.+20     	; 0x2a62 <xQueueReceiveFromISR+0x3a>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    2a4e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2a50:	df 91       	pop	r29
    2a52:	cf 91       	pop	r28
    2a54:	1f 91       	pop	r17
    2a56:	0f 91       	pop	r16
    2a58:	ff 90       	pop	r15
    2a5a:	ef 90       	pop	r14
    2a5c:	df 90       	pop	r13
    2a5e:	cf 90       	pop	r12
    2a60:	08 95       	ret
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    2a62:	0d 8d       	ldd	r16, Y+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2a64:	b7 01       	movw	r22, r14
    2a66:	ce 01       	movw	r24, r28
    2a68:	0e 94 75 10 	call	0x20ea	; 0x20ea <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2a6c:	11 50       	subi	r17, 0x01	; 1
    2a6e:	1a 8f       	std	Y+26, r17	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    2a70:	0f 3f       	cpi	r16, 0xFF	; 255
    2a72:	71 f0       	breq	.+28     	; 0x2a90 <xQueueReceiveFromISR+0x68>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2a74:	0f 5f       	subi	r16, 0xFF	; 255
    2a76:	0d 8f       	std	Y+29, r16	; 0x1d
			}

			xReturn = pdPASS;
    2a78:	81 e0       	ldi	r24, 0x01	; 1
    2a7a:	ea cf       	rjmp	.-44     	; 0x2a50 <xQueueReceiveFromISR+0x28>
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    2a7c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2a7e:	88 23       	and	r24, r24
    2a80:	19 f3       	breq	.-58     	; 0x2a48 <xQueueReceiveFromISR+0x20>
    2a82:	6c ef       	ldi	r22, 0xFC	; 252
    2a84:	76 e0       	ldi	r23, 0x06	; 6
    2a86:	8b e8       	ldi	r24, 0x8B	; 139
    2a88:	92 e2       	ldi	r25, 0x22	; 34
    2a8a:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    2a8e:	dc cf       	rjmp	.-72     	; 0x2a48 <xQueueReceiveFromISR+0x20>
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2a90:	88 85       	ldd	r24, Y+8	; 0x08
    2a92:	88 23       	and	r24, r24
    2a94:	89 f3       	breq	.-30     	; 0x2a78 <xQueueReceiveFromISR+0x50>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2a96:	ce 01       	movw	r24, r28
    2a98:	08 96       	adiw	r24, 0x08	; 8
    2a9a:	0e 94 9f 1a 	call	0x353e	; 0x353e <xTaskRemoveFromEventList>
    2a9e:	88 23       	and	r24, r24
    2aa0:	59 f3       	breq	.-42     	; 0x2a78 <xQueueReceiveFromISR+0x50>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2aa2:	c1 14       	cp	r12, r1
    2aa4:	d1 04       	cpc	r13, r1
    2aa6:	41 f3       	breq	.-48     	; 0x2a78 <xQueueReceiveFromISR+0x50>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2aa8:	81 e0       	ldi	r24, 0x01	; 1
    2aaa:	f6 01       	movw	r30, r12
    2aac:	80 83       	st	Z, r24
    2aae:	d0 cf       	rjmp	.-96     	; 0x2a50 <xQueueReceiveFromISR+0x28>
{
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
    2ab0:	6b ef       	ldi	r22, 0xFB	; 251
    2ab2:	76 e0       	ldi	r23, 0x06	; 6
    2ab4:	8b e8       	ldi	r24, 0x8B	; 139
    2ab6:	92 e2       	ldi	r25, 0x22	; 34
    2ab8:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    2abc:	c2 cf       	rjmp	.-124    	; 0x2a42 <xQueueReceiveFromISR+0x1a>

00002abe <prvIdleTask>:
	TCB_t * pxTCB;

		if( xTask != NULL )
		{
			pxTCB = xTask;
			pxTCB->uxTaskNumber = uxHandle;
    2abe:	20 c0       	rjmp	.+64     	; 0x2b00 <prvIdleTask+0x42>
    2ac0:	0f b6       	in	r0, 0x3f	; 63
    2ac2:	f8 94       	cli
    2ac4:	0f 92       	push	r0
    2ac6:	e0 91 45 68 	lds	r30, 0x6845	; 0x806845 <xTasksWaitingTermination+0x5>
    2aca:	f0 91 46 68 	lds	r31, 0x6846	; 0x806846 <xTasksWaitingTermination+0x6>
    2ace:	c6 81       	ldd	r28, Z+6	; 0x06
    2ad0:	d7 81       	ldd	r29, Z+7	; 0x07
    2ad2:	ce 01       	movw	r24, r28
    2ad4:	02 96       	adiw	r24, 0x02	; 2
    2ad6:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <uxListRemove>
    2ada:	80 91 35 68 	lds	r24, 0x6835	; 0x806835 <uxCurrentNumberOfTasks>
    2ade:	81 50       	subi	r24, 0x01	; 1
    2ae0:	80 93 35 68 	sts	0x6835, r24	; 0x806835 <uxCurrentNumberOfTasks>
    2ae4:	80 91 3f 68 	lds	r24, 0x683F	; 0x80683f <uxDeletedTasksWaitingCleanUp>
    2ae8:	81 50       	subi	r24, 0x01	; 1
    2aea:	80 93 3f 68 	sts	0x683F, r24	; 0x80683f <uxDeletedTasksWaitingCleanUp>
    2aee:	0f 90       	pop	r0
    2af0:	0f be       	out	0x3f, r0	; 63
    2af2:	8f 89       	ldd	r24, Y+23	; 0x17
    2af4:	98 8d       	ldd	r25, Y+24	; 0x18
    2af6:	0e 94 96 0d 	call	0x1b2c	; 0x1b2c <vPortFree>
    2afa:	ce 01       	movw	r24, r28
    2afc:	0e 94 96 0d 	call	0x1b2c	; 0x1b2c <vPortFree>
    2b00:	80 91 3f 68 	lds	r24, 0x683F	; 0x80683f <uxDeletedTasksWaitingCleanUp>
    2b04:	81 11       	cpse	r24, r1
    2b06:	dc cf       	rjmp	.-72     	; 0x2ac0 <prvIdleTask+0x2>
    2b08:	80 91 68 68 	lds	r24, 0x6868	; 0x806868 <pxReadyTasksLists>
    2b0c:	82 30       	cpi	r24, 0x02	; 2
    2b0e:	10 f0       	brcs	.+4      	; 0x2b14 <prvIdleTask+0x56>
    2b10:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vPortYield>
    2b14:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <vApplicationIdleHook>
    2b18:	f3 cf       	rjmp	.-26     	; 0x2b00 <prvIdleTask+0x42>

00002b1a <prvResetNextTaskUnblockTime.part.0>:
    2b1a:	e0 91 54 68 	lds	r30, 0x6854	; 0x806854 <pxDelayedTaskList>
    2b1e:	f0 91 55 68 	lds	r31, 0x6855	; 0x806855 <pxDelayedTaskList+0x1>
    2b22:	05 80       	ldd	r0, Z+5	; 0x05
    2b24:	f6 81       	ldd	r31, Z+6	; 0x06
    2b26:	e0 2d       	mov	r30, r0
    2b28:	06 80       	ldd	r0, Z+6	; 0x06
    2b2a:	f7 81       	ldd	r31, Z+7	; 0x07
    2b2c:	e0 2d       	mov	r30, r0
    2b2e:	82 81       	ldd	r24, Z+2	; 0x02
    2b30:	93 81       	ldd	r25, Z+3	; 0x03
    2b32:	80 93 2b 68 	sts	0x682B, r24	; 0x80682b <xNextTaskUnblockTime>
    2b36:	90 93 2c 68 	sts	0x682C, r25	; 0x80682c <xNextTaskUnblockTime+0x1>
    2b3a:	08 95       	ret

00002b3c <prvAddCurrentTaskToDelayedList>:
    2b3c:	ff 92       	push	r15
    2b3e:	0f 93       	push	r16
    2b40:	1f 93       	push	r17
    2b42:	cf 93       	push	r28
    2b44:	df 93       	push	r29
    2b46:	ec 01       	movw	r28, r24
    2b48:	f6 2e       	mov	r15, r22
    2b4a:	00 91 33 68 	lds	r16, 0x6833	; 0x806833 <xTickCount>
    2b4e:	10 91 34 68 	lds	r17, 0x6834	; 0x806834 <xTickCount+0x1>
    2b52:	80 91 8c 68 	lds	r24, 0x688C	; 0x80688c <pxCurrentTCB>
    2b56:	90 91 8d 68 	lds	r25, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    2b5a:	02 96       	adiw	r24, 0x02	; 2
    2b5c:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <uxListRemove>
    2b60:	cf 3f       	cpi	r28, 0xFF	; 255
    2b62:	8f ef       	ldi	r24, 0xFF	; 255
    2b64:	d8 07       	cpc	r29, r24
    2b66:	a9 f1       	breq	.+106    	; 0x2bd2 <prvAddCurrentTaskToDelayedList+0x96>
    2b68:	c0 0f       	add	r28, r16
    2b6a:	d1 1f       	adc	r29, r17
    2b6c:	e0 91 8c 68 	lds	r30, 0x688C	; 0x80688c <pxCurrentTCB>
    2b70:	f0 91 8d 68 	lds	r31, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    2b74:	c2 83       	std	Z+2, r28	; 0x02
    2b76:	d3 83       	std	Z+3, r29	; 0x03
    2b78:	60 91 8c 68 	lds	r22, 0x688C	; 0x80688c <pxCurrentTCB>
    2b7c:	70 91 8d 68 	lds	r23, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    2b80:	c0 17       	cp	r28, r16
    2b82:	d1 07       	cpc	r29, r17
    2b84:	c8 f0       	brcs	.+50     	; 0x2bb8 <prvAddCurrentTaskToDelayedList+0x7c>
    2b86:	80 91 54 68 	lds	r24, 0x6854	; 0x806854 <pxDelayedTaskList>
    2b8a:	90 91 55 68 	lds	r25, 0x6855	; 0x806855 <pxDelayedTaskList+0x1>
    2b8e:	6e 5f       	subi	r22, 0xFE	; 254
    2b90:	7f 4f       	sbci	r23, 0xFF	; 255
    2b92:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <vListInsert>
    2b96:	80 91 2b 68 	lds	r24, 0x682B	; 0x80682b <xNextTaskUnblockTime>
    2b9a:	90 91 2c 68 	lds	r25, 0x682C	; 0x80682c <xNextTaskUnblockTime+0x1>
    2b9e:	c8 17       	cp	r28, r24
    2ba0:	d9 07       	cpc	r29, r25
    2ba2:	20 f4       	brcc	.+8      	; 0x2bac <prvAddCurrentTaskToDelayedList+0x70>
    2ba4:	c0 93 2b 68 	sts	0x682B, r28	; 0x80682b <xNextTaskUnblockTime>
    2ba8:	d0 93 2c 68 	sts	0x682C, r29	; 0x80682c <xNextTaskUnblockTime+0x1>
    2bac:	df 91       	pop	r29
    2bae:	cf 91       	pop	r28
    2bb0:	1f 91       	pop	r17
    2bb2:	0f 91       	pop	r16
    2bb4:	ff 90       	pop	r15
    2bb6:	08 95       	ret
    2bb8:	80 91 52 68 	lds	r24, 0x6852	; 0x806852 <pxOverflowDelayedTaskList>
    2bbc:	90 91 53 68 	lds	r25, 0x6853	; 0x806853 <pxOverflowDelayedTaskList+0x1>
    2bc0:	6e 5f       	subi	r22, 0xFE	; 254
    2bc2:	7f 4f       	sbci	r23, 0xFF	; 255
    2bc4:	df 91       	pop	r29
    2bc6:	cf 91       	pop	r28
    2bc8:	1f 91       	pop	r17
    2bca:	0f 91       	pop	r16
    2bcc:	ff 90       	pop	r15
    2bce:	0c 94 f9 0d 	jmp	0x1bf2	; 0x1bf2 <vListInsert>
    2bd2:	ff 20       	and	r15, r15
    2bd4:	49 f2       	breq	.-110    	; 0x2b68 <prvAddCurrentTaskToDelayedList+0x2c>
    2bd6:	60 91 8c 68 	lds	r22, 0x688C	; 0x80688c <pxCurrentTCB>
    2bda:	70 91 8d 68 	lds	r23, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    2bde:	6e 5f       	subi	r22, 0xFE	; 254
    2be0:	7f 4f       	sbci	r23, 0xFF	; 255
    2be2:	86 e3       	ldi	r24, 0x36	; 54
    2be4:	98 e6       	ldi	r25, 0x68	; 104
    2be6:	df 91       	pop	r29
    2be8:	cf 91       	pop	r28
    2bea:	1f 91       	pop	r17
    2bec:	0f 91       	pop	r16
    2bee:	ff 90       	pop	r15
    2bf0:	0c 94 d8 0d 	jmp	0x1bb0	; 0x1bb0 <vListInsertEnd>

00002bf4 <vTaskSwitchContext.part.5>:
    2bf4:	0f 93       	push	r16
    2bf6:	1f 93       	push	r17
    2bf8:	cf 93       	push	r28
    2bfa:	10 92 2f 68 	sts	0x682F, r1	; 0x80682f <xYieldPending>
    2bfe:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2c02:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2c06:	80 91 a2 68 	lds	r24, 0x68A2	; 0x8068a2 <StatsTimer>
    2c0a:	90 91 a3 68 	lds	r25, 0x68A3	; 0x8068a3 <StatsTimer+0x1>
    2c0e:	a0 91 a4 68 	lds	r26, 0x68A4	; 0x8068a4 <StatsTimer+0x2>
    2c12:	b0 91 a5 68 	lds	r27, 0x68A5	; 0x8068a5 <StatsTimer+0x3>
    2c16:	82 0f       	add	r24, r18
    2c18:	93 1f       	adc	r25, r19
    2c1a:	a1 1d       	adc	r26, r1
    2c1c:	b1 1d       	adc	r27, r1
    2c1e:	00 91 24 68 	lds	r16, 0x6824	; 0x806824 <ulTaskSwitchedInTime>
    2c22:	10 91 25 68 	lds	r17, 0x6825	; 0x806825 <ulTaskSwitchedInTime+0x1>
    2c26:	20 91 26 68 	lds	r18, 0x6826	; 0x806826 <ulTaskSwitchedInTime+0x2>
    2c2a:	30 91 27 68 	lds	r19, 0x6827	; 0x806827 <ulTaskSwitchedInTime+0x3>
    2c2e:	08 17       	cp	r16, r24
    2c30:	19 07       	cpc	r17, r25
    2c32:	2a 07       	cpc	r18, r26
    2c34:	3b 07       	cpc	r19, r27
    2c36:	a0 f4       	brcc	.+40     	; 0x2c60 <vTaskSwitchContext.part.5+0x6c>
    2c38:	e0 91 8c 68 	lds	r30, 0x688C	; 0x80688c <pxCurrentTCB>
    2c3c:	f0 91 8d 68 	lds	r31, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    2c40:	43 a1       	ldd	r20, Z+35	; 0x23
    2c42:	54 a1       	ldd	r21, Z+36	; 0x24
    2c44:	65 a1       	ldd	r22, Z+37	; 0x25
    2c46:	76 a1       	ldd	r23, Z+38	; 0x26
    2c48:	40 1b       	sub	r20, r16
    2c4a:	51 0b       	sbc	r21, r17
    2c4c:	62 0b       	sbc	r22, r18
    2c4e:	73 0b       	sbc	r23, r19
    2c50:	48 0f       	add	r20, r24
    2c52:	59 1f       	adc	r21, r25
    2c54:	6a 1f       	adc	r22, r26
    2c56:	7b 1f       	adc	r23, r27
    2c58:	43 a3       	std	Z+35, r20	; 0x23
    2c5a:	54 a3       	std	Z+36, r21	; 0x24
    2c5c:	65 a3       	std	Z+37, r22	; 0x25
    2c5e:	76 a3       	std	Z+38, r23	; 0x26
    2c60:	80 93 24 68 	sts	0x6824, r24	; 0x806824 <ulTaskSwitchedInTime>
    2c64:	90 93 25 68 	sts	0x6825, r25	; 0x806825 <ulTaskSwitchedInTime+0x1>
    2c68:	a0 93 26 68 	sts	0x6826, r26	; 0x806826 <ulTaskSwitchedInTime+0x2>
    2c6c:	b0 93 27 68 	sts	0x6827, r27	; 0x806827 <ulTaskSwitchedInTime+0x3>
    2c70:	e0 91 8c 68 	lds	r30, 0x688C	; 0x80688c <pxCurrentTCB>
    2c74:	f0 91 8d 68 	lds	r31, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    2c78:	07 88       	ldd	r0, Z+23	; 0x17
    2c7a:	f0 8d       	ldd	r31, Z+24	; 0x18
    2c7c:	e0 2d       	mov	r30, r0
    2c7e:	80 81       	ld	r24, Z
    2c80:	91 81       	ldd	r25, Z+1	; 0x01
    2c82:	a2 81       	ldd	r26, Z+2	; 0x02
    2c84:	b3 81       	ldd	r27, Z+3	; 0x03
    2c86:	85 3a       	cpi	r24, 0xA5	; 165
    2c88:	95 4a       	sbci	r25, 0xA5	; 165
    2c8a:	a5 4a       	sbci	r26, 0xA5	; 165
    2c8c:	b5 4a       	sbci	r27, 0xA5	; 165
    2c8e:	09 f4       	brne	.+2      	; 0x2c92 <vTaskSwitchContext.part.5+0x9e>
    2c90:	4c c0       	rjmp	.+152    	; 0x2d2a <vTaskSwitchContext.part.5+0x136>
    2c92:	60 91 8c 68 	lds	r22, 0x688C	; 0x80688c <pxCurrentTCB>
    2c96:	70 91 8d 68 	lds	r23, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    2c9a:	80 91 8c 68 	lds	r24, 0x688C	; 0x80688c <pxCurrentTCB>
    2c9e:	90 91 8d 68 	lds	r25, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    2ca2:	67 5e       	subi	r22, 0xE7	; 231
    2ca4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ca6:	0e 94 0c 1d 	call	0x3a18	; 0x3a18 <vApplicationStackOverflowHook>
    2caa:	c0 91 32 68 	lds	r28, 0x6832	; 0x806832 <uxTopReadyPriority>
    2cae:	8c 2f       	mov	r24, r28
    2cb0:	90 e0       	ldi	r25, 0x00	; 0
    2cb2:	9c 01       	movw	r18, r24
    2cb4:	22 0f       	add	r18, r18
    2cb6:	33 1f       	adc	r19, r19
    2cb8:	22 0f       	add	r18, r18
    2cba:	33 1f       	adc	r19, r19
    2cbc:	22 0f       	add	r18, r18
    2cbe:	33 1f       	adc	r19, r19
    2cc0:	f9 01       	movw	r30, r18
    2cc2:	e8 0f       	add	r30, r24
    2cc4:	f9 1f       	adc	r31, r25
    2cc6:	e8 59       	subi	r30, 0x98	; 152
    2cc8:	f7 49       	sbci	r31, 0x97	; 151
    2cca:	40 81       	ld	r20, Z
    2ccc:	41 11       	cpse	r20, r1
    2cce:	0c c0       	rjmp	.+24     	; 0x2ce8 <vTaskSwitchContext.part.5+0xf4>
    2cd0:	cc 23       	and	r28, r28
    2cd2:	11 f0       	breq	.+4      	; 0x2cd8 <vTaskSwitchContext.part.5+0xe4>
    2cd4:	c1 50       	subi	r28, 0x01	; 1
    2cd6:	eb cf       	rjmp	.-42     	; 0x2cae <vTaskSwitchContext.part.5+0xba>
    2cd8:	6c e8       	ldi	r22, 0x8C	; 140
    2cda:	7b e0       	ldi	r23, 0x0B	; 11
    2cdc:	8f e9       	ldi	r24, 0x9F	; 159
    2cde:	92 e2       	ldi	r25, 0x22	; 34
    2ce0:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    2ce4:	c1 50       	subi	r28, 0x01	; 1
    2ce6:	e3 cf       	rjmp	.-58     	; 0x2cae <vTaskSwitchContext.part.5+0xba>
    2ce8:	82 0f       	add	r24, r18
    2cea:	93 1f       	adc	r25, r19
    2cec:	dc 01       	movw	r26, r24
    2cee:	a8 59       	subi	r26, 0x98	; 152
    2cf0:	b7 49       	sbci	r27, 0x97	; 151
    2cf2:	11 96       	adiw	r26, 0x01	; 1
    2cf4:	ed 91       	ld	r30, X+
    2cf6:	fc 91       	ld	r31, X
    2cf8:	12 97       	sbiw	r26, 0x02	; 2
    2cfa:	02 80       	ldd	r0, Z+2	; 0x02
    2cfc:	f3 81       	ldd	r31, Z+3	; 0x03
    2cfe:	e0 2d       	mov	r30, r0
    2d00:	11 96       	adiw	r26, 0x01	; 1
    2d02:	ed 93       	st	X+, r30
    2d04:	fc 93       	st	X, r31
    2d06:	12 97       	sbiw	r26, 0x02	; 2
    2d08:	85 59       	subi	r24, 0x95	; 149
    2d0a:	97 49       	sbci	r25, 0x97	; 151
    2d0c:	e8 17       	cp	r30, r24
    2d0e:	f9 07       	cpc	r31, r25
    2d10:	59 f1       	breq	.+86     	; 0x2d68 <vTaskSwitchContext.part.5+0x174>
    2d12:	86 81       	ldd	r24, Z+6	; 0x06
    2d14:	97 81       	ldd	r25, Z+7	; 0x07
    2d16:	80 93 8c 68 	sts	0x688C, r24	; 0x80688c <pxCurrentTCB>
    2d1a:	90 93 8d 68 	sts	0x688D, r25	; 0x80688d <pxCurrentTCB+0x1>
    2d1e:	c0 93 32 68 	sts	0x6832, r28	; 0x806832 <uxTopReadyPriority>
    2d22:	cf 91       	pop	r28
    2d24:	1f 91       	pop	r17
    2d26:	0f 91       	pop	r16
    2d28:	08 95       	ret
    2d2a:	84 81       	ldd	r24, Z+4	; 0x04
    2d2c:	95 81       	ldd	r25, Z+5	; 0x05
    2d2e:	a6 81       	ldd	r26, Z+6	; 0x06
    2d30:	b7 81       	ldd	r27, Z+7	; 0x07
    2d32:	85 3a       	cpi	r24, 0xA5	; 165
    2d34:	95 4a       	sbci	r25, 0xA5	; 165
    2d36:	a5 4a       	sbci	r26, 0xA5	; 165
    2d38:	b5 4a       	sbci	r27, 0xA5	; 165
    2d3a:	09 f0       	breq	.+2      	; 0x2d3e <vTaskSwitchContext.part.5+0x14a>
    2d3c:	aa cf       	rjmp	.-172    	; 0x2c92 <vTaskSwitchContext.part.5+0x9e>
    2d3e:	80 85       	ldd	r24, Z+8	; 0x08
    2d40:	91 85       	ldd	r25, Z+9	; 0x09
    2d42:	a2 85       	ldd	r26, Z+10	; 0x0a
    2d44:	b3 85       	ldd	r27, Z+11	; 0x0b
    2d46:	85 3a       	cpi	r24, 0xA5	; 165
    2d48:	95 4a       	sbci	r25, 0xA5	; 165
    2d4a:	a5 4a       	sbci	r26, 0xA5	; 165
    2d4c:	b5 4a       	sbci	r27, 0xA5	; 165
    2d4e:	09 f0       	breq	.+2      	; 0x2d52 <vTaskSwitchContext.part.5+0x15e>
    2d50:	a0 cf       	rjmp	.-192    	; 0x2c92 <vTaskSwitchContext.part.5+0x9e>
    2d52:	84 85       	ldd	r24, Z+12	; 0x0c
    2d54:	95 85       	ldd	r25, Z+13	; 0x0d
    2d56:	a6 85       	ldd	r26, Z+14	; 0x0e
    2d58:	b7 85       	ldd	r27, Z+15	; 0x0f
    2d5a:	85 3a       	cpi	r24, 0xA5	; 165
    2d5c:	95 4a       	sbci	r25, 0xA5	; 165
    2d5e:	a5 4a       	sbci	r26, 0xA5	; 165
    2d60:	b5 4a       	sbci	r27, 0xA5	; 165
    2d62:	09 f0       	breq	.+2      	; 0x2d66 <vTaskSwitchContext.part.5+0x172>
    2d64:	96 cf       	rjmp	.-212    	; 0x2c92 <vTaskSwitchContext.part.5+0x9e>
    2d66:	a1 cf       	rjmp	.-190    	; 0x2caa <vTaskSwitchContext.part.5+0xb6>
    2d68:	02 80       	ldd	r0, Z+2	; 0x02
    2d6a:	f3 81       	ldd	r31, Z+3	; 0x03
    2d6c:	e0 2d       	mov	r30, r0
    2d6e:	11 96       	adiw	r26, 0x01	; 1
    2d70:	ed 93       	st	X+, r30
    2d72:	fc 93       	st	X, r31
    2d74:	12 97       	sbiw	r26, 0x02	; 2
    2d76:	cd cf       	rjmp	.-102    	; 0x2d12 <vTaskSwitchContext.part.5+0x11e>

00002d78 <xTaskCreate>:
    2d78:	5f 92       	push	r5
    2d7a:	6f 92       	push	r6
    2d7c:	7f 92       	push	r7
    2d7e:	8f 92       	push	r8
    2d80:	9f 92       	push	r9
    2d82:	af 92       	push	r10
    2d84:	bf 92       	push	r11
    2d86:	cf 92       	push	r12
    2d88:	df 92       	push	r13
    2d8a:	ef 92       	push	r14
    2d8c:	ff 92       	push	r15
    2d8e:	0f 93       	push	r16
    2d90:	1f 93       	push	r17
    2d92:	cf 93       	push	r28
    2d94:	df 93       	push	r29
    2d96:	4c 01       	movw	r8, r24
    2d98:	eb 01       	movw	r28, r22
    2d9a:	5a 01       	movw	r10, r20
    2d9c:	39 01       	movw	r6, r18
    2d9e:	50 2e       	mov	r5, r16
    2da0:	ca 01       	movw	r24, r20
    2da2:	0e 94 f7 0c 	call	0x19ee	; 0x19ee <pvPortMalloc>
    2da6:	8c 01       	movw	r16, r24
    2da8:	89 2b       	or	r24, r25
    2daa:	09 f4       	brne	.+2      	; 0x2dae <xTaskCreate+0x36>
    2dac:	d6 c0       	rjmp	.+428    	; 0x2f5a <xTaskCreate+0x1e2>
    2dae:	8c e2       	ldi	r24, 0x2C	; 44
    2db0:	90 e0       	ldi	r25, 0x00	; 0
    2db2:	0e 94 f7 0c 	call	0x19ee	; 0x19ee <pvPortMalloc>
    2db6:	6c 01       	movw	r12, r24
    2db8:	00 97       	sbiw	r24, 0x00	; 0
    2dba:	09 f4       	brne	.+2      	; 0x2dbe <xTaskCreate+0x46>
    2dbc:	cb c0       	rjmp	.+406    	; 0x2f54 <xTaskCreate+0x1dc>
    2dbe:	dc 01       	movw	r26, r24
    2dc0:	57 96       	adiw	r26, 0x17	; 23
    2dc2:	0d 93       	st	X+, r16
    2dc4:	1c 93       	st	X, r17
    2dc6:	58 97       	sbiw	r26, 0x18	; 24
    2dc8:	20 97       	sbiw	r28, 0x00	; 0
    2dca:	09 f4       	brne	.+2      	; 0x2dce <xTaskCreate+0x56>
    2dcc:	c8 c0       	rjmp	.+400    	; 0x2f5e <xTaskCreate+0x1e6>
    2dce:	c8 01       	movw	r24, r16
    2dd0:	a5 01       	movw	r20, r10
    2dd2:	65 ea       	ldi	r22, 0xA5	; 165
    2dd4:	70 e0       	ldi	r23, 0x00	; 0
    2dd6:	0e 94 b6 2a 	call	0x556c	; 0x556c <memset>
    2dda:	f1 e0       	ldi	r31, 0x01	; 1
    2ddc:	af 1a       	sub	r10, r31
    2dde:	b1 08       	sbc	r11, r1
    2de0:	d6 01       	movw	r26, r12
    2de2:	57 96       	adiw	r26, 0x17	; 23
    2de4:	8d 91       	ld	r24, X+
    2de6:	9c 91       	ld	r25, X
    2de8:	58 97       	sbiw	r26, 0x18	; 24
    2dea:	a8 0e       	add	r10, r24
    2dec:	b9 1e       	adc	r11, r25
    2dee:	f6 01       	movw	r30, r12
    2df0:	79 96       	adiw	r30, 0x19	; 25
    2df2:	9e 01       	movw	r18, r28
    2df4:	28 5f       	subi	r18, 0xF8	; 248
    2df6:	3f 4f       	sbci	r19, 0xFF	; 255
    2df8:	de 01       	movw	r26, r28
    2dfa:	89 91       	ld	r24, Y+
    2dfc:	81 93       	st	Z+, r24
    2dfe:	8c 91       	ld	r24, X
    2e00:	88 23       	and	r24, r24
    2e02:	19 f0       	breq	.+6      	; 0x2e0a <xTaskCreate+0x92>
    2e04:	c2 17       	cp	r28, r18
    2e06:	d3 07       	cpc	r29, r19
    2e08:	b9 f7       	brne	.-18     	; 0x2df8 <xTaskCreate+0x80>
    2e0a:	f6 01       	movw	r30, r12
    2e0c:	10 a2       	std	Z+32, r1	; 0x20
    2e0e:	05 2d       	mov	r16, r5
    2e10:	04 30       	cpi	r16, 0x04	; 4
    2e12:	08 f0       	brcs	.+2      	; 0x2e16 <xTaskCreate+0x9e>
    2e14:	99 c0       	rjmp	.+306    	; 0x2f48 <xTaskCreate+0x1d0>
    2e16:	d6 01       	movw	r26, r12
    2e18:	56 96       	adiw	r26, 0x16	; 22
    2e1a:	0c 93       	st	X, r16
    2e1c:	e6 01       	movw	r28, r12
    2e1e:	22 96       	adiw	r28, 0x02	; 2
    2e20:	ce 01       	movw	r24, r28
    2e22:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialiseItem>
    2e26:	c6 01       	movw	r24, r12
    2e28:	0c 96       	adiw	r24, 0x0c	; 12
    2e2a:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <vListInitialiseItem>
    2e2e:	f6 01       	movw	r30, r12
    2e30:	c0 86       	std	Z+8, r12	; 0x08
    2e32:	d1 86       	std	Z+9, r13	; 0x09
    2e34:	84 e0       	ldi	r24, 0x04	; 4
    2e36:	90 e0       	ldi	r25, 0x00	; 0
    2e38:	80 1b       	sub	r24, r16
    2e3a:	91 09       	sbc	r25, r1
    2e3c:	84 87       	std	Z+12, r24	; 0x0c
    2e3e:	95 87       	std	Z+13, r25	; 0x0d
    2e40:	c2 8a       	std	Z+18, r12	; 0x12
    2e42:	d3 8a       	std	Z+19, r13	; 0x13
    2e44:	13 a2       	std	Z+35, r1	; 0x23
    2e46:	14 a2       	std	Z+36, r1	; 0x24
    2e48:	15 a2       	std	Z+37, r1	; 0x25
    2e4a:	16 a2       	std	Z+38, r1	; 0x26
    2e4c:	17 a2       	std	Z+39, r1	; 0x27
    2e4e:	10 a6       	std	Z+40, r1	; 0x28
    2e50:	11 a6       	std	Z+41, r1	; 0x29
    2e52:	12 a6       	std	Z+42, r1	; 0x2a
    2e54:	13 a6       	std	Z+43, r1	; 0x2b
    2e56:	a3 01       	movw	r20, r6
    2e58:	b4 01       	movw	r22, r8
    2e5a:	c5 01       	movw	r24, r10
    2e5c:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <pxPortInitialiseStack>
    2e60:	d6 01       	movw	r26, r12
    2e62:	8d 93       	st	X+, r24
    2e64:	9c 93       	st	X, r25
    2e66:	e1 14       	cp	r14, r1
    2e68:	f1 04       	cpc	r15, r1
    2e6a:	19 f0       	breq	.+6      	; 0x2e72 <xTaskCreate+0xfa>
    2e6c:	f7 01       	movw	r30, r14
    2e6e:	c0 82       	st	Z, r12
    2e70:	d1 82       	std	Z+1, r13	; 0x01
    2e72:	0f b6       	in	r0, 0x3f	; 63
    2e74:	f8 94       	cli
    2e76:	0f 92       	push	r0
    2e78:	80 91 35 68 	lds	r24, 0x6835	; 0x806835 <uxCurrentNumberOfTasks>
    2e7c:	8f 5f       	subi	r24, 0xFF	; 255
    2e7e:	80 93 35 68 	sts	0x6835, r24	; 0x806835 <uxCurrentNumberOfTasks>
    2e82:	80 91 8c 68 	lds	r24, 0x688C	; 0x80688c <pxCurrentTCB>
    2e86:	90 91 8d 68 	lds	r25, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    2e8a:	89 2b       	or	r24, r25
    2e8c:	99 f0       	breq	.+38     	; 0x2eb4 <xTaskCreate+0x13c>
    2e8e:	80 91 31 68 	lds	r24, 0x6831	; 0x806831 <xSchedulerRunning>
    2e92:	81 11       	cpse	r24, r1
    2e94:	18 c0       	rjmp	.+48     	; 0x2ec6 <xTaskCreate+0x14e>
    2e96:	e0 91 8c 68 	lds	r30, 0x688C	; 0x80688c <pxCurrentTCB>
    2e9a:	f0 91 8d 68 	lds	r31, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    2e9e:	d6 01       	movw	r26, r12
    2ea0:	56 96       	adiw	r26, 0x16	; 22
    2ea2:	8c 91       	ld	r24, X
    2ea4:	96 89       	ldd	r25, Z+22	; 0x16
    2ea6:	89 17       	cp	r24, r25
    2ea8:	88 f0       	brcs	.+34     	; 0x2ecc <xTaskCreate+0x154>
    2eaa:	c0 92 8c 68 	sts	0x688C, r12	; 0x80688c <pxCurrentTCB>
    2eae:	d0 92 8d 68 	sts	0x688D, r13	; 0x80688d <pxCurrentTCB+0x1>
    2eb2:	0c c0       	rjmp	.+24     	; 0x2ecc <xTaskCreate+0x154>
    2eb4:	c0 92 8c 68 	sts	0x688C, r12	; 0x80688c <pxCurrentTCB>
    2eb8:	d0 92 8d 68 	sts	0x688D, r13	; 0x80688d <pxCurrentTCB+0x1>
    2ebc:	80 91 35 68 	lds	r24, 0x6835	; 0x806835 <uxCurrentNumberOfTasks>
    2ec0:	81 30       	cpi	r24, 0x01	; 1
    2ec2:	09 f4       	brne	.+2      	; 0x2ec6 <xTaskCreate+0x14e>
    2ec4:	56 c0       	rjmp	.+172    	; 0x2f72 <xTaskCreate+0x1fa>
    2ec6:	d6 01       	movw	r26, r12
    2ec8:	56 96       	adiw	r26, 0x16	; 22
    2eca:	8c 91       	ld	r24, X
    2ecc:	90 91 2d 68 	lds	r25, 0x682D	; 0x80682d <uxTaskNumber>
    2ed0:	9f 5f       	subi	r25, 0xFF	; 255
    2ed2:	90 93 2d 68 	sts	0x682D, r25	; 0x80682d <uxTaskNumber>
    2ed6:	f6 01       	movw	r30, r12
    2ed8:	91 a3       	std	Z+33, r25	; 0x21
    2eda:	90 91 32 68 	lds	r25, 0x6832	; 0x806832 <uxTopReadyPriority>
    2ede:	98 17       	cp	r25, r24
    2ee0:	80 f1       	brcs	.+96     	; 0x2f42 <xTaskCreate+0x1ca>
    2ee2:	90 e0       	ldi	r25, 0x00	; 0
    2ee4:	9c 01       	movw	r18, r24
    2ee6:	22 0f       	add	r18, r18
    2ee8:	33 1f       	adc	r19, r19
    2eea:	22 0f       	add	r18, r18
    2eec:	33 1f       	adc	r19, r19
    2eee:	22 0f       	add	r18, r18
    2ef0:	33 1f       	adc	r19, r19
    2ef2:	82 0f       	add	r24, r18
    2ef4:	93 1f       	adc	r25, r19
    2ef6:	be 01       	movw	r22, r28
    2ef8:	88 59       	subi	r24, 0x98	; 152
    2efa:	97 49       	sbci	r25, 0x97	; 151
    2efc:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <vListInsertEnd>
    2f00:	0f 90       	pop	r0
    2f02:	0f be       	out	0x3f, r0	; 63
    2f04:	80 91 31 68 	lds	r24, 0x6831	; 0x806831 <xSchedulerRunning>
    2f08:	88 23       	and	r24, r24
    2f0a:	51 f0       	breq	.+20     	; 0x2f20 <xTaskCreate+0x1a8>
    2f0c:	e0 91 8c 68 	lds	r30, 0x688C	; 0x80688c <pxCurrentTCB>
    2f10:	f0 91 8d 68 	lds	r31, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    2f14:	96 89       	ldd	r25, Z+22	; 0x16
    2f16:	d6 01       	movw	r26, r12
    2f18:	56 96       	adiw	r26, 0x16	; 22
    2f1a:	8c 91       	ld	r24, X
    2f1c:	98 17       	cp	r25, r24
    2f1e:	b0 f0       	brcs	.+44     	; 0x2f4c <xTaskCreate+0x1d4>
    2f20:	81 e0       	ldi	r24, 0x01	; 1
    2f22:	df 91       	pop	r29
    2f24:	cf 91       	pop	r28
    2f26:	1f 91       	pop	r17
    2f28:	0f 91       	pop	r16
    2f2a:	ff 90       	pop	r15
    2f2c:	ef 90       	pop	r14
    2f2e:	df 90       	pop	r13
    2f30:	cf 90       	pop	r12
    2f32:	bf 90       	pop	r11
    2f34:	af 90       	pop	r10
    2f36:	9f 90       	pop	r9
    2f38:	8f 90       	pop	r8
    2f3a:	7f 90       	pop	r7
    2f3c:	6f 90       	pop	r6
    2f3e:	5f 90       	pop	r5
    2f40:	08 95       	ret
    2f42:	80 93 32 68 	sts	0x6832, r24	; 0x806832 <uxTopReadyPriority>
    2f46:	cd cf       	rjmp	.-102    	; 0x2ee2 <xTaskCreate+0x16a>
    2f48:	03 e0       	ldi	r16, 0x03	; 3
    2f4a:	65 cf       	rjmp	.-310    	; 0x2e16 <xTaskCreate+0x9e>
    2f4c:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vPortYield>
    2f50:	81 e0       	ldi	r24, 0x01	; 1
    2f52:	e7 cf       	rjmp	.-50     	; 0x2f22 <xTaskCreate+0x1aa>
    2f54:	c8 01       	movw	r24, r16
    2f56:	0e 94 96 0d 	call	0x1b2c	; 0x1b2c <vPortFree>
    2f5a:	8f ef       	ldi	r24, 0xFF	; 255
    2f5c:	e2 cf       	rjmp	.-60     	; 0x2f22 <xTaskCreate+0x1aa>
    2f5e:	60 e6       	ldi	r22, 0x60	; 96
    2f60:	73 e0       	ldi	r23, 0x03	; 3
    2f62:	8f e9       	ldi	r24, 0x9F	; 159
    2f64:	92 e2       	ldi	r25, 0x22	; 34
    2f66:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    2f6a:	f6 01       	movw	r30, r12
    2f6c:	87 89       	ldd	r24, Z+23	; 0x17
    2f6e:	90 8d       	ldd	r25, Z+24	; 0x18
    2f70:	2f cf       	rjmp	.-418    	; 0x2dd0 <xTaskCreate+0x58>
    2f72:	88 e6       	ldi	r24, 0x68	; 104
    2f74:	98 e6       	ldi	r25, 0x68	; 104
    2f76:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <vListInitialise>
    2f7a:	81 e7       	ldi	r24, 0x71	; 113
    2f7c:	98 e6       	ldi	r25, 0x68	; 104
    2f7e:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <vListInitialise>
    2f82:	8a e7       	ldi	r24, 0x7A	; 122
    2f84:	98 e6       	ldi	r25, 0x68	; 104
    2f86:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <vListInitialise>
    2f8a:	83 e8       	ldi	r24, 0x83	; 131
    2f8c:	98 e6       	ldi	r25, 0x68	; 104
    2f8e:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <vListInitialise>
    2f92:	8f e5       	ldi	r24, 0x5F	; 95
    2f94:	98 e6       	ldi	r25, 0x68	; 104
    2f96:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <vListInitialise>
    2f9a:	86 e5       	ldi	r24, 0x56	; 86
    2f9c:	98 e6       	ldi	r25, 0x68	; 104
    2f9e:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <vListInitialise>
    2fa2:	89 e4       	ldi	r24, 0x49	; 73
    2fa4:	98 e6       	ldi	r25, 0x68	; 104
    2fa6:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <vListInitialise>
    2faa:	80 e4       	ldi	r24, 0x40	; 64
    2fac:	98 e6       	ldi	r25, 0x68	; 104
    2fae:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <vListInitialise>
    2fb2:	86 e3       	ldi	r24, 0x36	; 54
    2fb4:	98 e6       	ldi	r25, 0x68	; 104
    2fb6:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <vListInitialise>
    2fba:	8f e5       	ldi	r24, 0x5F	; 95
    2fbc:	98 e6       	ldi	r25, 0x68	; 104
    2fbe:	80 93 54 68 	sts	0x6854, r24	; 0x806854 <pxDelayedTaskList>
    2fc2:	90 93 55 68 	sts	0x6855, r25	; 0x806855 <pxDelayedTaskList+0x1>
    2fc6:	86 e5       	ldi	r24, 0x56	; 86
    2fc8:	98 e6       	ldi	r25, 0x68	; 104
    2fca:	80 93 52 68 	sts	0x6852, r24	; 0x806852 <pxOverflowDelayedTaskList>
    2fce:	90 93 53 68 	sts	0x6853, r25	; 0x806853 <pxOverflowDelayedTaskList+0x1>
    2fd2:	f6 01       	movw	r30, r12
    2fd4:	86 89       	ldd	r24, Z+22	; 0x16
    2fd6:	7a cf       	rjmp	.-268    	; 0x2ecc <xTaskCreate+0x154>

00002fd8 <eTaskGetState>:
    2fd8:	cf 93       	push	r28
    2fda:	df 93       	push	r29
    2fdc:	ec 01       	movw	r28, r24
    2fde:	89 2b       	or	r24, r25
    2fe0:	09 f4       	brne	.+2      	; 0x2fe4 <eTaskGetState+0xc>
    2fe2:	3a c0       	rjmp	.+116    	; 0x3058 <eTaskGetState+0x80>
    2fe4:	80 91 8c 68 	lds	r24, 0x688C	; 0x80688c <pxCurrentTCB>
    2fe8:	90 91 8d 68 	lds	r25, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    2fec:	c8 17       	cp	r28, r24
    2fee:	d9 07       	cpc	r29, r25
    2ff0:	79 f1       	breq	.+94     	; 0x3050 <eTaskGetState+0x78>
    2ff2:	0f b6       	in	r0, 0x3f	; 63
    2ff4:	f8 94       	cli
    2ff6:	0f 92       	push	r0
    2ff8:	8a 85       	ldd	r24, Y+10	; 0x0a
    2ffa:	9b 85       	ldd	r25, Y+11	; 0x0b
    2ffc:	20 91 54 68 	lds	r18, 0x6854	; 0x806854 <pxDelayedTaskList>
    3000:	30 91 55 68 	lds	r19, 0x6855	; 0x806855 <pxDelayedTaskList+0x1>
    3004:	40 91 52 68 	lds	r20, 0x6852	; 0x806852 <pxOverflowDelayedTaskList>
    3008:	50 91 53 68 	lds	r21, 0x6853	; 0x806853 <pxOverflowDelayedTaskList+0x1>
    300c:	0f 90       	pop	r0
    300e:	0f be       	out	0x3f, r0	; 63
    3010:	82 17       	cp	r24, r18
    3012:	93 07       	cpc	r25, r19
    3014:	a9 f0       	breq	.+42     	; 0x3040 <eTaskGetState+0x68>
    3016:	84 17       	cp	r24, r20
    3018:	95 07       	cpc	r25, r21
    301a:	91 f0       	breq	.+36     	; 0x3040 <eTaskGetState+0x68>
    301c:	28 e6       	ldi	r18, 0x68	; 104
    301e:	86 33       	cpi	r24, 0x36	; 54
    3020:	92 07       	cpc	r25, r18
    3022:	51 f0       	breq	.+20     	; 0x3038 <eTaskGetState+0x60>
    3024:	28 e6       	ldi	r18, 0x68	; 104
    3026:	80 34       	cpi	r24, 0x40	; 64
    3028:	92 07       	cpc	r25, r18
    302a:	71 f0       	breq	.+28     	; 0x3048 <eTaskGetState+0x70>
    302c:	89 2b       	or	r24, r25
    302e:	61 f0       	breq	.+24     	; 0x3048 <eTaskGetState+0x70>
    3030:	81 e0       	ldi	r24, 0x01	; 1
    3032:	df 91       	pop	r29
    3034:	cf 91       	pop	r28
    3036:	08 95       	ret
    3038:	8c 89       	ldd	r24, Y+20	; 0x14
    303a:	9d 89       	ldd	r25, Y+21	; 0x15
    303c:	89 2b       	or	r24, r25
    303e:	99 f0       	breq	.+38     	; 0x3066 <eTaskGetState+0x8e>
    3040:	82 e0       	ldi	r24, 0x02	; 2
    3042:	df 91       	pop	r29
    3044:	cf 91       	pop	r28
    3046:	08 95       	ret
    3048:	84 e0       	ldi	r24, 0x04	; 4
    304a:	df 91       	pop	r29
    304c:	cf 91       	pop	r28
    304e:	08 95       	ret
    3050:	80 e0       	ldi	r24, 0x00	; 0
    3052:	df 91       	pop	r29
    3054:	cf 91       	pop	r28
    3056:	08 95       	ret
    3058:	6c e4       	ldi	r22, 0x4C	; 76
    305a:	75 e0       	ldi	r23, 0x05	; 5
    305c:	8f e9       	ldi	r24, 0x9F	; 159
    305e:	92 e2       	ldi	r25, 0x22	; 34
    3060:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    3064:	bf cf       	rjmp	.-130    	; 0x2fe4 <eTaskGetState+0xc>
    3066:	8b a5       	ldd	r24, Y+43	; 0x2b
    3068:	81 30       	cpi	r24, 0x01	; 1
    306a:	51 f3       	breq	.-44     	; 0x3040 <eTaskGetState+0x68>
    306c:	83 e0       	ldi	r24, 0x03	; 3
    306e:	e1 cf       	rjmp	.-62     	; 0x3032 <eTaskGetState+0x5a>

00003070 <vTaskStartScheduler>:
    3070:	ef 92       	push	r14
    3072:	ff 92       	push	r15
    3074:	0f 93       	push	r16
    3076:	89 e2       	ldi	r24, 0x29	; 41
    3078:	e8 2e       	mov	r14, r24
    307a:	88 e6       	ldi	r24, 0x68	; 104
    307c:	f8 2e       	mov	r15, r24
    307e:	00 e0       	ldi	r16, 0x00	; 0
    3080:	20 e0       	ldi	r18, 0x00	; 0
    3082:	30 e0       	ldi	r19, 0x00	; 0
    3084:	40 e0       	ldi	r20, 0x00	; 0
    3086:	51 e0       	ldi	r21, 0x01	; 1
    3088:	63 eb       	ldi	r22, 0xB3	; 179
    308a:	72 e2       	ldi	r23, 0x22	; 34
    308c:	8f e5       	ldi	r24, 0x5F	; 95
    308e:	95 e1       	ldi	r25, 0x15	; 21
    3090:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <xTaskCreate>
    3094:	81 30       	cpi	r24, 0x01	; 1
    3096:	79 f0       	breq	.+30     	; 0x30b6 <vTaskStartScheduler+0x46>
    3098:	8f 3f       	cpi	r24, 0xFF	; 255
    309a:	21 f0       	breq	.+8      	; 0x30a4 <vTaskStartScheduler+0x34>
    309c:	0f 91       	pop	r16
    309e:	ff 90       	pop	r15
    30a0:	ef 90       	pop	r14
    30a2:	08 95       	ret
    30a4:	67 e0       	ldi	r22, 0x07	; 7
    30a6:	78 e0       	ldi	r23, 0x08	; 8
    30a8:	8f e9       	ldi	r24, 0x9F	; 159
    30aa:	92 e2       	ldi	r25, 0x22	; 34
    30ac:	0f 91       	pop	r16
    30ae:	ff 90       	pop	r15
    30b0:	ef 90       	pop	r14
    30b2:	0c 94 27 1d 	jmp	0x3a4e	; 0x3a4e <vAssertCalled>
    30b6:	f8 94       	cli
    30b8:	2f ef       	ldi	r18, 0xFF	; 255
    30ba:	3f ef       	ldi	r19, 0xFF	; 255
    30bc:	20 93 2b 68 	sts	0x682B, r18	; 0x80682b <xNextTaskUnblockTime>
    30c0:	30 93 2c 68 	sts	0x682C, r19	; 0x80682c <xNextTaskUnblockTime+0x1>
    30c4:	80 93 31 68 	sts	0x6831, r24	; 0x806831 <xSchedulerRunning>
    30c8:	10 92 33 68 	sts	0x6833, r1	; 0x806833 <xTickCount>
    30cc:	10 92 34 68 	sts	0x6834, r1	; 0x806834 <xTickCount+0x1>
    30d0:	0e 94 19 10 	call	0x2032	; 0x2032 <vConfigureTimerForRunTimeStats>
    30d4:	0f 91       	pop	r16
    30d6:	ff 90       	pop	r15
    30d8:	ef 90       	pop	r14
    30da:	0c 94 be 0e 	jmp	0x1d7c	; 0x1d7c <xPortStartScheduler>

000030de <vTaskSuspendAll>:
    30de:	80 91 28 68 	lds	r24, 0x6828	; 0x806828 <uxSchedulerSuspended>
    30e2:	8f 5f       	subi	r24, 0xFF	; 255
    30e4:	80 93 28 68 	sts	0x6828, r24	; 0x806828 <uxSchedulerSuspended>
    30e8:	08 95       	ret

000030ea <xTaskGetTickCount>:
    30ea:	0f b6       	in	r0, 0x3f	; 63
    30ec:	f8 94       	cli
    30ee:	0f 92       	push	r0
    30f0:	80 91 33 68 	lds	r24, 0x6833	; 0x806833 <xTickCount>
    30f4:	90 91 34 68 	lds	r25, 0x6834	; 0x806834 <xTickCount+0x1>
    30f8:	0f 90       	pop	r0
    30fa:	0f be       	out	0x3f, r0	; 63
    30fc:	08 95       	ret

000030fe <xTaskGetIdleTaskHandle>:
    30fe:	80 91 29 68 	lds	r24, 0x6829	; 0x806829 <xIdleTaskHandle>
    3102:	90 91 2a 68 	lds	r25, 0x682A	; 0x80682a <xIdleTaskHandle+0x1>
    3106:	00 97       	sbiw	r24, 0x00	; 0
    3108:	09 f0       	breq	.+2      	; 0x310c <xTaskGetIdleTaskHandle+0xe>
    310a:	08 95       	ret
    310c:	6a ee       	ldi	r22, 0xEA	; 234
    310e:	79 e0       	ldi	r23, 0x09	; 9
    3110:	8f e9       	ldi	r24, 0x9F	; 159
    3112:	92 e2       	ldi	r25, 0x22	; 34
    3114:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    3118:	80 91 29 68 	lds	r24, 0x6829	; 0x806829 <xIdleTaskHandle>
    311c:	90 91 2a 68 	lds	r25, 0x682A	; 0x80682a <xIdleTaskHandle+0x1>
    3120:	08 95       	ret

00003122 <xTaskIncrementTick>:
    3122:	df 92       	push	r13
    3124:	ef 92       	push	r14
    3126:	ff 92       	push	r15
    3128:	0f 93       	push	r16
    312a:	1f 93       	push	r17
    312c:	cf 93       	push	r28
    312e:	df 93       	push	r29
    3130:	80 91 28 68 	lds	r24, 0x6828	; 0x806828 <uxSchedulerSuspended>
    3134:	81 11       	cpse	r24, r1
    3136:	b9 c0       	rjmp	.+370    	; 0x32aa <xTaskIncrementTick+0x188>
    3138:	e0 90 33 68 	lds	r14, 0x6833	; 0x806833 <xTickCount>
    313c:	f0 90 34 68 	lds	r15, 0x6834	; 0x806834 <xTickCount+0x1>
    3140:	8f ef       	ldi	r24, 0xFF	; 255
    3142:	e8 1a       	sub	r14, r24
    3144:	f8 0a       	sbc	r15, r24
    3146:	e0 92 33 68 	sts	0x6833, r14	; 0x806833 <xTickCount>
    314a:	f0 92 34 68 	sts	0x6834, r15	; 0x806834 <xTickCount+0x1>
    314e:	e1 14       	cp	r14, r1
    3150:	f1 04       	cpc	r15, r1
    3152:	49 f5       	brne	.+82     	; 0x31a6 <xTaskIncrementTick+0x84>
    3154:	e0 91 54 68 	lds	r30, 0x6854	; 0x806854 <pxDelayedTaskList>
    3158:	f0 91 55 68 	lds	r31, 0x6855	; 0x806855 <pxDelayedTaskList+0x1>
    315c:	80 81       	ld	r24, Z
    315e:	81 11       	cpse	r24, r1
    3160:	ab c0       	rjmp	.+342    	; 0x32b8 <xTaskIncrementTick+0x196>
    3162:	80 91 54 68 	lds	r24, 0x6854	; 0x806854 <pxDelayedTaskList>
    3166:	90 91 55 68 	lds	r25, 0x6855	; 0x806855 <pxDelayedTaskList+0x1>
    316a:	20 91 52 68 	lds	r18, 0x6852	; 0x806852 <pxOverflowDelayedTaskList>
    316e:	30 91 53 68 	lds	r19, 0x6853	; 0x806853 <pxOverflowDelayedTaskList+0x1>
    3172:	20 93 54 68 	sts	0x6854, r18	; 0x806854 <pxDelayedTaskList>
    3176:	30 93 55 68 	sts	0x6855, r19	; 0x806855 <pxDelayedTaskList+0x1>
    317a:	80 93 52 68 	sts	0x6852, r24	; 0x806852 <pxOverflowDelayedTaskList>
    317e:	90 93 53 68 	sts	0x6853, r25	; 0x806853 <pxOverflowDelayedTaskList+0x1>
    3182:	80 91 2e 68 	lds	r24, 0x682E	; 0x80682e <xNumOfOverflows>
    3186:	8f 5f       	subi	r24, 0xFF	; 255
    3188:	80 93 2e 68 	sts	0x682E, r24	; 0x80682e <xNumOfOverflows>
    318c:	e0 91 54 68 	lds	r30, 0x6854	; 0x806854 <pxDelayedTaskList>
    3190:	f0 91 55 68 	lds	r31, 0x6855	; 0x806855 <pxDelayedTaskList+0x1>
    3194:	80 81       	ld	r24, Z
    3196:	81 11       	cpse	r24, r1
    3198:	96 c0       	rjmp	.+300    	; 0x32c6 <xTaskIncrementTick+0x1a4>
    319a:	8f ef       	ldi	r24, 0xFF	; 255
    319c:	9f ef       	ldi	r25, 0xFF	; 255
    319e:	80 93 2b 68 	sts	0x682B, r24	; 0x80682b <xNextTaskUnblockTime>
    31a2:	90 93 2c 68 	sts	0x682C, r25	; 0x80682c <xNextTaskUnblockTime+0x1>
    31a6:	80 91 2b 68 	lds	r24, 0x682B	; 0x80682b <xNextTaskUnblockTime>
    31aa:	90 91 2c 68 	lds	r25, 0x682C	; 0x80682c <xNextTaskUnblockTime+0x1>
    31ae:	d1 2c       	mov	r13, r1
    31b0:	e8 16       	cp	r14, r24
    31b2:	f9 06       	cpc	r15, r25
    31b4:	08 f4       	brcc	.+2      	; 0x31b8 <xTaskIncrementTick+0x96>
    31b6:	53 c0       	rjmp	.+166    	; 0x325e <xTaskIncrementTick+0x13c>
    31b8:	e0 91 54 68 	lds	r30, 0x6854	; 0x806854 <pxDelayedTaskList>
    31bc:	f0 91 55 68 	lds	r31, 0x6855	; 0x806855 <pxDelayedTaskList+0x1>
    31c0:	80 81       	ld	r24, Z
    31c2:	88 23       	and	r24, r24
    31c4:	09 f4       	brne	.+2      	; 0x31c8 <xTaskIncrementTick+0xa6>
    31c6:	45 c0       	rjmp	.+138    	; 0x3252 <xTaskIncrementTick+0x130>
    31c8:	e0 91 54 68 	lds	r30, 0x6854	; 0x806854 <pxDelayedTaskList>
    31cc:	f0 91 55 68 	lds	r31, 0x6855	; 0x806855 <pxDelayedTaskList+0x1>
    31d0:	05 80       	ldd	r0, Z+5	; 0x05
    31d2:	f6 81       	ldd	r31, Z+6	; 0x06
    31d4:	e0 2d       	mov	r30, r0
    31d6:	c6 81       	ldd	r28, Z+6	; 0x06
    31d8:	d7 81       	ldd	r29, Z+7	; 0x07
    31da:	8a 81       	ldd	r24, Y+2	; 0x02
    31dc:	9b 81       	ldd	r25, Y+3	; 0x03
    31de:	e8 16       	cp	r14, r24
    31e0:	f9 06       	cpc	r15, r25
    31e2:	08 f4       	brcc	.+2      	; 0x31e6 <xTaskIncrementTick+0xc4>
    31e4:	73 c0       	rjmp	.+230    	; 0x32cc <xTaskIncrementTick+0x1aa>
    31e6:	8e 01       	movw	r16, r28
    31e8:	0e 5f       	subi	r16, 0xFE	; 254
    31ea:	1f 4f       	sbci	r17, 0xFF	; 255
    31ec:	c8 01       	movw	r24, r16
    31ee:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <uxListRemove>
    31f2:	8c 89       	ldd	r24, Y+20	; 0x14
    31f4:	9d 89       	ldd	r25, Y+21	; 0x15
    31f6:	89 2b       	or	r24, r25
    31f8:	21 f0       	breq	.+8      	; 0x3202 <xTaskIncrementTick+0xe0>
    31fa:	ce 01       	movw	r24, r28
    31fc:	0c 96       	adiw	r24, 0x0c	; 12
    31fe:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <uxListRemove>
    3202:	8e 89       	ldd	r24, Y+22	; 0x16
    3204:	90 91 32 68 	lds	r25, 0x6832	; 0x806832 <uxTopReadyPriority>
    3208:	98 17       	cp	r25, r24
    320a:	10 f4       	brcc	.+4      	; 0x3210 <xTaskIncrementTick+0xee>
    320c:	80 93 32 68 	sts	0x6832, r24	; 0x806832 <uxTopReadyPriority>
    3210:	90 e0       	ldi	r25, 0x00	; 0
    3212:	9c 01       	movw	r18, r24
    3214:	22 0f       	add	r18, r18
    3216:	33 1f       	adc	r19, r19
    3218:	22 0f       	add	r18, r18
    321a:	33 1f       	adc	r19, r19
    321c:	22 0f       	add	r18, r18
    321e:	33 1f       	adc	r19, r19
    3220:	82 0f       	add	r24, r18
    3222:	93 1f       	adc	r25, r19
    3224:	b8 01       	movw	r22, r16
    3226:	88 59       	subi	r24, 0x98	; 152
    3228:	97 49       	sbci	r25, 0x97	; 151
    322a:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <vListInsertEnd>
    322e:	e0 91 8c 68 	lds	r30, 0x688C	; 0x80688c <pxCurrentTCB>
    3232:	f0 91 8d 68 	lds	r31, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    3236:	9e 89       	ldd	r25, Y+22	; 0x16
    3238:	86 89       	ldd	r24, Z+22	; 0x16
    323a:	98 17       	cp	r25, r24
    323c:	08 f4       	brcc	.+2      	; 0x3240 <xTaskIncrementTick+0x11e>
    323e:	bc cf       	rjmp	.-136    	; 0x31b8 <xTaskIncrementTick+0x96>
    3240:	dd 24       	eor	r13, r13
    3242:	d3 94       	inc	r13
    3244:	e0 91 54 68 	lds	r30, 0x6854	; 0x806854 <pxDelayedTaskList>
    3248:	f0 91 55 68 	lds	r31, 0x6855	; 0x806855 <pxDelayedTaskList+0x1>
    324c:	80 81       	ld	r24, Z
    324e:	81 11       	cpse	r24, r1
    3250:	bb cf       	rjmp	.-138    	; 0x31c8 <xTaskIncrementTick+0xa6>
    3252:	8f ef       	ldi	r24, 0xFF	; 255
    3254:	9f ef       	ldi	r25, 0xFF	; 255
    3256:	80 93 2b 68 	sts	0x682B, r24	; 0x80682b <xNextTaskUnblockTime>
    325a:	90 93 2c 68 	sts	0x682C, r25	; 0x80682c <xNextTaskUnblockTime+0x1>
    325e:	e0 91 8c 68 	lds	r30, 0x688C	; 0x80688c <pxCurrentTCB>
    3262:	f0 91 8d 68 	lds	r31, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    3266:	86 89       	ldd	r24, Z+22	; 0x16
    3268:	90 e0       	ldi	r25, 0x00	; 0
    326a:	fc 01       	movw	r30, r24
    326c:	ee 0f       	add	r30, r30
    326e:	ff 1f       	adc	r31, r31
    3270:	ee 0f       	add	r30, r30
    3272:	ff 1f       	adc	r31, r31
    3274:	ee 0f       	add	r30, r30
    3276:	ff 1f       	adc	r31, r31
    3278:	8e 0f       	add	r24, r30
    327a:	9f 1f       	adc	r25, r31
    327c:	fc 01       	movw	r30, r24
    327e:	e8 59       	subi	r30, 0x98	; 152
    3280:	f7 49       	sbci	r31, 0x97	; 151
    3282:	80 81       	ld	r24, Z
    3284:	82 30       	cpi	r24, 0x02	; 2
    3286:	10 f0       	brcs	.+4      	; 0x328c <xTaskIncrementTick+0x16a>
    3288:	dd 24       	eor	r13, r13
    328a:	d3 94       	inc	r13
    328c:	80 91 2f 68 	lds	r24, 0x682F	; 0x80682f <xYieldPending>
    3290:	88 23       	and	r24, r24
    3292:	11 f0       	breq	.+4      	; 0x3298 <xTaskIncrementTick+0x176>
    3294:	dd 24       	eor	r13, r13
    3296:	d3 94       	inc	r13
    3298:	8d 2d       	mov	r24, r13
    329a:	df 91       	pop	r29
    329c:	cf 91       	pop	r28
    329e:	1f 91       	pop	r17
    32a0:	0f 91       	pop	r16
    32a2:	ff 90       	pop	r15
    32a4:	ef 90       	pop	r14
    32a6:	df 90       	pop	r13
    32a8:	08 95       	ret
    32aa:	80 91 30 68 	lds	r24, 0x6830	; 0x806830 <uxPendedTicks>
    32ae:	8f 5f       	subi	r24, 0xFF	; 255
    32b0:	80 93 30 68 	sts	0x6830, r24	; 0x806830 <uxPendedTicks>
    32b4:	d1 2c       	mov	r13, r1
    32b6:	ea cf       	rjmp	.-44     	; 0x328c <xTaskIncrementTick+0x16a>
    32b8:	66 e6       	ldi	r22, 0x66	; 102
    32ba:	7a e0       	ldi	r23, 0x0A	; 10
    32bc:	8f e9       	ldi	r24, 0x9F	; 159
    32be:	92 e2       	ldi	r25, 0x22	; 34
    32c0:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    32c4:	4e cf       	rjmp	.-356    	; 0x3162 <xTaskIncrementTick+0x40>
    32c6:	0e 94 8d 15 	call	0x2b1a	; 0x2b1a <prvResetNextTaskUnblockTime.part.0>
    32ca:	6d cf       	rjmp	.-294    	; 0x31a6 <xTaskIncrementTick+0x84>
    32cc:	80 93 2b 68 	sts	0x682B, r24	; 0x80682b <xNextTaskUnblockTime>
    32d0:	90 93 2c 68 	sts	0x682C, r25	; 0x80682c <xNextTaskUnblockTime+0x1>
    32d4:	c4 cf       	rjmp	.-120    	; 0x325e <xTaskIncrementTick+0x13c>

000032d6 <xTaskResumeAll>:
    32d6:	ff 92       	push	r15
    32d8:	0f 93       	push	r16
    32da:	1f 93       	push	r17
    32dc:	cf 93       	push	r28
    32de:	df 93       	push	r29
    32e0:	80 91 28 68 	lds	r24, 0x6828	; 0x806828 <uxSchedulerSuspended>
    32e4:	88 23       	and	r24, r24
    32e6:	09 f4       	brne	.+2      	; 0x32ea <xTaskResumeAll+0x14>
    32e8:	77 c0       	rjmp	.+238    	; 0x33d8 <xTaskResumeAll+0x102>
    32ea:	0f b6       	in	r0, 0x3f	; 63
    32ec:	f8 94       	cli
    32ee:	0f 92       	push	r0
    32f0:	80 91 28 68 	lds	r24, 0x6828	; 0x806828 <uxSchedulerSuspended>
    32f4:	81 50       	subi	r24, 0x01	; 1
    32f6:	80 93 28 68 	sts	0x6828, r24	; 0x806828 <uxSchedulerSuspended>
    32fa:	80 91 28 68 	lds	r24, 0x6828	; 0x806828 <uxSchedulerSuspended>
    32fe:	81 11       	cpse	r24, r1
    3300:	62 c0       	rjmp	.+196    	; 0x33c6 <xTaskResumeAll+0xf0>
    3302:	80 91 35 68 	lds	r24, 0x6835	; 0x806835 <uxCurrentNumberOfTasks>
    3306:	88 23       	and	r24, r24
    3308:	09 f4       	brne	.+2      	; 0x330c <xTaskResumeAll+0x36>
    330a:	5d c0       	rjmp	.+186    	; 0x33c6 <xTaskResumeAll+0xf0>
    330c:	c0 e0       	ldi	r28, 0x00	; 0
    330e:	d0 e0       	ldi	r29, 0x00	; 0
    3310:	ff 24       	eor	r15, r15
    3312:	f3 94       	inc	r15
    3314:	80 91 49 68 	lds	r24, 0x6849	; 0x806849 <xPendingReadyList>
    3318:	88 23       	and	r24, r24
    331a:	a1 f1       	breq	.+104    	; 0x3384 <xTaskResumeAll+0xae>
    331c:	e0 91 4e 68 	lds	r30, 0x684E	; 0x80684e <xPendingReadyList+0x5>
    3320:	f0 91 4f 68 	lds	r31, 0x684F	; 0x80684f <xPendingReadyList+0x6>
    3324:	c6 81       	ldd	r28, Z+6	; 0x06
    3326:	d7 81       	ldd	r29, Z+7	; 0x07
    3328:	ce 01       	movw	r24, r28
    332a:	0c 96       	adiw	r24, 0x0c	; 12
    332c:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <uxListRemove>
    3330:	8e 01       	movw	r16, r28
    3332:	0e 5f       	subi	r16, 0xFE	; 254
    3334:	1f 4f       	sbci	r17, 0xFF	; 255
    3336:	c8 01       	movw	r24, r16
    3338:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <uxListRemove>
    333c:	8e 89       	ldd	r24, Y+22	; 0x16
    333e:	90 91 32 68 	lds	r25, 0x6832	; 0x806832 <uxTopReadyPriority>
    3342:	98 17       	cp	r25, r24
    3344:	10 f4       	brcc	.+4      	; 0x334a <xTaskResumeAll+0x74>
    3346:	80 93 32 68 	sts	0x6832, r24	; 0x806832 <uxTopReadyPriority>
    334a:	90 e0       	ldi	r25, 0x00	; 0
    334c:	9c 01       	movw	r18, r24
    334e:	22 0f       	add	r18, r18
    3350:	33 1f       	adc	r19, r19
    3352:	22 0f       	add	r18, r18
    3354:	33 1f       	adc	r19, r19
    3356:	22 0f       	add	r18, r18
    3358:	33 1f       	adc	r19, r19
    335a:	82 0f       	add	r24, r18
    335c:	93 1f       	adc	r25, r19
    335e:	b8 01       	movw	r22, r16
    3360:	88 59       	subi	r24, 0x98	; 152
    3362:	97 49       	sbci	r25, 0x97	; 151
    3364:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <vListInsertEnd>
    3368:	e0 91 8c 68 	lds	r30, 0x688C	; 0x80688c <pxCurrentTCB>
    336c:	f0 91 8d 68 	lds	r31, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    3370:	9e 89       	ldd	r25, Y+22	; 0x16
    3372:	86 89       	ldd	r24, Z+22	; 0x16
    3374:	98 17       	cp	r25, r24
    3376:	70 f2       	brcs	.-100    	; 0x3314 <xTaskResumeAll+0x3e>
    3378:	f0 92 2f 68 	sts	0x682F, r15	; 0x80682f <xYieldPending>
    337c:	80 91 49 68 	lds	r24, 0x6849	; 0x806849 <xPendingReadyList>
    3380:	81 11       	cpse	r24, r1
    3382:	cc cf       	rjmp	.-104    	; 0x331c <xTaskResumeAll+0x46>
    3384:	cd 2b       	or	r28, r29
    3386:	69 f0       	breq	.+26     	; 0x33a2 <xTaskResumeAll+0xcc>
    3388:	e0 91 54 68 	lds	r30, 0x6854	; 0x806854 <pxDelayedTaskList>
    338c:	f0 91 55 68 	lds	r31, 0x6855	; 0x806855 <pxDelayedTaskList+0x1>
    3390:	80 81       	ld	r24, Z
    3392:	81 11       	cpse	r24, r1
    3394:	2c c0       	rjmp	.+88     	; 0x33ee <xTaskResumeAll+0x118>
    3396:	8f ef       	ldi	r24, 0xFF	; 255
    3398:	9f ef       	ldi	r25, 0xFF	; 255
    339a:	80 93 2b 68 	sts	0x682B, r24	; 0x80682b <xNextTaskUnblockTime>
    339e:	90 93 2c 68 	sts	0x682C, r25	; 0x80682c <xNextTaskUnblockTime+0x1>
    33a2:	c0 91 30 68 	lds	r28, 0x6830	; 0x806830 <uxPendedTicks>
    33a6:	cc 23       	and	r28, r28
    33a8:	51 f0       	breq	.+20     	; 0x33be <xTaskResumeAll+0xe8>
    33aa:	d1 e0       	ldi	r29, 0x01	; 1
    33ac:	0e 94 91 18 	call	0x3122	; 0x3122 <xTaskIncrementTick>
    33b0:	81 11       	cpse	r24, r1
    33b2:	d0 93 2f 68 	sts	0x682F, r29	; 0x80682f <xYieldPending>
    33b6:	c1 50       	subi	r28, 0x01	; 1
    33b8:	c9 f7       	brne	.-14     	; 0x33ac <xTaskResumeAll+0xd6>
    33ba:	10 92 30 68 	sts	0x6830, r1	; 0x806830 <uxPendedTicks>
    33be:	80 91 2f 68 	lds	r24, 0x682F	; 0x80682f <xYieldPending>
    33c2:	81 11       	cpse	r24, r1
    33c4:	10 c0       	rjmp	.+32     	; 0x33e6 <xTaskResumeAll+0x110>
    33c6:	80 e0       	ldi	r24, 0x00	; 0
    33c8:	0f 90       	pop	r0
    33ca:	0f be       	out	0x3f, r0	; 63
    33cc:	df 91       	pop	r29
    33ce:	cf 91       	pop	r28
    33d0:	1f 91       	pop	r17
    33d2:	0f 91       	pop	r16
    33d4:	ff 90       	pop	r15
    33d6:	08 95       	ret
    33d8:	6c e6       	ldi	r22, 0x6C	; 108
    33da:	78 e0       	ldi	r23, 0x08	; 8
    33dc:	8f e9       	ldi	r24, 0x9F	; 159
    33de:	92 e2       	ldi	r25, 0x22	; 34
    33e0:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    33e4:	82 cf       	rjmp	.-252    	; 0x32ea <xTaskResumeAll+0x14>
    33e6:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vPortYield>
    33ea:	81 e0       	ldi	r24, 0x01	; 1
    33ec:	ed cf       	rjmp	.-38     	; 0x33c8 <xTaskResumeAll+0xf2>
    33ee:	0e 94 8d 15 	call	0x2b1a	; 0x2b1a <prvResetNextTaskUnblockTime.part.0>
    33f2:	d7 cf       	rjmp	.-82     	; 0x33a2 <xTaskResumeAll+0xcc>

000033f4 <vTaskDelayUntil>:
    33f4:	0f 93       	push	r16
    33f6:	1f 93       	push	r17
    33f8:	cf 93       	push	r28
    33fa:	df 93       	push	r29
    33fc:	8c 01       	movw	r16, r24
    33fe:	eb 01       	movw	r28, r22
    3400:	89 2b       	or	r24, r25
    3402:	09 f4       	brne	.+2      	; 0x3406 <vTaskDelayUntil+0x12>
    3404:	46 c0       	rjmp	.+140    	; 0x3492 <vTaskDelayUntil+0x9e>
    3406:	20 97       	sbiw	r28, 0x00	; 0
    3408:	e9 f1       	breq	.+122    	; 0x3484 <vTaskDelayUntil+0x90>
    340a:	80 91 28 68 	lds	r24, 0x6828	; 0x806828 <uxSchedulerSuspended>
    340e:	81 11       	cpse	r24, r1
    3410:	32 c0       	rjmp	.+100    	; 0x3476 <vTaskDelayUntil+0x82>
    3412:	80 91 28 68 	lds	r24, 0x6828	; 0x806828 <uxSchedulerSuspended>
    3416:	8f 5f       	subi	r24, 0xFF	; 255
    3418:	80 93 28 68 	sts	0x6828, r24	; 0x806828 <uxSchedulerSuspended>
    341c:	40 91 33 68 	lds	r20, 0x6833	; 0x806833 <xTickCount>
    3420:	50 91 34 68 	lds	r21, 0x6834	; 0x806834 <xTickCount+0x1>
    3424:	f8 01       	movw	r30, r16
    3426:	20 81       	ld	r18, Z
    3428:	31 81       	ldd	r19, Z+1	; 0x01
    342a:	ce 01       	movw	r24, r28
    342c:	82 0f       	add	r24, r18
    342e:	93 1f       	adc	r25, r19
    3430:	42 17       	cp	r20, r18
    3432:	53 07       	cpc	r21, r19
    3434:	88 f4       	brcc	.+34     	; 0x3458 <vTaskDelayUntil+0x64>
    3436:	82 17       	cp	r24, r18
    3438:	93 07       	cpc	r25, r19
    343a:	88 f0       	brcs	.+34     	; 0x345e <vTaskDelayUntil+0x6a>
    343c:	f8 01       	movw	r30, r16
    343e:	80 83       	st	Z, r24
    3440:	91 83       	std	Z+1, r25	; 0x01
    3442:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>
    3446:	81 11       	cpse	r24, r1
    3448:	02 c0       	rjmp	.+4      	; 0x344e <vTaskDelayUntil+0x5a>
    344a:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vPortYield>
    344e:	df 91       	pop	r29
    3450:	cf 91       	pop	r28
    3452:	1f 91       	pop	r17
    3454:	0f 91       	pop	r16
    3456:	08 95       	ret
    3458:	82 17       	cp	r24, r18
    345a:	93 07       	cpc	r25, r19
    345c:	18 f0       	brcs	.+6      	; 0x3464 <vTaskDelayUntil+0x70>
    345e:	48 17       	cp	r20, r24
    3460:	59 07       	cpc	r21, r25
    3462:	60 f7       	brcc	.-40     	; 0x343c <vTaskDelayUntil+0x48>
    3464:	f8 01       	movw	r30, r16
    3466:	80 83       	st	Z, r24
    3468:	91 83       	std	Z+1, r25	; 0x01
    346a:	60 e0       	ldi	r22, 0x00	; 0
    346c:	84 1b       	sub	r24, r20
    346e:	95 0b       	sbc	r25, r21
    3470:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <prvAddCurrentTaskToDelayedList>
    3474:	e6 cf       	rjmp	.-52     	; 0x3442 <vTaskDelayUntil+0x4e>
    3476:	6c ec       	ldi	r22, 0xCC	; 204
    3478:	74 e0       	ldi	r23, 0x04	; 4
    347a:	8f e9       	ldi	r24, 0x9F	; 159
    347c:	92 e2       	ldi	r25, 0x22	; 34
    347e:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    3482:	c7 cf       	rjmp	.-114    	; 0x3412 <vTaskDelayUntil+0x1e>
    3484:	6b ec       	ldi	r22, 0xCB	; 203
    3486:	74 e0       	ldi	r23, 0x04	; 4
    3488:	8f e9       	ldi	r24, 0x9F	; 159
    348a:	92 e2       	ldi	r25, 0x22	; 34
    348c:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    3490:	bc cf       	rjmp	.-136    	; 0x340a <vTaskDelayUntil+0x16>
    3492:	6a ec       	ldi	r22, 0xCA	; 202
    3494:	74 e0       	ldi	r23, 0x04	; 4
    3496:	8f e9       	ldi	r24, 0x9F	; 159
    3498:	92 e2       	ldi	r25, 0x22	; 34
    349a:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    349e:	b3 cf       	rjmp	.-154    	; 0x3406 <vTaskDelayUntil+0x12>

000034a0 <vTaskDelay>:
    34a0:	cf 93       	push	r28
    34a2:	df 93       	push	r29
    34a4:	ec 01       	movw	r28, r24
    34a6:	89 2b       	or	r24, r25
    34a8:	29 f4       	brne	.+10     	; 0x34b4 <vTaskDelay+0x14>
    34aa:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vPortYield>
    34ae:	df 91       	pop	r29
    34b0:	cf 91       	pop	r28
    34b2:	08 95       	ret
    34b4:	80 91 28 68 	lds	r24, 0x6828	; 0x806828 <uxSchedulerSuspended>
    34b8:	81 11       	cpse	r24, r1
    34ba:	10 c0       	rjmp	.+32     	; 0x34dc <vTaskDelay+0x3c>
    34bc:	80 91 28 68 	lds	r24, 0x6828	; 0x806828 <uxSchedulerSuspended>
    34c0:	8f 5f       	subi	r24, 0xFF	; 255
    34c2:	80 93 28 68 	sts	0x6828, r24	; 0x806828 <uxSchedulerSuspended>
    34c6:	60 e0       	ldi	r22, 0x00	; 0
    34c8:	ce 01       	movw	r24, r28
    34ca:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <prvAddCurrentTaskToDelayedList>
    34ce:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>
    34d2:	88 23       	and	r24, r24
    34d4:	51 f3       	breq	.-44     	; 0x34aa <vTaskDelay+0xa>
    34d6:	df 91       	pop	r29
    34d8:	cf 91       	pop	r28
    34da:	08 95       	ret
    34dc:	60 e2       	ldi	r22, 0x20	; 32
    34de:	75 e0       	ldi	r23, 0x05	; 5
    34e0:	8f e9       	ldi	r24, 0x9F	; 159
    34e2:	92 e2       	ldi	r25, 0x22	; 34
    34e4:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    34e8:	e9 cf       	rjmp	.-46     	; 0x34bc <vTaskDelay+0x1c>

000034ea <vTaskSwitchContext>:
    34ea:	80 91 28 68 	lds	r24, 0x6828	; 0x806828 <uxSchedulerSuspended>
    34ee:	81 11       	cpse	r24, r1
    34f0:	02 c0       	rjmp	.+4      	; 0x34f6 <vTaskSwitchContext+0xc>
    34f2:	0c 94 fa 15 	jmp	0x2bf4	; 0x2bf4 <vTaskSwitchContext.part.5>
    34f6:	81 e0       	ldi	r24, 0x01	; 1
    34f8:	80 93 2f 68 	sts	0x682F, r24	; 0x80682f <xYieldPending>
    34fc:	08 95       	ret

000034fe <vTaskPlaceOnEventList>:
    34fe:	0f 93       	push	r16
    3500:	1f 93       	push	r17
    3502:	cf 93       	push	r28
    3504:	df 93       	push	r29
    3506:	ec 01       	movw	r28, r24
    3508:	8b 01       	movw	r16, r22
    350a:	89 2b       	or	r24, r25
    350c:	89 f0       	breq	.+34     	; 0x3530 <vTaskPlaceOnEventList+0x32>
    350e:	60 91 8c 68 	lds	r22, 0x688C	; 0x80688c <pxCurrentTCB>
    3512:	70 91 8d 68 	lds	r23, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    3516:	64 5f       	subi	r22, 0xF4	; 244
    3518:	7f 4f       	sbci	r23, 0xFF	; 255
    351a:	ce 01       	movw	r24, r28
    351c:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <vListInsert>
    3520:	61 e0       	ldi	r22, 0x01	; 1
    3522:	c8 01       	movw	r24, r16
    3524:	df 91       	pop	r29
    3526:	cf 91       	pop	r28
    3528:	1f 91       	pop	r17
    352a:	0f 91       	pop	r16
    352c:	0c 94 9e 15 	jmp	0x2b3c	; 0x2b3c <prvAddCurrentTaskToDelayedList>
    3530:	63 ea       	ldi	r22, 0xA3	; 163
    3532:	7b e0       	ldi	r23, 0x0B	; 11
    3534:	8f e9       	ldi	r24, 0x9F	; 159
    3536:	92 e2       	ldi	r25, 0x22	; 34
    3538:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    353c:	e8 cf       	rjmp	.-48     	; 0x350e <vTaskPlaceOnEventList+0x10>

0000353e <xTaskRemoveFromEventList>:
    353e:	0f 93       	push	r16
    3540:	1f 93       	push	r17
    3542:	cf 93       	push	r28
    3544:	df 93       	push	r29
    3546:	dc 01       	movw	r26, r24
    3548:	15 96       	adiw	r26, 0x05	; 5
    354a:	ed 91       	ld	r30, X+
    354c:	fc 91       	ld	r31, X
    354e:	16 97       	sbiw	r26, 0x06	; 6
    3550:	c6 81       	ldd	r28, Z+6	; 0x06
    3552:	d7 81       	ldd	r29, Z+7	; 0x07
    3554:	20 97       	sbiw	r28, 0x00	; 0
    3556:	09 f4       	brne	.+2      	; 0x355a <xTaskRemoveFromEventList+0x1c>
    3558:	42 c0       	rjmp	.+132    	; 0x35de <xTaskRemoveFromEventList+0xa0>
    355a:	8e 01       	movw	r16, r28
    355c:	04 5f       	subi	r16, 0xF4	; 244
    355e:	1f 4f       	sbci	r17, 0xFF	; 255
    3560:	c8 01       	movw	r24, r16
    3562:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <uxListRemove>
    3566:	80 91 28 68 	lds	r24, 0x6828	; 0x806828 <uxSchedulerSuspended>
    356a:	81 11       	cpse	r24, r1
    356c:	29 c0       	rjmp	.+82     	; 0x35c0 <xTaskRemoveFromEventList+0x82>
    356e:	0a 50       	subi	r16, 0x0A	; 10
    3570:	11 09       	sbc	r17, r1
    3572:	c8 01       	movw	r24, r16
    3574:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <uxListRemove>
    3578:	8e 89       	ldd	r24, Y+22	; 0x16
    357a:	90 91 32 68 	lds	r25, 0x6832	; 0x806832 <uxTopReadyPriority>
    357e:	98 17       	cp	r25, r24
    3580:	28 f1       	brcs	.+74     	; 0x35cc <xTaskRemoveFromEventList+0x8e>
    3582:	90 e0       	ldi	r25, 0x00	; 0
    3584:	9c 01       	movw	r18, r24
    3586:	22 0f       	add	r18, r18
    3588:	33 1f       	adc	r19, r19
    358a:	22 0f       	add	r18, r18
    358c:	33 1f       	adc	r19, r19
    358e:	22 0f       	add	r18, r18
    3590:	33 1f       	adc	r19, r19
    3592:	82 0f       	add	r24, r18
    3594:	93 1f       	adc	r25, r19
    3596:	b8 01       	movw	r22, r16
    3598:	88 59       	subi	r24, 0x98	; 152
    359a:	97 49       	sbci	r25, 0x97	; 151
    359c:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <vListInsertEnd>
    35a0:	e0 91 8c 68 	lds	r30, 0x688C	; 0x80688c <pxCurrentTCB>
    35a4:	f0 91 8d 68 	lds	r31, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    35a8:	9e 89       	ldd	r25, Y+22	; 0x16
    35aa:	86 89       	ldd	r24, Z+22	; 0x16
    35ac:	89 17       	cp	r24, r25
    35ae:	88 f4       	brcc	.+34     	; 0x35d2 <xTaskRemoveFromEventList+0x94>
    35b0:	81 e0       	ldi	r24, 0x01	; 1
    35b2:	80 93 2f 68 	sts	0x682F, r24	; 0x80682f <xYieldPending>
    35b6:	df 91       	pop	r29
    35b8:	cf 91       	pop	r28
    35ba:	1f 91       	pop	r17
    35bc:	0f 91       	pop	r16
    35be:	08 95       	ret
    35c0:	b8 01       	movw	r22, r16
    35c2:	89 e4       	ldi	r24, 0x49	; 73
    35c4:	98 e6       	ldi	r25, 0x68	; 104
    35c6:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <vListInsertEnd>
    35ca:	ea cf       	rjmp	.-44     	; 0x35a0 <xTaskRemoveFromEventList+0x62>
    35cc:	80 93 32 68 	sts	0x6832, r24	; 0x806832 <uxTopReadyPriority>
    35d0:	d8 cf       	rjmp	.-80     	; 0x3582 <xTaskRemoveFromEventList+0x44>
    35d2:	80 e0       	ldi	r24, 0x00	; 0
    35d4:	df 91       	pop	r29
    35d6:	cf 91       	pop	r28
    35d8:	1f 91       	pop	r17
    35da:	0f 91       	pop	r16
    35dc:	08 95       	ret
    35de:	6e ef       	ldi	r22, 0xFE	; 254
    35e0:	7b e0       	ldi	r23, 0x0B	; 11
    35e2:	8f e9       	ldi	r24, 0x9F	; 159
    35e4:	92 e2       	ldi	r25, 0x22	; 34
    35e6:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    35ea:	b7 cf       	rjmp	.-146    	; 0x355a <xTaskRemoveFromEventList+0x1c>

000035ec <vTaskInternalSetTimeOutState>:
    35ec:	20 91 2e 68 	lds	r18, 0x682E	; 0x80682e <xNumOfOverflows>
    35f0:	fc 01       	movw	r30, r24
    35f2:	20 83       	st	Z, r18
    35f4:	20 91 33 68 	lds	r18, 0x6833	; 0x806833 <xTickCount>
    35f8:	30 91 34 68 	lds	r19, 0x6834	; 0x806834 <xTickCount+0x1>
    35fc:	21 83       	std	Z+1, r18	; 0x01
    35fe:	32 83       	std	Z+2, r19	; 0x02
    3600:	08 95       	ret

00003602 <xTaskCheckForTimeOut>:
    3602:	0f 93       	push	r16
    3604:	1f 93       	push	r17
    3606:	cf 93       	push	r28
    3608:	df 93       	push	r29
    360a:	ec 01       	movw	r28, r24
    360c:	8b 01       	movw	r16, r22
    360e:	89 2b       	or	r24, r25
    3610:	09 f4       	brne	.+2      	; 0x3614 <xTaskCheckForTimeOut+0x12>
    3612:	40 c0       	rjmp	.+128    	; 0x3694 <xTaskCheckForTimeOut+0x92>
    3614:	01 15       	cp	r16, r1
    3616:	11 05       	cpc	r17, r1
    3618:	09 f4       	brne	.+2      	; 0x361c <xTaskCheckForTimeOut+0x1a>
    361a:	43 c0       	rjmp	.+134    	; 0x36a2 <xTaskCheckForTimeOut+0xa0>
    361c:	0f b6       	in	r0, 0x3f	; 63
    361e:	f8 94       	cli
    3620:	0f 92       	push	r0
    3622:	80 91 33 68 	lds	r24, 0x6833	; 0x806833 <xTickCount>
    3626:	90 91 34 68 	lds	r25, 0x6834	; 0x806834 <xTickCount+0x1>
    362a:	f8 01       	movw	r30, r16
    362c:	20 81       	ld	r18, Z
    362e:	31 81       	ldd	r19, Z+1	; 0x01
    3630:	2f 3f       	cpi	r18, 0xFF	; 255
    3632:	ff ef       	ldi	r31, 0xFF	; 255
    3634:	3f 07       	cpc	r19, r31
    3636:	61 f1       	breq	.+88     	; 0x3690 <xTaskCheckForTimeOut+0x8e>
    3638:	49 81       	ldd	r20, Y+1	; 0x01
    363a:	5a 81       	ldd	r21, Y+2	; 0x02
    363c:	60 91 2e 68 	lds	r22, 0x682E	; 0x80682e <xNumOfOverflows>
    3640:	78 81       	ld	r23, Y
    3642:	76 17       	cp	r23, r22
    3644:	19 f0       	breq	.+6      	; 0x364c <xTaskCheckForTimeOut+0x4a>
    3646:	84 17       	cp	r24, r20
    3648:	95 07       	cpc	r25, r21
    364a:	80 f4       	brcc	.+32     	; 0x366c <xTaskCheckForTimeOut+0x6a>
    364c:	84 1b       	sub	r24, r20
    364e:	95 0b       	sbc	r25, r21
    3650:	82 17       	cp	r24, r18
    3652:	93 07       	cpc	r25, r19
    3654:	68 f0       	brcs	.+26     	; 0x3670 <xTaskCheckForTimeOut+0x6e>
    3656:	f8 01       	movw	r30, r16
    3658:	10 82       	st	Z, r1
    365a:	11 82       	std	Z+1, r1	; 0x01
    365c:	81 e0       	ldi	r24, 0x01	; 1
    365e:	0f 90       	pop	r0
    3660:	0f be       	out	0x3f, r0	; 63
    3662:	df 91       	pop	r29
    3664:	cf 91       	pop	r28
    3666:	1f 91       	pop	r17
    3668:	0f 91       	pop	r16
    366a:	08 95       	ret
    366c:	81 e0       	ldi	r24, 0x01	; 1
    366e:	f7 cf       	rjmp	.-18     	; 0x365e <xTaskCheckForTimeOut+0x5c>
    3670:	28 1b       	sub	r18, r24
    3672:	39 0b       	sbc	r19, r25
    3674:	f8 01       	movw	r30, r16
    3676:	20 83       	st	Z, r18
    3678:	31 83       	std	Z+1, r19	; 0x01
    367a:	80 91 2e 68 	lds	r24, 0x682E	; 0x80682e <xNumOfOverflows>
    367e:	88 83       	st	Y, r24
    3680:	80 91 33 68 	lds	r24, 0x6833	; 0x806833 <xTickCount>
    3684:	90 91 34 68 	lds	r25, 0x6834	; 0x806834 <xTickCount+0x1>
    3688:	89 83       	std	Y+1, r24	; 0x01
    368a:	9a 83       	std	Y+2, r25	; 0x02
    368c:	80 e0       	ldi	r24, 0x00	; 0
    368e:	e7 cf       	rjmp	.-50     	; 0x365e <xTaskCheckForTimeOut+0x5c>
    3690:	80 e0       	ldi	r24, 0x00	; 0
    3692:	e5 cf       	rjmp	.-54     	; 0x365e <xTaskCheckForTimeOut+0x5c>
    3694:	69 e6       	ldi	r22, 0x69	; 105
    3696:	7c e0       	ldi	r23, 0x0C	; 12
    3698:	8f e9       	ldi	r24, 0x9F	; 159
    369a:	92 e2       	ldi	r25, 0x22	; 34
    369c:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    36a0:	b9 cf       	rjmp	.-142    	; 0x3614 <xTaskCheckForTimeOut+0x12>
    36a2:	6a e6       	ldi	r22, 0x6A	; 106
    36a4:	7c e0       	ldi	r23, 0x0C	; 12
    36a6:	8f e9       	ldi	r24, 0x9F	; 159
    36a8:	92 e2       	ldi	r25, 0x22	; 34
    36aa:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <vAssertCalled>
    36ae:	b6 cf       	rjmp	.-148    	; 0x361c <xTaskCheckForTimeOut+0x1a>

000036b0 <vTaskMissedYield>:
    36b0:	81 e0       	ldi	r24, 0x01	; 1
    36b2:	80 93 2f 68 	sts	0x682F, r24	; 0x80682f <xYieldPending>
    36b6:	08 95       	ret

000036b8 <vTaskGetInfo>:
/*-----------------------------------------------------------*/

#if( configUSE_TRACE_FACILITY == 1 )

	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
    36b8:	ff 92       	push	r15
    36ba:	0f 93       	push	r16
    36bc:	1f 93       	push	r17
    36be:	cf 93       	push	r28
    36c0:	df 93       	push	r29
    36c2:	8c 01       	movw	r16, r24
    36c4:	eb 01       	movw	r28, r22
    36c6:	f4 2e       	mov	r15, r20
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );
    36c8:	89 2b       	or	r24, r25
    36ca:	09 f4       	brne	.+2      	; 0x36ce <vTaskGetInfo+0x16>
    36cc:	61 c0       	rjmp	.+194    	; 0x3790 <vTaskGetInfo+0xd8>

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
    36ce:	08 83       	st	Y, r16
    36d0:	19 83       	std	Y+1, r17	; 0x01
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
    36d2:	c8 01       	movw	r24, r16
    36d4:	49 96       	adiw	r24, 0x19	; 25
    36d6:	8a 83       	std	Y+2, r24	; 0x02
    36d8:	9b 83       	std	Y+3, r25	; 0x03
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
    36da:	d8 01       	movw	r26, r16
    36dc:	56 96       	adiw	r26, 0x16	; 22
    36de:	8c 91       	ld	r24, X
    36e0:	56 97       	sbiw	r26, 0x16	; 22
    36e2:	8e 83       	std	Y+6, r24	; 0x06
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
    36e4:	57 96       	adiw	r26, 0x17	; 23
    36e6:	8d 91       	ld	r24, X+
    36e8:	9c 91       	ld	r25, X
    36ea:	58 97       	sbiw	r26, 0x18	; 24
    36ec:	8c 87       	std	Y+12, r24	; 0x0c
    36ee:	9d 87       	std	Y+13, r25	; 0x0d
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
    36f0:	91 96       	adiw	r26, 0x21	; 33
    36f2:	8c 91       	ld	r24, X
    36f4:	91 97       	sbiw	r26, 0x21	; 33
    36f6:	8c 83       	std	Y+4, r24	; 0x04
		{
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
		}
		#else
		{
			pxTaskStatus->uxBasePriority = 0;
    36f8:	1f 82       	std	Y+7, r1	; 0x07
		}
		#endif

		#if ( configGENERATE_RUN_TIME_STATS == 1 )
		{
			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
    36fa:	93 96       	adiw	r26, 0x23	; 35
    36fc:	8d 91       	ld	r24, X+
    36fe:	9d 91       	ld	r25, X+
    3700:	0d 90       	ld	r0, X+
    3702:	bc 91       	ld	r27, X
    3704:	a0 2d       	mov	r26, r0
    3706:	88 87       	std	Y+8, r24	; 0x08
    3708:	99 87       	std	Y+9, r25	; 0x09
    370a:	aa 87       	std	Y+10, r26	; 0x0a
    370c:	bb 87       	std	Y+11, r27	; 0x0b
		#endif

		/* Obtaining the task state is a little fiddly, so is only done if the
		value of eState passed into this function is eInvalid - otherwise the
		state is just set to whatever is passed in. */
		if( eState != eInvalid )
    370e:	25 30       	cpi	r18, 0x05	; 5
    3710:	09 f4       	brne	.+2      	; 0x3714 <vTaskGetInfo+0x5c>
    3712:	43 c0       	rjmp	.+134    	; 0x379a <vTaskGetInfo+0xe2>
		{
			if( pxTCB == pxCurrentTCB )
    3714:	80 91 8c 68 	lds	r24, 0x688C	; 0x80688c <pxCurrentTCB>
    3718:	90 91 8d 68 	lds	r25, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    371c:	08 17       	cp	r16, r24
    371e:	19 07       	cpc	r17, r25
    3720:	09 f4       	brne	.+2      	; 0x3724 <vTaskGetInfo+0x6c>
    3722:	40 c0       	rjmp	.+128    	; 0x37a4 <vTaskGetInfo+0xec>
			{
				pxTaskStatus->eCurrentState = eRunning;
			}
			else
			{
				pxTaskStatus->eCurrentState = eState;
    3724:	2d 83       	std	Y+5, r18	; 0x05
				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* If the task is in the suspended list then there is a
					chance it is actually just blocked indefinitely - so really
					it should be reported as being in the Blocked state. */
					if( eState == eSuspended )
    3726:	23 30       	cpi	r18, 0x03	; 3
    3728:	21 f1       	breq	.+72     	; 0x3772 <vTaskGetInfo+0xba>
			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
		}

		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
		parameter is provided to allow it to be skipped. */
		if( xGetFreeStackSpace != pdFALSE )
    372a:	ff 20       	and	r15, r15
    372c:	d1 f0       	breq	.+52     	; 0x3762 <vTaskGetInfo+0xaa>
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
			}
			#else
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
    372e:	d8 01       	movw	r26, r16
    3730:	57 96       	adiw	r26, 0x17	; 23
    3732:	ed 91       	ld	r30, X+
    3734:	fc 91       	ld	r31, X
    3736:	58 97       	sbiw	r26, 0x18	; 24

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    3738:	80 81       	ld	r24, Z
    373a:	85 3a       	cpi	r24, 0xA5	; 165
    373c:	a9 f5       	brne	.+106    	; 0x37a8 <vTaskGetInfo+0xf0>
    373e:	31 96       	adiw	r30, 0x01	; 1
    3740:	80 e0       	ldi	r24, 0x00	; 0
    3742:	90 e0       	ldi	r25, 0x00	; 0
    3744:	dc 01       	movw	r26, r24
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
    3746:	01 96       	adiw	r24, 0x01	; 1
    3748:	a1 1d       	adc	r26, r1
    374a:	b1 1d       	adc	r27, r1

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    374c:	21 91       	ld	r18, Z+
    374e:	25 3a       	cpi	r18, 0xA5	; 165
    3750:	d1 f3       	breq	.-12     	; 0x3746 <vTaskGetInfo+0x8e>
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
			}
			#else
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
    3752:	8e 87       	std	Y+14, r24	; 0x0e
    3754:	9f 87       	std	Y+15, r25	; 0x0f
		}
		else
		{
			pxTaskStatus->usStackHighWaterMark = 0;
		}
	}
    3756:	df 91       	pop	r29
    3758:	cf 91       	pop	r28
    375a:	1f 91       	pop	r17
    375c:	0f 91       	pop	r16
    375e:	ff 90       	pop	r15
    3760:	08 95       	ret
			}
			#endif
		}
		else
		{
			pxTaskStatus->usStackHighWaterMark = 0;
    3762:	1e 86       	std	Y+14, r1	; 0x0e
    3764:	1f 86       	std	Y+15, r1	; 0x0f
		}
	}
    3766:	df 91       	pop	r29
    3768:	cf 91       	pop	r28
    376a:	1f 91       	pop	r17
    376c:	0f 91       	pop	r16
    376e:	ff 90       	pop	r15
    3770:	08 95       	ret
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    3772:	80 91 28 68 	lds	r24, 0x6828	; 0x806828 <uxSchedulerSuspended>
    3776:	8f 5f       	subi	r24, 0xFF	; 255
    3778:	80 93 28 68 	sts	0x6828, r24	; 0x806828 <uxSchedulerSuspended>
					it should be reported as being in the Blocked state. */
					if( eState == eSuspended )
					{
						vTaskSuspendAll();
						{
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    377c:	f8 01       	movw	r30, r16
    377e:	84 89       	ldd	r24, Z+20	; 0x14
    3780:	95 89       	ldd	r25, Z+21	; 0x15
    3782:	89 2b       	or	r24, r25
    3784:	11 f0       	breq	.+4      	; 0x378a <vTaskGetInfo+0xd2>
							{
								pxTaskStatus->eCurrentState = eBlocked;
    3786:	82 e0       	ldi	r24, 0x02	; 2
    3788:	8d 83       	std	Y+5, r24	; 0x05
							}
						}
						( void ) xTaskResumeAll();
    378a:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>
    378e:	cd cf       	rjmp	.-102    	; 0x372a <vTaskGetInfo+0x72>
	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );
    3790:	00 91 8c 68 	lds	r16, 0x688C	; 0x80688c <pxCurrentTCB>
    3794:	10 91 8d 68 	lds	r17, 0x688D	; 0x80688d <pxCurrentTCB+0x1>
    3798:	9a cf       	rjmp	.-204    	; 0x36ce <vTaskGetInfo+0x16>
				#endif /* INCLUDE_vTaskSuspend */
			}
		}
		else
		{
			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
    379a:	c8 01       	movw	r24, r16
    379c:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <eTaskGetState>
    37a0:	8d 83       	std	Y+5, r24	; 0x05
    37a2:	c3 cf       	rjmp	.-122    	; 0x372a <vTaskGetInfo+0x72>
		state is just set to whatever is passed in. */
		if( eState != eInvalid )
		{
			if( pxTCB == pxCurrentTCB )
			{
				pxTaskStatus->eCurrentState = eRunning;
    37a4:	1d 82       	std	Y+5, r1	; 0x05
    37a6:	c1 cf       	rjmp	.-126    	; 0x372a <vTaskGetInfo+0x72>

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    37a8:	80 e0       	ldi	r24, 0x00	; 0
    37aa:	90 e0       	ldi	r25, 0x00	; 0
    37ac:	d2 cf       	rjmp	.-92     	; 0x3752 <vTaskGetInfo+0x9a>

000037ae <prvListTasksWithinSingleList.part.6>:
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
    37ae:	8f 92       	push	r8
    37b0:	9f 92       	push	r9
    37b2:	af 92       	push	r10
    37b4:	bf 92       	push	r11
    37b6:	cf 92       	push	r12
    37b8:	df 92       	push	r13
    37ba:	ef 92       	push	r14
    37bc:	ff 92       	push	r15
    37be:	0f 93       	push	r16
    37c0:	1f 93       	push	r17
    37c2:	cf 93       	push	r28
    37c4:	df 93       	push	r29
    37c6:	5c 01       	movw	r10, r24
    37c8:	8b 01       	movw	r16, r22
    37ca:	d4 2f       	mov	r29, r20
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    37cc:	db 01       	movw	r26, r22
    37ce:	11 96       	adiw	r26, 0x01	; 1
    37d0:	ed 91       	ld	r30, X+
    37d2:	fc 91       	ld	r31, X
    37d4:	12 97       	sbiw	r26, 0x02	; 2
    37d6:	02 80       	ldd	r0, Z+2	; 0x02
    37d8:	f3 81       	ldd	r31, Z+3	; 0x03
    37da:	e0 2d       	mov	r30, r0
    37dc:	11 96       	adiw	r26, 0x01	; 1
    37de:	ed 93       	st	X+, r30
    37e0:	fc 93       	st	X, r31
    37e2:	12 97       	sbiw	r26, 0x02	; 2
    37e4:	7b 01       	movw	r14, r22
    37e6:	b3 e0       	ldi	r27, 0x03	; 3
    37e8:	eb 0e       	add	r14, r27
    37ea:	f1 1c       	adc	r15, r1
    37ec:	ee 15       	cp	r30, r14
    37ee:	ff 05       	cpc	r31, r15
    37f0:	e1 f1       	breq	.+120    	; 0x386a <prvListTasksWithinSingleList.part.6+0xbc>
    37f2:	c6 80       	ldd	r12, Z+6	; 0x06
    37f4:	d7 80       	ldd	r13, Z+7	; 0x07
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
    37f6:	c0 e0       	ldi	r28, 0x00	; 0
    37f8:	16 c0       	rjmp	.+44     	; 0x3826 <prvListTasksWithinSingleList.part.6+0x78>
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    37fa:	86 80       	ldd	r8, Z+6	; 0x06
    37fc:	97 80       	ldd	r9, Z+7	; 0x07
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
    37fe:	b5 01       	movw	r22, r10
    3800:	b0 e1       	ldi	r27, 0x10	; 16
    3802:	cb 9f       	mul	r28, r27
    3804:	60 0d       	add	r22, r0
    3806:	71 1d       	adc	r23, r1
    3808:	11 24       	eor	r1, r1
    380a:	2d 2f       	mov	r18, r29
    380c:	41 e0       	ldi	r20, 0x01	; 1
    380e:	c4 01       	movw	r24, r8
    3810:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <vTaskGetInfo>
				uxTask++;
    3814:	cf 5f       	subi	r28, 0xFF	; 255
			} while( pxNextTCB != pxFirstTCB );
    3816:	c8 14       	cp	r12, r8
    3818:	d9 04       	cpc	r13, r9
    381a:	c9 f0       	breq	.+50     	; 0x384e <prvListTasksWithinSingleList.part.6+0xa0>
    381c:	d8 01       	movw	r26, r16
    381e:	11 96       	adiw	r26, 0x01	; 1
    3820:	ed 91       	ld	r30, X+
    3822:	fc 91       	ld	r31, X
    3824:	12 97       	sbiw	r26, 0x02	; 2
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3826:	02 80       	ldd	r0, Z+2	; 0x02
    3828:	f3 81       	ldd	r31, Z+3	; 0x03
    382a:	e0 2d       	mov	r30, r0
    382c:	d8 01       	movw	r26, r16
    382e:	11 96       	adiw	r26, 0x01	; 1
    3830:	ed 93       	st	X+, r30
    3832:	fc 93       	st	X, r31
    3834:	12 97       	sbiw	r26, 0x02	; 2
    3836:	ee 16       	cp	r14, r30
    3838:	ff 06       	cpc	r15, r31
    383a:	f9 f6       	brne	.-66     	; 0x37fa <prvListTasksWithinSingleList.part.6+0x4c>
    383c:	15 96       	adiw	r26, 0x05	; 5
    383e:	ed 91       	ld	r30, X+
    3840:	fc 91       	ld	r31, X
    3842:	16 97       	sbiw	r26, 0x06	; 6
    3844:	11 96       	adiw	r26, 0x01	; 1
    3846:	ed 93       	st	X+, r30
    3848:	fc 93       	st	X, r31
    384a:	12 97       	sbiw	r26, 0x02	; 2
    384c:	d6 cf       	rjmp	.-84     	; 0x37fa <prvListTasksWithinSingleList.part.6+0x4c>
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return uxTask;
	}
    384e:	8c 2f       	mov	r24, r28
    3850:	df 91       	pop	r29
    3852:	cf 91       	pop	r28
    3854:	1f 91       	pop	r17
    3856:	0f 91       	pop	r16
    3858:	ff 90       	pop	r15
    385a:	ef 90       	pop	r14
    385c:	df 90       	pop	r13
    385e:	cf 90       	pop	r12
    3860:	bf 90       	pop	r11
    3862:	af 90       	pop	r10
    3864:	9f 90       	pop	r9
    3866:	8f 90       	pop	r8
    3868:	08 95       	ret
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    386a:	02 80       	ldd	r0, Z+2	; 0x02
    386c:	f3 81       	ldd	r31, Z+3	; 0x03
    386e:	e0 2d       	mov	r30, r0
    3870:	c0 cf       	rjmp	.-128    	; 0x37f2 <prvListTasksWithinSingleList.part.6+0x44>

00003872 <uxTaskGetSystemState>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
    3872:	ef 92       	push	r14
    3874:	ff 92       	push	r15
    3876:	0f 93       	push	r16
    3878:	1f 93       	push	r17
    387a:	cf 93       	push	r28
    387c:	df 93       	push	r29
    387e:	8c 01       	movw	r16, r24
    3880:	7a 01       	movw	r14, r20
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    3882:	80 91 28 68 	lds	r24, 0x6828	; 0x806828 <uxSchedulerSuspended>
    3886:	8f 5f       	subi	r24, 0xFF	; 255
    3888:	80 93 28 68 	sts	0x6828, r24	; 0x806828 <uxSchedulerSuspended>
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;

		vTaskSuspendAll();
		{
			/* Is there a space in the array for each task in the system? */
			if( uxArraySize >= uxCurrentNumberOfTasks )
    388c:	80 91 35 68 	lds	r24, 0x6835	; 0x806835 <uxCurrentNumberOfTasks>
    3890:	68 17       	cp	r22, r24
    3892:	08 f4       	brcc	.+2      	; 0x3896 <uxTaskGetSystemState+0x24>
    3894:	63 c0       	rjmp	.+198    	; 0x395c <uxTaskGetSystemState+0xea>
    3896:	c4 e0       	ldi	r28, 0x04	; 4
    3898:	d0 e0       	ldi	r29, 0x00	; 0
			{
				/* Fill in an TaskStatus_t structure with information on each
				task in the Ready state. */
				do
				{
					uxQueue--;
    389a:	c1 50       	subi	r28, 0x01	; 1
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
    389c:	6c 2f       	mov	r22, r28
    389e:	70 e0       	ldi	r23, 0x00	; 0
	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
    38a0:	cb 01       	movw	r24, r22
    38a2:	88 0f       	add	r24, r24
    38a4:	99 1f       	adc	r25, r25
    38a6:	88 0f       	add	r24, r24
    38a8:	99 1f       	adc	r25, r25
    38aa:	88 0f       	add	r24, r24
    38ac:	99 1f       	adc	r25, r25
    38ae:	68 0f       	add	r22, r24
    38b0:	79 1f       	adc	r23, r25
    38b2:	fb 01       	movw	r30, r22
    38b4:	e8 59       	subi	r30, 0x98	; 152
    38b6:	f7 49       	sbci	r31, 0x97	; 151
    38b8:	80 81       	ld	r24, Z
    38ba:	81 11       	cpse	r24, r1
    38bc:	44 c0       	rjmp	.+136    	; 0x3946 <uxTaskGetSystemState+0xd4>
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
    38be:	80 e0       	ldi	r24, 0x00	; 0
				/* Fill in an TaskStatus_t structure with information on each
				task in the Ready state. */
				do
				{
					uxQueue--;
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
    38c0:	d8 0f       	add	r29, r24

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    38c2:	c1 11       	cpse	r28, r1
    38c4:	ea cf       	rjmp	.-44     	; 0x389a <uxTaskGetSystemState+0x28>

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
    38c6:	e0 91 54 68 	lds	r30, 0x6854	; 0x806854 <pxDelayedTaskList>
    38ca:	f0 91 55 68 	lds	r31, 0x6855	; 0x806855 <pxDelayedTaskList+0x1>
	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
    38ce:	80 81       	ld	r24, Z
    38d0:	81 11       	cpse	r24, r1
    38d2:	46 c0       	rjmp	.+140    	; 0x3960 <uxTaskGetSystemState+0xee>
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
    38d4:	80 e0       	ldi	r24, 0x00	; 0

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
    38d6:	d8 0f       	add	r29, r24
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
    38d8:	e0 91 52 68 	lds	r30, 0x6852	; 0x806852 <pxOverflowDelayedTaskList>
    38dc:	f0 91 53 68 	lds	r31, 0x6853	; 0x806853 <pxOverflowDelayedTaskList+0x1>
	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
    38e0:	80 81       	ld	r24, Z
    38e2:	81 11       	cpse	r24, r1
    38e4:	50 c0       	rjmp	.+160    	; 0x3986 <uxTaskGetSystemState+0x114>
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
    38e6:	80 e0       	ldi	r24, 0x00	; 0
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
    38e8:	d8 0f       	add	r29, r24
	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
    38ea:	80 91 40 68 	lds	r24, 0x6840	; 0x806840 <xTasksWaitingTermination>
    38ee:	81 11       	cpse	r24, r1
    38f0:	5a c0       	rjmp	.+180    	; 0x39a6 <uxTaskGetSystemState+0x134>
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
    38f2:	80 e0       	ldi	r24, 0x00	; 0

				#if( INCLUDE_vTaskDelete == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task that has been deleted but not yet cleaned up. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
    38f4:	d8 0f       	add	r29, r24
	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
    38f6:	80 91 36 68 	lds	r24, 0x6836	; 0x806836 <xSuspendedTaskList>
    38fa:	81 11       	cpse	r24, r1
    38fc:	65 c0       	rjmp	.+202    	; 0x39c8 <uxTaskGetSystemState+0x156>
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
    38fe:	80 e0       	ldi	r24, 0x00	; 0

				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task in the Suspended state. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
    3900:	d8 0f       	add	r29, r24
				}
				#endif

				#if ( configGENERATE_RUN_TIME_STATS == 1)
				{
					if( pulTotalRunTime != NULL )
    3902:	e1 14       	cp	r14, r1
    3904:	f1 04       	cpc	r15, r1
    3906:	a9 f0       	breq	.+42     	; 0x3932 <uxTaskGetSystemState+0xc0>
					{
						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
						#else
							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
    3908:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    390c:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3910:	80 91 a2 68 	lds	r24, 0x68A2	; 0x8068a2 <StatsTimer>
    3914:	90 91 a3 68 	lds	r25, 0x68A3	; 0x8068a3 <StatsTimer+0x1>
    3918:	a0 91 a4 68 	lds	r26, 0x68A4	; 0x8068a4 <StatsTimer+0x2>
    391c:	b0 91 a5 68 	lds	r27, 0x68A5	; 0x8068a5 <StatsTimer+0x3>
    3920:	82 0f       	add	r24, r18
    3922:	93 1f       	adc	r25, r19
    3924:	a1 1d       	adc	r26, r1
    3926:	b1 1d       	adc	r27, r1
    3928:	f7 01       	movw	r30, r14
    392a:	80 83       	st	Z, r24
    392c:	91 83       	std	Z+1, r25	; 0x01
    392e:	a2 83       	std	Z+2, r26	; 0x02
    3930:	b3 83       	std	Z+3, r27	; 0x03
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		( void ) xTaskResumeAll();
    3932:	0e 94 6b 19 	call	0x32d6	; 0x32d6 <xTaskResumeAll>

		return uxTask;
	}
    3936:	8d 2f       	mov	r24, r29
    3938:	df 91       	pop	r29
    393a:	cf 91       	pop	r28
    393c:	1f 91       	pop	r17
    393e:	0f 91       	pop	r16
    3940:	ff 90       	pop	r15
    3942:	ef 90       	pop	r14
    3944:	08 95       	ret
    3946:	41 e0       	ldi	r20, 0x01	; 1
    3948:	bf 01       	movw	r22, r30
    394a:	c8 01       	movw	r24, r16
    394c:	20 e1       	ldi	r18, 0x10	; 16
    394e:	d2 9f       	mul	r29, r18
    3950:	80 0d       	add	r24, r0
    3952:	91 1d       	adc	r25, r1
    3954:	11 24       	eor	r1, r1
    3956:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <prvListTasksWithinSingleList.part.6>
    395a:	b2 cf       	rjmp	.-156    	; 0x38c0 <uxTaskGetSystemState+0x4e>

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
    395c:	d0 e0       	ldi	r29, 0x00	; 0
    395e:	e9 cf       	rjmp	.-46     	; 0x3932 <uxTaskGetSystemState+0xc0>
    3960:	42 e0       	ldi	r20, 0x02	; 2
    3962:	bf 01       	movw	r22, r30
    3964:	c8 01       	movw	r24, r16
    3966:	e0 e1       	ldi	r30, 0x10	; 16
    3968:	de 9f       	mul	r29, r30
    396a:	80 0d       	add	r24, r0
    396c:	91 1d       	adc	r25, r1
    396e:	11 24       	eor	r1, r1
    3970:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <prvListTasksWithinSingleList.part.6>

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
    3974:	d8 0f       	add	r29, r24
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
    3976:	e0 91 52 68 	lds	r30, 0x6852	; 0x806852 <pxOverflowDelayedTaskList>
    397a:	f0 91 53 68 	lds	r31, 0x6853	; 0x806853 <pxOverflowDelayedTaskList+0x1>
	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
    397e:	80 81       	ld	r24, Z
    3980:	88 23       	and	r24, r24
    3982:	09 f4       	brne	.+2      	; 0x3986 <uxTaskGetSystemState+0x114>
    3984:	b0 cf       	rjmp	.-160    	; 0x38e6 <uxTaskGetSystemState+0x74>
    3986:	42 e0       	ldi	r20, 0x02	; 2
    3988:	bf 01       	movw	r22, r30
    398a:	c8 01       	movw	r24, r16
    398c:	f0 e1       	ldi	r31, 0x10	; 16
    398e:	df 9f       	mul	r29, r31
    3990:	80 0d       	add	r24, r0
    3992:	91 1d       	adc	r25, r1
    3994:	11 24       	eor	r1, r1
    3996:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <prvListTasksWithinSingleList.part.6>
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
    399a:	d8 0f       	add	r29, r24
	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
    399c:	80 91 40 68 	lds	r24, 0x6840	; 0x806840 <xTasksWaitingTermination>
    39a0:	88 23       	and	r24, r24
    39a2:	09 f4       	brne	.+2      	; 0x39a6 <uxTaskGetSystemState+0x134>
    39a4:	a6 cf       	rjmp	.-180    	; 0x38f2 <uxTaskGetSystemState+0x80>
    39a6:	44 e0       	ldi	r20, 0x04	; 4
    39a8:	60 e4       	ldi	r22, 0x40	; 64
    39aa:	78 e6       	ldi	r23, 0x68	; 104
    39ac:	c8 01       	movw	r24, r16
    39ae:	20 e1       	ldi	r18, 0x10	; 16
    39b0:	d2 9f       	mul	r29, r18
    39b2:	80 0d       	add	r24, r0
    39b4:	91 1d       	adc	r25, r1
    39b6:	11 24       	eor	r1, r1
    39b8:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <prvListTasksWithinSingleList.part.6>

				#if( INCLUDE_vTaskDelete == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task that has been deleted but not yet cleaned up. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
    39bc:	d8 0f       	add	r29, r24
	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
    39be:	80 91 36 68 	lds	r24, 0x6836	; 0x806836 <xSuspendedTaskList>
    39c2:	88 23       	and	r24, r24
    39c4:	09 f4       	brne	.+2      	; 0x39c8 <uxTaskGetSystemState+0x156>
    39c6:	9b cf       	rjmp	.-202    	; 0x38fe <uxTaskGetSystemState+0x8c>
    39c8:	43 e0       	ldi	r20, 0x03	; 3
    39ca:	66 e3       	ldi	r22, 0x36	; 54
    39cc:	78 e6       	ldi	r23, 0x68	; 104
    39ce:	c8 01       	movw	r24, r16
    39d0:	e0 e1       	ldi	r30, 0x10	; 16
    39d2:	de 9f       	mul	r29, r30
    39d4:	80 0d       	add	r24, r0
    39d6:	91 1d       	adc	r25, r1
    39d8:	11 24       	eor	r1, r1
    39da:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <prvListTasksWithinSingleList.part.6>
    39de:	90 cf       	rjmp	.-224    	; 0x3900 <uxTaskGetSystemState+0x8e>

000039e0 <vApplicationIdleHook>:
#define CFG_ERR_LED() PORTA.DIRSET=1<<7
#define SET_ERR_LED() PORTA.OUTSET=1<<7
#define CLR_ERR_LED() PORTA.OUTCLR=1<<7

void vApplicationIdleHook( void )
{
    39e0:	08 95       	ret

000039e2 <vApplicationMallocFailedHook>:
}

void vApplicationMallocFailedHook(void)
{
	//printf ("ERROR: memory allocation failed\r\n");
	CFG_ERR_LED();
    39e2:	80 e8       	ldi	r24, 0x80	; 128
    39e4:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	taskDISABLE_INTERRUPTS();
    39e8:	f8 94       	cli
	while (1)
	{
		SET_ERR_LED();
    39ea:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    39ee:	2f ef       	ldi	r18, 0xFF	; 255
    39f0:	33 ec       	ldi	r19, 0xC3	; 195
    39f2:	99 e0       	ldi	r25, 0x09	; 9
    39f4:	21 50       	subi	r18, 0x01	; 1
    39f6:	30 40       	sbci	r19, 0x00	; 0
    39f8:	90 40       	sbci	r25, 0x00	; 0
    39fa:	e1 f7       	brne	.-8      	; 0x39f4 <vApplicationMallocFailedHook+0x12>
    39fc:	00 c0       	rjmp	.+0      	; 0x39fe <vApplicationMallocFailedHook+0x1c>
    39fe:	00 00       	nop
		_delay_ms(100);
		CLR_ERR_LED();
    3a00:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    3a04:	2f ef       	ldi	r18, 0xFF	; 255
    3a06:	33 ec       	ldi	r19, 0xC3	; 195
    3a08:	99 e0       	ldi	r25, 0x09	; 9
    3a0a:	21 50       	subi	r18, 0x01	; 1
    3a0c:	30 40       	sbci	r19, 0x00	; 0
    3a0e:	90 40       	sbci	r25, 0x00	; 0
    3a10:	e1 f7       	brne	.-8      	; 0x3a0a <vApplicationMallocFailedHook+0x28>
    3a12:	00 c0       	rjmp	.+0      	; 0x3a14 <vApplicationMallocFailedHook+0x32>
    3a14:	00 00       	nop
    3a16:	e9 cf       	rjmp	.-46     	; 0x39ea <vApplicationMallocFailedHook+0x8>

00003a18 <vApplicationStackOverflowHook>:


void vApplicationStackOverflowHook( TaskHandle_t xTask,signed char *pcTaskName )
{
	//printf ("STACK overflow:%s\r\n",pcTaskName);
	CFG_ERR_LED();
    3a18:	80 e8       	ldi	r24, 0x80	; 128
    3a1a:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	taskDISABLE_INTERRUPTS();
    3a1e:	f8 94       	cli
	while (1)
	{
		SET_ERR_LED();
    3a20:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
    3a24:	2f ef       	ldi	r18, 0xFF	; 255
    3a26:	33 ed       	ldi	r19, 0xD3	; 211
    3a28:	90 e3       	ldi	r25, 0x30	; 48
    3a2a:	21 50       	subi	r18, 0x01	; 1
    3a2c:	30 40       	sbci	r19, 0x00	; 0
    3a2e:	90 40       	sbci	r25, 0x00	; 0
    3a30:	e1 f7       	brne	.-8      	; 0x3a2a <vApplicationStackOverflowHook+0x12>
    3a32:	00 c0       	rjmp	.+0      	; 0x3a34 <vApplicationStackOverflowHook+0x1c>
    3a34:	00 00       	nop
		_delay_ms(500);
		CLR_ERR_LED();
    3a36:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    3a3a:	2f ef       	ldi	r18, 0xFF	; 255
    3a3c:	33 ed       	ldi	r19, 0xD3	; 211
    3a3e:	90 e3       	ldi	r25, 0x30	; 48
    3a40:	21 50       	subi	r18, 0x01	; 1
    3a42:	30 40       	sbci	r19, 0x00	; 0
    3a44:	90 40       	sbci	r25, 0x00	; 0
    3a46:	e1 f7       	brne	.-8      	; 0x3a40 <vApplicationStackOverflowHook+0x28>
    3a48:	00 c0       	rjmp	.+0      	; 0x3a4a <vApplicationStackOverflowHook+0x32>
    3a4a:	00 00       	nop
    3a4c:	e9 cf       	rjmp	.-46     	; 0x3a20 <vApplicationStackOverflowHook+0x8>

00003a4e <vAssertCalled>:
	}
}

void vAssertCalled( char *File, int Line)
{
	CFG_ERR_LED();
    3a4e:	80 e8       	ldi	r24, 0x80	; 128
    3a50:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	taskDISABLE_INTERRUPTS();
    3a54:	f8 94       	cli
	//printf ("Assert file in file %s, line nr %d\r\n",File,Line);
	while (1)
	{
		SET_ERR_LED();
    3a56:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
    3a5a:	2f ef       	ldi	r18, 0xFF	; 255
    3a5c:	33 ec       	ldi	r19, 0xC3	; 195
    3a5e:	99 e0       	ldi	r25, 0x09	; 9
    3a60:	21 50       	subi	r18, 0x01	; 1
    3a62:	30 40       	sbci	r19, 0x00	; 0
    3a64:	90 40       	sbci	r25, 0x00	; 0
    3a66:	e1 f7       	brne	.-8      	; 0x3a60 <vAssertCalled+0x12>
    3a68:	00 c0       	rjmp	.+0      	; 0x3a6a <vAssertCalled+0x1c>
    3a6a:	00 00       	nop
		_delay_ms(100);
		CLR_ERR_LED();
    3a6c:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    3a70:	2f ef       	ldi	r18, 0xFF	; 255
    3a72:	33 ed       	ldi	r19, 0xD3	; 211
    3a74:	90 e3       	ldi	r25, 0x30	; 48
    3a76:	21 50       	subi	r18, 0x01	; 1
    3a78:	30 40       	sbci	r19, 0x00	; 0
    3a7a:	90 40       	sbci	r25, 0x00	; 0
    3a7c:	e1 f7       	brne	.-8      	; 0x3a76 <vAssertCalled+0x28>
    3a7e:	00 c0       	rjmp	.+0      	; 0x3a80 <vAssertCalled+0x32>
    3a80:	00 00       	nop
    3a82:	e9 cf       	rjmp	.-46     	; 0x3a56 <vAssertCalled+0x8>

00003a84 <main>:
#include <util/delay.h>

#include <stdio.h>

int main(void)
{
    3a84:	cf 93       	push	r28
    3a86:	df 93       	push	r29
    3a88:	cd b7       	in	r28, 0x3d	; 61
    3a8a:	de b7       	in	r29, 0x3e	; 62
    3a8c:	2c 97       	sbiw	r28, 0x0c	; 12
    3a8e:	cd bf       	out	0x3d, r28	; 61
    3a90:	de bf       	out	0x3e, r29	; 62
	uint8_t res;
	
	DriverSysClkXtalInit();	//Clock init
    3a92:	0e 94 d1 0a 	call	0x15a2	; 0x15a2 <DriverSysClkXtalInit>
	USARTInit();			//USART init and link to stdio
    3a96:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <USARTInit>
	DriverTWIMInit();		//Initialize TWI in master mode
    3a9a:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <DriverTWIMInit>
	DriverCursorstickInit();//Initialize cursor stick
    3a9e:	0e 94 10 03 	call	0x620	; 0x620 <DriverCursorstickInit>
	DriverLedInit();		//Initialize LED's
    3aa2:	0e 94 21 03 	call	0x642	; 0x642 <DriverLedInit>
	DriverPowerInit();		//Initialize aux power driver
    3aa6:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DriverPowerInit>
	DriverPL9823Init();		//Initialize PL9823 LEDs
    3aaa:	0e 94 55 0a 	call	0x14aa	; 0x14aa <DriverPL9823Init>
	DriverAdcInit();		//Initialize ADC driver
    3aae:	0e 94 b0 01 	call	0x360	; 0x360 <DriverAdcInit>

	DriverPowerVccAuxSet(1);//Enable Auxillary power line
    3ab2:	81 e0       	ldi	r24, 0x01	; 1
    3ab4:	0e 94 c7 0a 	call	0x158e	; 0x158e <DriverPowerVccAuxSet>
	
	//printf ("Start init\r\n");

	//Enable interrupts
	PMIC.CTRL=0b111;		
    3ab8:	87 e0       	ldi	r24, 0x07	; 7
    3aba:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3abe:	78 94       	sei
    3ac0:	2f ef       	ldi	r18, 0xFF	; 255
    3ac2:	89 ef       	ldi	r24, 0xF9	; 249
    3ac4:	90 e0       	ldi	r25, 0x00	; 0
    3ac6:	21 50       	subi	r18, 0x01	; 1
    3ac8:	80 40       	sbci	r24, 0x00	; 0
    3aca:	90 40       	sbci	r25, 0x00	; 0
    3acc:	e1 f7       	brne	.-8      	; 0x3ac6 <main+0x42>
    3ace:	00 c0       	rjmp	.+0      	; 0x3ad0 <main+0x4c>
    3ad0:	00 00       	nop

	_delay_ms(10);
	
	uint8_t r[]={255,0,0,255};
    3ad2:	8f ef       	ldi	r24, 0xFF	; 255
    3ad4:	89 87       	std	Y+9, r24	; 0x09
    3ad6:	1a 86       	std	Y+10, r1	; 0x0a
    3ad8:	1b 86       	std	Y+11, r1	; 0x0b
    3ada:	8c 87       	std	Y+12, r24	; 0x0c
	uint8_t g[]={0,255,0,255};
    3adc:	1d 82       	std	Y+5, r1	; 0x05
    3ade:	8e 83       	std	Y+6, r24	; 0x06
    3ae0:	1f 82       	std	Y+7, r1	; 0x07
    3ae2:	88 87       	std	Y+8, r24	; 0x08
	uint8_t b[]={0,0,255,255};
    3ae4:	19 82       	std	Y+1, r1	; 0x01
    3ae6:	1a 82       	std	Y+2, r1	; 0x02
    3ae8:	8b 83       	std	Y+3, r24	; 0x03
    3aea:	8c 83       	std	Y+4, r24	; 0x04
	DriverPL9823Set(r,g,b);
    3aec:	ae 01       	movw	r20, r28
    3aee:	4f 5f       	subi	r20, 0xFF	; 255
    3af0:	5f 4f       	sbci	r21, 0xFF	; 255
    3af2:	be 01       	movw	r22, r28
    3af4:	6b 5f       	subi	r22, 0xFB	; 251
    3af6:	7f 4f       	sbci	r23, 0xFF	; 255
    3af8:	ce 01       	movw	r24, r28
    3afa:	09 96       	adiw	r24, 0x09	; 9
    3afc:	0e 94 67 0a 	call	0x14ce	; 0x14ce <DriverPL9823Set>
	//Init tasks
	InitOLEDMenuTask();
    3b00:	0e 94 2a 20 	call	0x4054	; 0x4054 <InitOLEDMenuTask>
	InitADCTask();
    3b04:	0e 94 cb 1d 	call	0x3b96	; 0x3b96 <InitADCTask>
	InitMotorSpeedTask();
    3b08:	0e 94 f0 1f 	call	0x3fe0	; 0x3fe0 <InitMotorSpeedTask>
	InitLineFollowerTask();
    3b0c:	0e 94 ab 1e 	call	0x3d56	; 0x3d56 <InitLineFollowerTask>
		
	//printf ("Init complete\r\n");
	
	vTaskStartScheduler();	//Start scheduler loop
    3b10:	0e 94 38 18 	call	0x3070	; 0x3070 <vTaskStartScheduler>

	return 0;
}
    3b14:	80 e0       	ldi	r24, 0x00	; 0
    3b16:	90 e0       	ldi	r25, 0x00	; 0
    3b18:	2c 96       	adiw	r28, 0x0c	; 12
    3b1a:	cd bf       	out	0x3d, r28	; 61
    3b1c:	de bf       	out	0x3e, r29	; 62
    3b1e:	df 91       	pop	r29
    3b20:	cf 91       	pop	r28
    3b22:	08 95       	ret

00003b24 <WorkerADC>:
	ADCQueue=xQueueCreate(1,sizeof(ADCStruct));
	xTaskCreate( WorkerADC, "ADC", 512, NULL, tskIDLE_PRIORITY+2, NULL );
}

void WorkerADC(void *pvParameters)
{
    3b24:	cf 93       	push	r28
    3b26:	df 93       	push	r29
    3b28:	cd b7       	in	r28, 0x3d	; 61
    3b2a:	de b7       	in	r29, 0x3e	; 62
    3b2c:	2a 97       	sbiw	r28, 0x0a	; 10
    3b2e:	cd bf       	out	0x3d, r28	; 61
    3b30:	de bf       	out	0x3e, r29	; 62
	TickType_t xLastWakeTime;
	const TickType_t xPeriod = 10;
	ADCStruct ADCData;
	DriverLedSet(0b0111);
    3b32:	87 e0       	ldi	r24, 0x07	; 7
    3b34:	0e 94 2f 03 	call	0x65e	; 0x65e <DriverLedSet>
	
	xLastWakeTime=xTaskGetTickCount();
    3b38:	0e 94 75 18 	call	0x30ea	; 0x30ea <xTaskGetTickCount>
    3b3c:	89 87       	std	Y+9, r24	; 0x09
    3b3e:	9a 87       	std	Y+10, r25	; 0x0a
	while(1)
	{
		ADCData.PhotoL=DriverAdcGetCh(0,4);
    3b40:	64 e0       	ldi	r22, 0x04	; 4
    3b42:	80 e0       	ldi	r24, 0x00	; 0
    3b44:	0e 94 d7 01 	call	0x3ae	; 0x3ae <DriverAdcGetCh>
    3b48:	89 83       	std	Y+1, r24	; 0x01
    3b4a:	9a 83       	std	Y+2, r25	; 0x02
		ADCData.PhotoM=DriverAdcGetCh(1,4);
    3b4c:	64 e0       	ldi	r22, 0x04	; 4
    3b4e:	81 e0       	ldi	r24, 0x01	; 1
    3b50:	0e 94 d7 01 	call	0x3ae	; 0x3ae <DriverAdcGetCh>
    3b54:	8b 83       	std	Y+3, r24	; 0x03
    3b56:	9c 83       	std	Y+4, r25	; 0x04
		ADCData.PhotoR=DriverAdcGetCh(2,4);
    3b58:	64 e0       	ldi	r22, 0x04	; 4
    3b5a:	82 e0       	ldi	r24, 0x02	; 2
    3b5c:	0e 94 d7 01 	call	0x3ae	; 0x3ae <DriverAdcGetCh>
    3b60:	8d 83       	std	Y+5, r24	; 0x05
    3b62:	9e 83       	std	Y+6, r25	; 0x06
		ADCData.Potmeter=DriverAdcGetCh(3,4);
    3b64:	64 e0       	ldi	r22, 0x04	; 4
    3b66:	83 e0       	ldi	r24, 0x03	; 3
    3b68:	0e 94 d7 01 	call	0x3ae	; 0x3ae <DriverAdcGetCh>
    3b6c:	8f 83       	std	Y+7, r24	; 0x07
    3b6e:	98 87       	std	Y+8, r25	; 0x08
		xQueueOverwrite(ADCQueue,&ADCData);
    3b70:	22 e0       	ldi	r18, 0x02	; 2
    3b72:	40 e0       	ldi	r20, 0x00	; 0
    3b74:	50 e0       	ldi	r21, 0x00	; 0
    3b76:	be 01       	movw	r22, r28
    3b78:	6f 5f       	subi	r22, 0xFF	; 255
    3b7a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b7c:	80 91 a6 68 	lds	r24, 0x68A6	; 0x8068a6 <ADCQueue>
    3b80:	90 91 a7 68 	lds	r25, 0x68A7	; 0x8068a7 <ADCQueue+0x1>
    3b84:	0e 94 71 11 	call	0x22e2	; 0x22e2 <xQueueGenericSend>
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    3b88:	6a e0       	ldi	r22, 0x0A	; 10
    3b8a:	70 e0       	ldi	r23, 0x00	; 0
    3b8c:	ce 01       	movw	r24, r28
    3b8e:	09 96       	adiw	r24, 0x09	; 9
    3b90:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <vTaskDelayUntil>
    3b94:	d5 cf       	rjmp	.-86     	; 0x3b40 <WorkerADC+0x1c>

00003b96 <InitADCTask>:

void WorkerADC(void *pvParameters);

//Function definitions
void InitADCTask()
{
    3b96:	ef 92       	push	r14
    3b98:	ff 92       	push	r15
    3b9a:	0f 93       	push	r16
	ADCQueue=xQueueCreate(1,sizeof(ADCStruct));
    3b9c:	40 e0       	ldi	r20, 0x00	; 0
    3b9e:	68 e0       	ldi	r22, 0x08	; 8
    3ba0:	81 e0       	ldi	r24, 0x01	; 1
    3ba2:	0e 94 2d 11 	call	0x225a	; 0x225a <xQueueGenericCreate>
    3ba6:	80 93 a6 68 	sts	0x68A6, r24	; 0x8068a6 <ADCQueue>
    3baa:	90 93 a7 68 	sts	0x68A7, r25	; 0x8068a7 <ADCQueue+0x1>
	xTaskCreate( WorkerADC, "ADC", 512, NULL, tskIDLE_PRIORITY+2, NULL );
    3bae:	e1 2c       	mov	r14, r1
    3bb0:	f1 2c       	mov	r15, r1
    3bb2:	02 e0       	ldi	r16, 0x02	; 2
    3bb4:	20 e0       	ldi	r18, 0x00	; 0
    3bb6:	30 e0       	ldi	r19, 0x00	; 0
    3bb8:	40 e0       	ldi	r20, 0x00	; 0
    3bba:	52 e0       	ldi	r21, 0x02	; 2
    3bbc:	62 ee       	ldi	r22, 0xE2	; 226
    3bbe:	72 e2       	ldi	r23, 0x22	; 34
    3bc0:	82 e9       	ldi	r24, 0x92	; 146
    3bc2:	9d e1       	ldi	r25, 0x1D	; 29
    3bc4:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <xTaskCreate>
}
    3bc8:	0f 91       	pop	r16
    3bca:	ff 90       	pop	r15
    3bcc:	ef 90       	pop	r14
    3bce:	08 95       	ret

00003bd0 <GetADCData>:
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
	}
}

ADCStruct GetADCData(void)
{
    3bd0:	cf 93       	push	r28
    3bd2:	df 93       	push	r29
    3bd4:	cd b7       	in	r28, 0x3d	; 61
    3bd6:	de b7       	in	r29, 0x3e	; 62
    3bd8:	60 97       	sbiw	r28, 0x10	; 16
    3bda:	cd bf       	out	0x3d, r28	; 61
    3bdc:	de bf       	out	0x3e, r29	; 62
	ADCStruct ADCData;
	xQueuePeek(ADCQueue,&ADCData,portMAX_DELAY);
    3bde:	4f ef       	ldi	r20, 0xFF	; 255
    3be0:	5f ef       	ldi	r21, 0xFF	; 255
    3be2:	be 01       	movw	r22, r28
    3be4:	67 5f       	subi	r22, 0xF7	; 247
    3be6:	7f 4f       	sbci	r23, 0xFF	; 255
    3be8:	80 91 a6 68 	lds	r24, 0x68A6	; 0x8068a6 <ADCQueue>
    3bec:	90 91 a7 68 	lds	r25, 0x68A7	; 0x8068a7 <ADCQueue+0x1>
    3bf0:	0e 94 57 14 	call	0x28ae	; 0x28ae <xQueuePeek>
	return ADCData;
    3bf4:	88 e0       	ldi	r24, 0x08	; 8
    3bf6:	fe 01       	movw	r30, r28
    3bf8:	39 96       	adiw	r30, 0x09	; 9
    3bfa:	de 01       	movw	r26, r28
    3bfc:	11 96       	adiw	r26, 0x01	; 1
    3bfe:	01 90       	ld	r0, Z+
    3c00:	0d 92       	st	X+, r0
    3c02:	8a 95       	dec	r24
    3c04:	e1 f7       	brne	.-8      	; 0x3bfe <GetADCData+0x2e>
    3c06:	29 81       	ldd	r18, Y+1	; 0x01
    3c08:	3a 81       	ldd	r19, Y+2	; 0x02
    3c0a:	4b 81       	ldd	r20, Y+3	; 0x03
    3c0c:	5c 81       	ldd	r21, Y+4	; 0x04
    3c0e:	6d 81       	ldd	r22, Y+5	; 0x05
    3c10:	7e 81       	ldd	r23, Y+6	; 0x06
    3c12:	8f 81       	ldd	r24, Y+7	; 0x07
    3c14:	98 85       	ldd	r25, Y+8	; 0x08
    3c16:	60 96       	adiw	r28, 0x10	; 16
    3c18:	cd bf       	out	0x3d, r28	; 61
    3c1a:	de bf       	out	0x3e, r29	; 62
    3c1c:	df 91       	pop	r29
    3c1e:	cf 91       	pop	r28
    3c20:	08 95       	ret

00003c22 <WorkerLineFollower>:
	StopSema=xSemaphoreCreateBinary();
	xTaskCreate( WorkerLineFollower, "LFollow", 512, NULL, tskIDLE_PRIORITY+2, NULL );
}

void WorkerLineFollower(void *pvParameters)
{
    3c22:	cf 93       	push	r28
    3c24:	df 93       	push	r29
    3c26:	cd b7       	in	r28, 0x3d	; 61
    3c28:	de b7       	in	r29, 0x3e	; 62
    3c2a:	2a 97       	sbiw	r28, 0x0a	; 10
    3c2c:	cd bf       	out	0x3d, r28	; 61
    3c2e:	de bf       	out	0x3e, r29	; 62
	float OutL,OutR;
	ADCStruct ADCData;
	
	while(1)
	{
		xSemaphoreTake(StartSema,portMAX_DELAY);
    3c30:	6f ef       	ldi	r22, 0xFF	; 255
    3c32:	7f ef       	ldi	r23, 0xFF	; 255
    3c34:	80 91 90 68 	lds	r24, 0x6890	; 0x806890 <StartSema>
    3c38:	90 91 91 68 	lds	r25, 0x6891	; 0x806891 <StartSema+0x1>
    3c3c:	0e 94 ab 13 	call	0x2756	; 0x2756 <xQueueSemaphoreTake>
		Speed=ReqSpeed;
    3c40:	80 91 a8 68 	lds	r24, 0x68A8	; 0x8068a8 <ReqSpeed>
    3c44:	90 91 a9 68 	lds	r25, 0x68A9	; 0x8068a9 <ReqSpeed+0x1>
    3c48:	a0 91 aa 68 	lds	r26, 0x68AA	; 0x8068aa <ReqSpeed+0x2>
    3c4c:	b0 91 ab 68 	lds	r27, 0x68AB	; 0x8068ab <ReqSpeed+0x3>
    3c50:	80 93 92 68 	sts	0x6892, r24	; 0x806892 <Speed>
    3c54:	90 93 93 68 	sts	0x6893, r25	; 0x806893 <Speed+0x1>
    3c58:	a0 93 94 68 	sts	0x6894, r26	; 0x806894 <Speed+0x2>
    3c5c:	b0 93 95 68 	sts	0x6895, r27	; 0x806895 <Speed+0x3>
		xLastWakeTime=xTaskGetTickCount();
    3c60:	0e 94 75 18 	call	0x30ea	; 0x30ea <xTaskGetTickCount>
    3c64:	89 87       	std	Y+9, r24	; 0x09
    3c66:	9a 87       	std	Y+10, r25	; 0x0a
    3c68:	18 c0       	rjmp	.+48     	; 0x3c9a <WorkerLineFollower+0x78>
    3c6a:	c5 01       	movw	r24, r10
    3c6c:	b4 01       	movw	r22, r8
    3c6e:	0e 94 b3 24 	call	0x4966	; 0x4966 <__fixsfsi>
			Diff=(float) (ADCData.PhotoL-ADCData.PhotoR+SensorOffset);
			OutL=Speed+(Diff*LineFollowKp);
			OutR=Speed-(Diff*LineFollowKp);
			if (OutL<0) OutL=0;
			if (OutR<0) OutR=0;
			MotorSpeedSet((int16_t) OutL, (int16_t) OutR);	
    3c72:	c7 01       	movw	r24, r14
    3c74:	0e 94 1a 20 	call	0x4034	; 0x4034 <MotorSpeedSet>
			
			if (xSemaphoreTake(StopSema,0)==pdPASS)
    3c78:	60 e0       	ldi	r22, 0x00	; 0
    3c7a:	70 e0       	ldi	r23, 0x00	; 0
    3c7c:	80 91 8e 68 	lds	r24, 0x688E	; 0x80688e <StopSema>
    3c80:	90 91 8f 68 	lds	r25, 0x688F	; 0x80688f <StopSema+0x1>
    3c84:	0e 94 ab 13 	call	0x2756	; 0x2756 <xQueueSemaphoreTake>
    3c88:	81 30       	cpi	r24, 0x01	; 1
    3c8a:	09 f4       	brne	.+2      	; 0x3c8e <WorkerLineFollower+0x6c>
    3c8c:	5d c0       	rjmp	.+186    	; 0x3d48 <WorkerLineFollower+0x126>
			{
				MotorSpeedSet(0,0);	
				break;
			}
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
    3c8e:	6a e0       	ldi	r22, 0x0A	; 10
    3c90:	70 e0       	ldi	r23, 0x00	; 0
    3c92:	ce 01       	movw	r24, r28
    3c94:	09 96       	adiw	r24, 0x09	; 9
    3c96:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <vTaskDelayUntil>
		xSemaphoreTake(StartSema,portMAX_DELAY);
		Speed=ReqSpeed;
		xLastWakeTime=xTaskGetTickCount();
		while (1)
		{
			printf ("*");
    3c9a:	8a e2       	ldi	r24, 0x2A	; 42
    3c9c:	90 e0       	ldi	r25, 0x00	; 0
    3c9e:	0e 94 18 2b 	call	0x5630	; 0x5630 <putchar>
			ADCData=GetADCData();
    3ca2:	0e 94 e8 1d 	call	0x3bd0	; 0x3bd0 <GetADCData>
    3ca6:	29 83       	std	Y+1, r18	; 0x01
    3ca8:	3a 83       	std	Y+2, r19	; 0x02
    3caa:	6d 83       	std	Y+5, r22	; 0x05
    3cac:	7e 83       	std	Y+6, r23	; 0x06
			Diff=(float) (ADCData.PhotoL-ADCData.PhotoR+SensorOffset);
			OutL=Speed+(Diff*LineFollowKp);
    3cae:	69 81       	ldd	r22, Y+1	; 0x01
    3cb0:	7a 81       	ldd	r23, Y+2	; 0x02
    3cb2:	8d 81       	ldd	r24, Y+5	; 0x05
    3cb4:	9e 81       	ldd	r25, Y+6	; 0x06
    3cb6:	68 1b       	sub	r22, r24
    3cb8:	79 0b       	sbc	r23, r25
    3cba:	80 91 96 68 	lds	r24, 0x6896	; 0x806896 <SensorOffset>
    3cbe:	90 91 97 68 	lds	r25, 0x6897	; 0x806897 <SensorOffset+0x1>
    3cc2:	68 0f       	add	r22, r24
    3cc4:	79 1f       	adc	r23, r25
    3cc6:	07 2e       	mov	r0, r23
    3cc8:	00 0c       	add	r0, r0
    3cca:	88 0b       	sbc	r24, r24
    3ccc:	99 0b       	sbc	r25, r25
    3cce:	0e 94 eb 24 	call	0x49d6	; 0x49d6 <__floatsisf>
    3cd2:	2a e0       	ldi	r18, 0x0A	; 10
    3cd4:	37 ed       	ldi	r19, 0xD7	; 215
    3cd6:	43 ea       	ldi	r20, 0xA3	; 163
    3cd8:	5d e3       	ldi	r21, 0x3D	; 61
    3cda:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <__mulsf3>
    3cde:	4b 01       	movw	r8, r22
    3ce0:	5c 01       	movw	r10, r24
    3ce2:	c0 90 92 68 	lds	r12, 0x6892	; 0x806892 <Speed>
    3ce6:	d0 90 93 68 	lds	r13, 0x6893	; 0x806893 <Speed+0x1>
    3cea:	e0 90 94 68 	lds	r14, 0x6894	; 0x806894 <Speed+0x2>
    3cee:	f0 90 95 68 	lds	r15, 0x6895	; 0x806895 <Speed+0x3>
    3cf2:	a7 01       	movw	r20, r14
    3cf4:	96 01       	movw	r18, r12
    3cf6:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <__addsf3>
    3cfa:	2b 01       	movw	r4, r22
    3cfc:	3c 01       	movw	r6, r24
			OutR=Speed-(Diff*LineFollowKp);
    3cfe:	a5 01       	movw	r20, r10
    3d00:	94 01       	movw	r18, r8
    3d02:	c7 01       	movw	r24, r14
    3d04:	b6 01       	movw	r22, r12
    3d06:	0e 94 cf 23 	call	0x479e	; 0x479e <__subsf3>
    3d0a:	4b 01       	movw	r8, r22
    3d0c:	5c 01       	movw	r10, r24
			if (OutL<0) OutL=0;
    3d0e:	20 e0       	ldi	r18, 0x00	; 0
    3d10:	30 e0       	ldi	r19, 0x00	; 0
    3d12:	a9 01       	movw	r20, r18
    3d14:	c3 01       	movw	r24, r6
    3d16:	b2 01       	movw	r22, r4
    3d18:	0e 94 3c 24 	call	0x4878	; 0x4878 <__cmpsf2>
    3d1c:	87 ff       	sbrs	r24, 7
    3d1e:	0e c0       	rjmp	.+28     	; 0x3d3c <WorkerLineFollower+0x11a>
    3d20:	e1 2c       	mov	r14, r1
    3d22:	f1 2c       	mov	r15, r1
			if (OutR<0) OutR=0;
    3d24:	20 e0       	ldi	r18, 0x00	; 0
    3d26:	30 e0       	ldi	r19, 0x00	; 0
    3d28:	a9 01       	movw	r20, r18
    3d2a:	c5 01       	movw	r24, r10
    3d2c:	b4 01       	movw	r22, r8
    3d2e:	0e 94 3c 24 	call	0x4878	; 0x4878 <__cmpsf2>
    3d32:	87 ff       	sbrs	r24, 7
    3d34:	9a cf       	rjmp	.-204    	; 0x3c6a <WorkerLineFollower+0x48>
    3d36:	60 e0       	ldi	r22, 0x00	; 0
    3d38:	70 e0       	ldi	r23, 0x00	; 0
    3d3a:	9b cf       	rjmp	.-202    	; 0x3c72 <WorkerLineFollower+0x50>
    3d3c:	c3 01       	movw	r24, r6
    3d3e:	b2 01       	movw	r22, r4
    3d40:	0e 94 b3 24 	call	0x4966	; 0x4966 <__fixsfsi>
    3d44:	7b 01       	movw	r14, r22
    3d46:	ee cf       	rjmp	.-36     	; 0x3d24 <WorkerLineFollower+0x102>
			MotorSpeedSet((int16_t) OutL, (int16_t) OutR);	
			
			if (xSemaphoreTake(StopSema,0)==pdPASS)
			{
				MotorSpeedSet(0,0);	
    3d48:	60 e0       	ldi	r22, 0x00	; 0
    3d4a:	70 e0       	ldi	r23, 0x00	; 0
    3d4c:	80 e0       	ldi	r24, 0x00	; 0
    3d4e:	90 e0       	ldi	r25, 0x00	; 0
    3d50:	0e 94 1a 20 	call	0x4034	; 0x4034 <MotorSpeedSet>
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
		}

		
		
	}
    3d54:	6d cf       	rjmp	.-294    	; 0x3c30 <WorkerLineFollower+0xe>

00003d56 <InitLineFollowerTask>:
void WorkerLineFollower(void *pvParameters);


//Function definitions
void InitLineFollowerTask()
{
    3d56:	ef 92       	push	r14
    3d58:	ff 92       	push	r15
    3d5a:	0f 93       	push	r16
	StartSema=xSemaphoreCreateBinary();
    3d5c:	43 e0       	ldi	r20, 0x03	; 3
    3d5e:	60 e0       	ldi	r22, 0x00	; 0
    3d60:	81 e0       	ldi	r24, 0x01	; 1
    3d62:	0e 94 2d 11 	call	0x225a	; 0x225a <xQueueGenericCreate>
    3d66:	80 93 90 68 	sts	0x6890, r24	; 0x806890 <StartSema>
    3d6a:	90 93 91 68 	sts	0x6891, r25	; 0x806891 <StartSema+0x1>
	StopSema=xSemaphoreCreateBinary();
    3d6e:	43 e0       	ldi	r20, 0x03	; 3
    3d70:	60 e0       	ldi	r22, 0x00	; 0
    3d72:	81 e0       	ldi	r24, 0x01	; 1
    3d74:	0e 94 2d 11 	call	0x225a	; 0x225a <xQueueGenericCreate>
    3d78:	80 93 8e 68 	sts	0x688E, r24	; 0x80688e <StopSema>
    3d7c:	90 93 8f 68 	sts	0x688F, r25	; 0x80688f <StopSema+0x1>
	xTaskCreate( WorkerLineFollower, "LFollow", 512, NULL, tskIDLE_PRIORITY+2, NULL );
    3d80:	e1 2c       	mov	r14, r1
    3d82:	f1 2c       	mov	r15, r1
    3d84:	02 e0       	ldi	r16, 0x02	; 2
    3d86:	20 e0       	ldi	r18, 0x00	; 0
    3d88:	30 e0       	ldi	r19, 0x00	; 0
    3d8a:	40 e0       	ldi	r20, 0x00	; 0
    3d8c:	52 e0       	ldi	r21, 0x02	; 2
    3d8e:	66 ee       	ldi	r22, 0xE6	; 230
    3d90:	72 e2       	ldi	r23, 0x22	; 34
    3d92:	81 e1       	ldi	r24, 0x11	; 17
    3d94:	9e e1       	ldi	r25, 0x1E	; 30
    3d96:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <xTaskCreate>
}
    3d9a:	0f 91       	pop	r16
    3d9c:	ff 90       	pop	r15
    3d9e:	ef 90       	pop	r14
    3da0:	08 95       	ret

00003da2 <StartLineFollower>:
	}
}

void StartLineFollower(float Speed)
{
	ReqSpeed=Speed;
    3da2:	60 93 a8 68 	sts	0x68A8, r22	; 0x8068a8 <ReqSpeed>
    3da6:	70 93 a9 68 	sts	0x68A9, r23	; 0x8068a9 <ReqSpeed+0x1>
    3daa:	80 93 aa 68 	sts	0x68AA, r24	; 0x8068aa <ReqSpeed+0x2>
    3dae:	90 93 ab 68 	sts	0x68AB, r25	; 0x8068ab <ReqSpeed+0x3>
	xSemaphoreGive(StartSema);
    3db2:	20 e0       	ldi	r18, 0x00	; 0
    3db4:	40 e0       	ldi	r20, 0x00	; 0
    3db6:	50 e0       	ldi	r21, 0x00	; 0
    3db8:	60 e0       	ldi	r22, 0x00	; 0
    3dba:	70 e0       	ldi	r23, 0x00	; 0
    3dbc:	80 91 90 68 	lds	r24, 0x6890	; 0x806890 <StartSema>
    3dc0:	90 91 91 68 	lds	r25, 0x6891	; 0x806891 <StartSema+0x1>
    3dc4:	0c 94 71 11 	jmp	0x22e2	; 0x22e2 <xQueueGenericSend>

00003dc8 <StopLineFollower>:
	
}
void StopLineFollower()
{
	xSemaphoreGive(StopSema);
    3dc8:	20 e0       	ldi	r18, 0x00	; 0
    3dca:	40 e0       	ldi	r20, 0x00	; 0
    3dcc:	50 e0       	ldi	r21, 0x00	; 0
    3dce:	60 e0       	ldi	r22, 0x00	; 0
    3dd0:	70 e0       	ldi	r23, 0x00	; 0
    3dd2:	80 91 8e 68 	lds	r24, 0x688E	; 0x80688e <StopSema>
    3dd6:	90 91 8f 68 	lds	r25, 0x688F	; 0x80688f <StopSema+0x1>
    3dda:	0c 94 71 11 	jmp	0x22e2	; 0x22e2 <xQueueGenericSend>

00003dde <WorkerMotorSpeed>:
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
	
}

void WorkerMotorSpeed(void *pvParameters)
{
    3dde:	cf 93       	push	r28
    3de0:	df 93       	push	r29
    3de2:	cd b7       	in	r28, 0x3d	; 61
    3de4:	de b7       	in	r29, 0x3e	; 62
    3de6:	2c 97       	sbiw	r28, 0x0c	; 12
    3de8:	cd bf       	out	0x3d, r28	; 61
    3dea:	de bf       	out	0x3e, r29	; 62
	uint8_t Inv1,Inv2;
	
	EncoderStruct EncoderInfo;
	MotorSpeedStruct MotorSpeed;

	xLastWakeTime = xTaskGetTickCount();
    3dec:	0e 94 75 18 	call	0x30ea	; 0x30ea <xTaskGetTickCount>
    3df0:	8d 83       	std	Y+5, r24	; 0x05
    3df2:	9e 83       	std	Y+6, r25	; 0x06
{
	TickType_t xLastWakeTime;
	const TickType_t xPeriod = 10;
	int16_t Out1,Out2;
	int16_t Err1=0,Err2=0;
	int32_t Err1Int=0,Err2Int=0;
    3df4:	c1 2c       	mov	r12, r1
    3df6:	d1 2c       	mov	r13, r1
    3df8:	76 01       	movw	r14, r12
    3dfa:	21 2c       	mov	r2, r1
    3dfc:	31 2c       	mov	r3, r1
    3dfe:	21 01       	movw	r4, r2
    3e00:	c0 c0       	rjmp	.+384    	; 0x3f82 <WorkerMotorSpeed+0x1a4>
			{
				MotorSpeed.Speed1=-MotorSpeed.Speed1;
				Inv1=1;
			}
			else
				Inv1=0;
    3e02:	1b 86       	std	Y+11, r1	; 0x0b
				
			if (MotorSpeed.Speed2<0)
    3e04:	2b 81       	ldd	r18, Y+3	; 0x03
    3e06:	3c 81       	ldd	r19, Y+4	; 0x04
    3e08:	37 fd       	sbrc	r19, 7
    3e0a:	dc c0       	rjmp	.+440    	; 0x3fc4 <WorkerMotorSpeed+0x1e6>
			{
				MotorSpeed.Speed2=-MotorSpeed.Speed2;
				Inv2=1;
			}
			else
				Inv2=0;
    3e0c:	1c 86       	std	Y+12, r1	; 0x0c
			
			
			//PI controller
			Err1=(MotorSpeed.Speed1-EncoderInfo.Speed1);
    3e0e:	3c 01       	movw	r6, r24
    3e10:	68 18       	sub	r6, r8
    3e12:	79 08       	sbc	r7, r9
			if (EncoderInfo.Speed1!=-1) Err1Int=Err1Int+Err1;
    3e14:	4f 81       	ldd	r20, Y+7	; 0x07
    3e16:	58 85       	ldd	r21, Y+8	; 0x08
    3e18:	4f 3f       	cpi	r20, 0xFF	; 255
    3e1a:	5f 4f       	sbci	r21, 0xFF	; 255
    3e1c:	49 f0       	breq	.+18     	; 0x3e30 <WorkerMotorSpeed+0x52>
    3e1e:	a3 01       	movw	r20, r6
    3e20:	07 2c       	mov	r0, r7
    3e22:	00 0c       	add	r0, r0
    3e24:	66 0b       	sbc	r22, r22
    3e26:	77 0b       	sbc	r23, r23
    3e28:	24 0e       	add	r2, r20
    3e2a:	35 1e       	adc	r3, r21
    3e2c:	46 1e       	adc	r4, r22
    3e2e:	57 1e       	adc	r5, r23
			printf (">%d %d\r\n",MotorSpeed.Speed1,MotorSpeed.Speed2);
    3e30:	3f 93       	push	r19
    3e32:	2f 93       	push	r18
    3e34:	9f 93       	push	r25
    3e36:	8f 93       	push	r24
    3e38:	8e ee       	ldi	r24, 0xEE	; 238
    3e3a:	92 e2       	ldi	r25, 0x22	; 34
    3e3c:	9f 93       	push	r25
    3e3e:	8f 93       	push	r24
    3e40:	0e 94 04 2b 	call	0x5608	; 0x5608 <printf>
    3e44:	d2 01       	movw	r26, r4
    3e46:	c1 01       	movw	r24, r2
    3e48:	0f 90       	pop	r0
    3e4a:	0f 90       	pop	r0
    3e4c:	0f 90       	pop	r0
    3e4e:	0f 90       	pop	r0
    3e50:	0f 90       	pop	r0
    3e52:	0f 90       	pop	r0
    3e54:	21 14       	cp	r2, r1
    3e56:	40 e6       	ldi	r20, 0x60	; 96
    3e58:	34 06       	cpc	r3, r20
    3e5a:	4f ef       	ldi	r20, 0xFF	; 255
    3e5c:	44 06       	cpc	r4, r20
    3e5e:	54 06       	cpc	r5, r20
    3e60:	24 f4       	brge	.+8      	; 0x3e6a <WorkerMotorSpeed+0x8c>
    3e62:	80 e0       	ldi	r24, 0x00	; 0
    3e64:	90 e6       	ldi	r25, 0x60	; 96
    3e66:	af ef       	ldi	r26, 0xFF	; 255
    3e68:	bf ef       	ldi	r27, 0xFF	; 255
    3e6a:	1c 01       	movw	r2, r24
    3e6c:	2d 01       	movw	r4, r26
    3e6e:	81 30       	cpi	r24, 0x01	; 1
    3e70:	90 4a       	sbci	r25, 0xA0	; 160
    3e72:	a1 05       	cpc	r26, r1
    3e74:	b1 05       	cpc	r27, r1
    3e76:	2c f0       	brlt	.+10     	; 0x3e82 <WorkerMotorSpeed+0xa4>
    3e78:	21 2c       	mov	r2, r1
    3e7a:	40 ea       	ldi	r20, 0xA0	; 160
    3e7c:	34 2e       	mov	r3, r20
    3e7e:	41 2c       	mov	r4, r1
    3e80:	51 2c       	mov	r5, r1
			if (Err1Int>MOTSPEED_ISAT) Err1Int=MOTSPEED_ISAT;
			else if (Err1Int<-MOTSPEED_ISAT) Err1Int=-MOTSPEED_ISAT;
			Out1=MotorSpeed.Speed1*MOTSPEED_FF+Err1*MOTSPEED_KP+MOTSPEED_KI*Err1Int;
    3e82:	b3 01       	movw	r22, r6
    3e84:	66 0f       	add	r22, r22
    3e86:	77 1f       	adc	r23, r23
    3e88:	07 2e       	mov	r0, r23
    3e8a:	00 0c       	add	r0, r0
    3e8c:	88 0b       	sbc	r24, r24
    3e8e:	99 0b       	sbc	r25, r25
    3e90:	0e 94 eb 24 	call	0x49d6	; 0x49d6 <__floatsisf>
    3e94:	6f 83       	std	Y+7, r22	; 0x07
    3e96:	78 87       	std	Y+8, r23	; 0x08
    3e98:	89 87       	std	Y+9, r24	; 0x09
    3e9a:	9a 87       	std	Y+10, r25	; 0x0a
    3e9c:	c2 01       	movw	r24, r4
    3e9e:	b1 01       	movw	r22, r2
    3ea0:	0e 94 eb 24 	call	0x49d6	; 0x49d6 <__floatsisf>
    3ea4:	2a e9       	ldi	r18, 0x9A	; 154
    3ea6:	39 e9       	ldi	r19, 0x99	; 153
    3ea8:	49 e9       	ldi	r20, 0x99	; 153
    3eaa:	5e e3       	ldi	r21, 0x3E	; 62
    3eac:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <__mulsf3>
    3eb0:	9b 01       	movw	r18, r22
    3eb2:	ac 01       	movw	r20, r24
    3eb4:	6f 81       	ldd	r22, Y+7	; 0x07
    3eb6:	78 85       	ldd	r23, Y+8	; 0x08
    3eb8:	89 85       	ldd	r24, Y+9	; 0x09
    3eba:	9a 85       	ldd	r25, Y+10	; 0x0a
    3ebc:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <__addsf3>
    3ec0:	0e 94 b3 24 	call	0x4966	; 0x4966 <__fixsfsi>
    3ec4:	3b 01       	movw	r6, r22
    3ec6:	77 fd       	sbrc	r23, 7
    3ec8:	88 c0       	rjmp	.+272    	; 0x3fda <WorkerMotorSpeed+0x1fc>
			if (Out1<0) Out1=0;
			if (Inv1) Out1=-Out1;
    3eca:	6b 85       	ldd	r22, Y+11	; 0x0b
    3ecc:	66 23       	and	r22, r22
    3ece:	19 f0       	breq	.+6      	; 0x3ed6 <WorkerMotorSpeed+0xf8>
    3ed0:	71 94       	neg	r7
    3ed2:	61 94       	neg	r6
    3ed4:	71 08       	sbc	r7, r1
					
			Err2=(MotorSpeed.Speed2-EncoderInfo.Speed2);
    3ed6:	6b 81       	ldd	r22, Y+3	; 0x03
    3ed8:	7c 81       	ldd	r23, Y+4	; 0x04
    3eda:	6a 19       	sub	r22, r10
    3edc:	7b 09       	sbc	r23, r11
			if (EncoderInfo.Speed2!=-1) Err2Int=Err2Int+Err2;
    3ede:	0f 3f       	cpi	r16, 0xFF	; 255
    3ee0:	1f 4f       	sbci	r17, 0xFF	; 255
    3ee2:	49 f0       	breq	.+18     	; 0x3ef6 <WorkerMotorSpeed+0x118>
    3ee4:	cb 01       	movw	r24, r22
    3ee6:	07 2e       	mov	r0, r23
    3ee8:	00 0c       	add	r0, r0
    3eea:	aa 0b       	sbc	r26, r26
    3eec:	bb 0b       	sbc	r27, r27
    3eee:	c8 0e       	add	r12, r24
    3ef0:	d9 1e       	adc	r13, r25
    3ef2:	ea 1e       	adc	r14, r26
    3ef4:	fb 1e       	adc	r15, r27
    3ef6:	c1 14       	cp	r12, r1
    3ef8:	90 e6       	ldi	r25, 0x60	; 96
    3efa:	d9 06       	cpc	r13, r25
    3efc:	9f ef       	ldi	r25, 0xFF	; 255
    3efe:	e9 06       	cpc	r14, r25
    3f00:	f9 06       	cpc	r15, r25
    3f02:	34 f4       	brge	.+12     	; 0x3f10 <WorkerMotorSpeed+0x132>
    3f04:	c1 2c       	mov	r12, r1
    3f06:	20 e6       	ldi	r18, 0x60	; 96
    3f08:	d2 2e       	mov	r13, r18
    3f0a:	ee 24       	eor	r14, r14
    3f0c:	ea 94       	dec	r14
    3f0e:	fe 2c       	mov	r15, r14
    3f10:	21 e0       	ldi	r18, 0x01	; 1
    3f12:	c2 16       	cp	r12, r18
    3f14:	20 ea       	ldi	r18, 0xA0	; 160
    3f16:	d2 06       	cpc	r13, r18
    3f18:	e1 04       	cpc	r14, r1
    3f1a:	f1 04       	cpc	r15, r1
    3f1c:	2c f0       	brlt	.+10     	; 0x3f28 <WorkerMotorSpeed+0x14a>
    3f1e:	c1 2c       	mov	r12, r1
    3f20:	90 ea       	ldi	r25, 0xA0	; 160
    3f22:	d9 2e       	mov	r13, r25
    3f24:	e1 2c       	mov	r14, r1
    3f26:	f1 2c       	mov	r15, r1
			if (Err2Int>MOTSPEED_ISAT) Err2Int=MOTSPEED_ISAT;
			else if (Err2Int<-MOTSPEED_ISAT) Err2Int=-MOTSPEED_ISAT;
			Out2=MotorSpeed.Speed2*MOTSPEED_FF+Err2*MOTSPEED_KP+MOTSPEED_KI*Err2Int;
    3f28:	66 0f       	add	r22, r22
    3f2a:	77 1f       	adc	r23, r23
    3f2c:	07 2e       	mov	r0, r23
    3f2e:	00 0c       	add	r0, r0
    3f30:	88 0b       	sbc	r24, r24
    3f32:	99 0b       	sbc	r25, r25
    3f34:	0e 94 eb 24 	call	0x49d6	; 0x49d6 <__floatsisf>
    3f38:	4b 01       	movw	r8, r22
    3f3a:	5c 01       	movw	r10, r24
    3f3c:	c7 01       	movw	r24, r14
    3f3e:	b6 01       	movw	r22, r12
    3f40:	0e 94 eb 24 	call	0x49d6	; 0x49d6 <__floatsisf>
    3f44:	2a e9       	ldi	r18, 0x9A	; 154
    3f46:	39 e9       	ldi	r19, 0x99	; 153
    3f48:	49 e9       	ldi	r20, 0x99	; 153
    3f4a:	5e e3       	ldi	r21, 0x3E	; 62
    3f4c:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <__mulsf3>
    3f50:	9b 01       	movw	r18, r22
    3f52:	ac 01       	movw	r20, r24
    3f54:	c5 01       	movw	r24, r10
    3f56:	b4 01       	movw	r22, r8
    3f58:	0e 94 d0 23 	call	0x47a0	; 0x47a0 <__addsf3>
    3f5c:	0e 94 b3 24 	call	0x4966	; 0x4966 <__fixsfsi>
    3f60:	77 fd       	sbrc	r23, 7
    3f62:	38 c0       	rjmp	.+112    	; 0x3fd4 <WorkerMotorSpeed+0x1f6>
			if (Out2<0) Out2=0;
			if (Inv2) Out2=-Out2;
    3f64:	4c 85       	ldd	r20, Y+12	; 0x0c
    3f66:	44 23       	and	r20, r20
    3f68:	19 f0       	breq	.+6      	; 0x3f70 <WorkerMotorSpeed+0x192>
    3f6a:	71 95       	neg	r23
    3f6c:	61 95       	neg	r22
    3f6e:	71 09       	sbc	r23, r1
			
			DriverMotorSet(Out1,Out2);
    3f70:	c3 01       	movw	r24, r6
    3f72:	0e 94 a8 03 	call	0x750	; 0x750 <DriverMotorSet>
			
			
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
    3f76:	6a e0       	ldi	r22, 0x0A	; 10
    3f78:	70 e0       	ldi	r23, 0x00	; 0
    3f7a:	ce 01       	movw	r24, r28
    3f7c:	05 96       	adiw	r24, 0x05	; 5
    3f7e:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <vTaskDelayUntil>
	xLastWakeTime = xTaskGetTickCount();
	
	while (1)
	{
		
			EncoderInfo=DriverMotorGetEncoder();
    3f82:	0e 94 0d 04 	call	0x81a	; 0x81a <DriverMotorGetEncoder>
    3f86:	4b 01       	movw	r8, r22
    3f88:	5c 01       	movw	r10, r24
    3f8a:	6f 83       	std	Y+7, r22	; 0x07
    3f8c:	78 87       	std	Y+8, r23	; 0x08
    3f8e:	85 01       	movw	r16, r10
			xQueuePeek(MotorSpeedQueue,&MotorSpeed,portMAX_DELAY);
    3f90:	4f ef       	ldi	r20, 0xFF	; 255
    3f92:	5f ef       	ldi	r21, 0xFF	; 255
    3f94:	be 01       	movw	r22, r28
    3f96:	6f 5f       	subi	r22, 0xFF	; 255
    3f98:	7f 4f       	sbci	r23, 0xFF	; 255
    3f9a:	80 91 b0 68 	lds	r24, 0x68B0	; 0x8068b0 <MotorSpeedQueue>
    3f9e:	90 91 b1 68 	lds	r25, 0x68B1	; 0x8068b1 <MotorSpeedQueue+0x1>
    3fa2:	0e 94 57 14 	call	0x28ae	; 0x28ae <xQueuePeek>
			//Filter
			//if (EncoderInfo.Speed1>2000) EncoderInfo.Speed1=-1;
			//if (EncoderInfo.Speed2>2000) EncoderInfo.Speed2=-1;
			
			//Motor direction
			if (MotorSpeed.Speed1<0)
    3fa6:	89 81       	ldd	r24, Y+1	; 0x01
    3fa8:	9a 81       	ldd	r25, Y+2	; 0x02
    3faa:	97 ff       	sbrs	r25, 7
    3fac:	2a cf       	rjmp	.-428    	; 0x3e02 <WorkerMotorSpeed+0x24>
			{
				MotorSpeed.Speed1=-MotorSpeed.Speed1;
    3fae:	91 95       	neg	r25
    3fb0:	81 95       	neg	r24
    3fb2:	91 09       	sbc	r25, r1
    3fb4:	89 83       	std	Y+1, r24	; 0x01
    3fb6:	9a 83       	std	Y+2, r25	; 0x02
				Inv1=1;
    3fb8:	21 e0       	ldi	r18, 0x01	; 1
    3fba:	2b 87       	std	Y+11, r18	; 0x0b
			}
			else
				Inv1=0;
				
			if (MotorSpeed.Speed2<0)
    3fbc:	2b 81       	ldd	r18, Y+3	; 0x03
    3fbe:	3c 81       	ldd	r19, Y+4	; 0x04
    3fc0:	37 ff       	sbrs	r19, 7
    3fc2:	24 cf       	rjmp	.-440    	; 0x3e0c <WorkerMotorSpeed+0x2e>
			{
				MotorSpeed.Speed2=-MotorSpeed.Speed2;
    3fc4:	31 95       	neg	r19
    3fc6:	21 95       	neg	r18
    3fc8:	31 09       	sbc	r19, r1
    3fca:	2b 83       	std	Y+3, r18	; 0x03
    3fcc:	3c 83       	std	Y+4, r19	; 0x04
				Inv2=1;
    3fce:	41 e0       	ldi	r20, 0x01	; 1
    3fd0:	4c 87       	std	Y+12, r20	; 0x0c
    3fd2:	1d cf       	rjmp	.-454    	; 0x3e0e <WorkerMotorSpeed+0x30>
    3fd4:	60 e0       	ldi	r22, 0x00	; 0
    3fd6:	70 e0       	ldi	r23, 0x00	; 0
    3fd8:	c5 cf       	rjmp	.-118    	; 0x3f64 <WorkerMotorSpeed+0x186>
    3fda:	61 2c       	mov	r6, r1
    3fdc:	71 2c       	mov	r7, r1
    3fde:	75 cf       	rjmp	.-278    	; 0x3eca <WorkerMotorSpeed+0xec>

00003fe0 <InitMotorSpeedTask>:
//Private function prototypes
void WorkerMotorSpeed(void *pvParameters);

//Function definitions
void InitMotorSpeedTask()
{
    3fe0:	ef 92       	push	r14
    3fe2:	ff 92       	push	r15
    3fe4:	0f 93       	push	r16
	DriverMotorInit();
    3fe6:	0e 94 61 03 	call	0x6c2	; 0x6c2 <DriverMotorInit>
	xTaskCreate( WorkerMotorSpeed, "motspd", 256, NULL, tskIDLE_PRIORITY+3, NULL );	
    3fea:	e1 2c       	mov	r14, r1
    3fec:	f1 2c       	mov	r15, r1
    3fee:	03 e0       	ldi	r16, 0x03	; 3
    3ff0:	20 e0       	ldi	r18, 0x00	; 0
    3ff2:	30 e0       	ldi	r19, 0x00	; 0
    3ff4:	40 e0       	ldi	r20, 0x00	; 0
    3ff6:	51 e0       	ldi	r21, 0x01	; 1
    3ff8:	67 ef       	ldi	r22, 0xF7	; 247
    3ffa:	72 e2       	ldi	r23, 0x22	; 34
    3ffc:	8f ee       	ldi	r24, 0xEF	; 239
    3ffe:	9e e1       	ldi	r25, 0x1E	; 30
    4000:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <xTaskCreate>
	
	MotorSpeedQueue=xQueueCreate(1,sizeof(MotorSpeedStruct));
    4004:	40 e0       	ldi	r20, 0x00	; 0
    4006:	64 e0       	ldi	r22, 0x04	; 4
    4008:	81 e0       	ldi	r24, 0x01	; 1
    400a:	0e 94 2d 11 	call	0x225a	; 0x225a <xQueueGenericCreate>
    400e:	80 93 b0 68 	sts	0x68B0, r24	; 0x8068b0 <MotorSpeedQueue>
    4012:	90 93 b1 68 	sts	0x68B1, r25	; 0x8068b1 <MotorSpeedQueue+0x1>
}

void MotorSpeedSet(int16_t Speed1,int16_t Speed2)
{
	
	MotorSpeed.Speed1=Speed1;
    4016:	ec ea       	ldi	r30, 0xAC	; 172
    4018:	f8 e6       	ldi	r31, 0x68	; 104
    401a:	10 82       	st	Z, r1
    401c:	11 82       	std	Z+1, r1	; 0x01
	MotorSpeed.Speed2=Speed2;
    401e:	12 82       	std	Z+2, r1	; 0x02
    4020:	13 82       	std	Z+3, r1	; 0x03
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
    4022:	22 e0       	ldi	r18, 0x02	; 2
    4024:	40 e0       	ldi	r20, 0x00	; 0
    4026:	50 e0       	ldi	r21, 0x00	; 0
    4028:	bf 01       	movw	r22, r30
	DriverMotorInit();
	xTaskCreate( WorkerMotorSpeed, "motspd", 256, NULL, tskIDLE_PRIORITY+3, NULL );	
	
	MotorSpeedQueue=xQueueCreate(1,sizeof(MotorSpeedStruct));
	MotorSpeedSet(0,0);
}
    402a:	0f 91       	pop	r16
    402c:	ff 90       	pop	r15
    402e:	ef 90       	pop	r14
void MotorSpeedSet(int16_t Speed1,int16_t Speed2)
{
	
	MotorSpeed.Speed1=Speed1;
	MotorSpeed.Speed2=Speed2;
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
    4030:	0c 94 71 11 	jmp	0x22e2	; 0x22e2 <xQueueGenericSend>

00004034 <MotorSpeedSet>:
}

void MotorSpeedSet(int16_t Speed1,int16_t Speed2)
{
	
	MotorSpeed.Speed1=Speed1;
    4034:	ec ea       	ldi	r30, 0xAC	; 172
    4036:	f8 e6       	ldi	r31, 0x68	; 104
    4038:	80 83       	st	Z, r24
    403a:	91 83       	std	Z+1, r25	; 0x01
	MotorSpeed.Speed2=Speed2;
    403c:	62 83       	std	Z+2, r22	; 0x02
    403e:	73 83       	std	Z+3, r23	; 0x03
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
    4040:	22 e0       	ldi	r18, 0x02	; 2
    4042:	40 e0       	ldi	r20, 0x00	; 0
    4044:	50 e0       	ldi	r21, 0x00	; 0
    4046:	bf 01       	movw	r22, r30
    4048:	80 91 b0 68 	lds	r24, 0x68B0	; 0x8068b0 <MotorSpeedQueue>
    404c:	90 91 b1 68 	lds	r25, 0x68B1	; 0x8068b1 <MotorSpeedQueue+0x1>
    4050:	0c 94 71 11 	jmp	0x22e2	; 0x22e2 <xQueueGenericSend>

00004054 <InitOLEDMenuTask>:
}

void UpMenu()
{
	if (SelItem>0) SelItem--;
	if (SelItem<TopItem) TopItem=SelItem;
    4054:	ef 92       	push	r14
    4056:	ff 92       	push	r15
    4058:	0f 93       	push	r16
    405a:	e1 2c       	mov	r14, r1
    405c:	f1 2c       	mov	r15, r1
    405e:	02 e0       	ldi	r16, 0x02	; 2
    4060:	20 e0       	ldi	r18, 0x00	; 0
    4062:	30 e0       	ldi	r19, 0x00	; 0
    4064:	40 e0       	ldi	r20, 0x00	; 0
    4066:	52 e0       	ldi	r21, 0x02	; 2
    4068:	6e ef       	ldi	r22, 0xFE	; 254
    406a:	72 e2       	ldi	r23, 0x22	; 34
    406c:	8b e6       	ldi	r24, 0x6B	; 107
    406e:	93 e2       	ldi	r25, 0x23	; 35
    4070:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <xTaskCreate>
    4074:	0f 91       	pop	r16
    4076:	ff 90       	pop	r15
    4078:	ef 90       	pop	r14
    407a:	08 95       	ret

0000407c <DrawMenu>:
    407c:	1f 93       	push	r17
    407e:	cf 93       	push	r28
    4080:	df 93       	push	r29
    4082:	d0 91 99 68 	lds	r29, 0x6899	; 0x806899 <TopItem>
    4086:	15 e0       	ldi	r17, 0x05	; 5
    4088:	1d 0f       	add	r17, r29
    408a:	0e 94 56 06 	call	0xcac	; 0xcac <DriverOLEDClearScreen>
    408e:	1d 17       	cp	r17, r29
    4090:	78 f0       	brcs	.+30     	; 0x40b0 <DrawMenu+0x34>
    4092:	cd 2f       	mov	r28, r29
    4094:	80 e1       	ldi	r24, 0x10	; 16
    4096:	c8 9f       	mul	r28, r24
    4098:	b0 01       	movw	r22, r0
    409a:	11 24       	eor	r1, r1
    409c:	60 5f       	subi	r22, 0xF0	; 240
    409e:	7f 4d       	sbci	r23, 0xDF	; 223
    40a0:	40 e0       	ldi	r20, 0x00	; 0
    40a2:	8c 2f       	mov	r24, r28
    40a4:	8d 1b       	sub	r24, r29
    40a6:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
    40aa:	cf 5f       	subi	r28, 0xFF	; 255
    40ac:	1c 17       	cp	r17, r28
    40ae:	90 f7       	brcc	.-28     	; 0x4094 <DrawMenu+0x18>
    40b0:	60 91 98 68 	lds	r22, 0x6898	; 0x806898 <SelItem>
    40b4:	80 91 99 68 	lds	r24, 0x6899	; 0x806899 <TopItem>
    40b8:	68 1b       	sub	r22, r24
    40ba:	20 e0       	ldi	r18, 0x00	; 0
    40bc:	4a e2       	ldi	r20, 0x2A	; 42
    40be:	80 e0       	ldi	r24, 0x00	; 0
    40c0:	0e 94 28 08 	call	0x1050	; 0x1050 <DriverOLEDPrintSmChar>
    40c4:	df 91       	pop	r29
    40c6:	cf 91       	pop	r28
    40c8:	1f 91       	pop	r17
    40ca:	0c 94 14 06 	jmp	0xc28	; 0xc28 <DriverOLEDUpdate>

000040ce <PageCPUStatus>:
}

void PageCPUStatus()
{
    40ce:	2f 92       	push	r2
    40d0:	3f 92       	push	r3
    40d2:	4f 92       	push	r4
    40d4:	5f 92       	push	r5
    40d6:	6f 92       	push	r6
    40d8:	7f 92       	push	r7
    40da:	8f 92       	push	r8
    40dc:	9f 92       	push	r9
    40de:	af 92       	push	r10
    40e0:	bf 92       	push	r11
    40e2:	cf 92       	push	r12
    40e4:	df 92       	push	r13
    40e6:	ef 92       	push	r14
    40e8:	ff 92       	push	r15
    40ea:	0f 93       	push	r16
    40ec:	1f 93       	push	r17
    40ee:	cf 93       	push	r28
    40f0:	df 93       	push	r29
    40f2:	cd b7       	in	r28, 0x3d	; 61
    40f4:	de b7       	in	r29, 0x3e	; 62
    40f6:	c4 59       	subi	r28, 0x94	; 148
    40f8:	d1 09       	sbc	r29, r1
    40fa:	cd bf       	out	0x3d, r28	; 61
    40fc:	de bf       	out	0x3e, r29	; 62
	float Load;
	
	uint32_t IdleTime;
	uint32_t OldTotalRunTime=0,OldIdleTime=0;
	
	vTaskDelay(300);
    40fe:	8c e2       	ldi	r24, 0x2C	; 44
    4100:	91 e0       	ldi	r25, 0x01	; 1
    4102:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <vTaskDelay>
	uint32_t TotalRunTime;
	int NumTasks;
	float Load;
	
	uint32_t IdleTime;
	uint32_t OldTotalRunTime=0,OldIdleTime=0;
    4106:	41 2c       	mov	r4, r1
    4108:	51 2c       	mov	r5, r1
    410a:	32 01       	movw	r6, r4
    410c:	81 2c       	mov	r8, r1
    410e:	91 2c       	mov	r9, r1
    4110:	54 01       	movw	r10, r8
		
		
		DriverOLEDClearScreen();
		
		DriverOLEDPrintSmText(0,"Mem free:",0);
		sprintf (s,"%6u/%6u",xPortGetFreeHeapSize(),configTOTAL_HEAP_SIZE);
    4112:	80 e1       	ldi	r24, 0x10	; 16
    4114:	28 2e       	mov	r2, r24
    4116:	83 e2       	ldi	r24, 0x23	; 35
    4118:	38 2e       	mov	r3, r24
    411a:	8e 01       	movw	r16, r28
    411c:	0f 59       	subi	r16, 0x9F	; 159
    411e:	1f 4f       	sbci	r17, 0xFF	; 255
    4120:	93 c0       	rjmp	.+294    	; 0x4248 <PageCPUStatus+0x17a>
	{
		Stick=DriverCursorstickGet();
		if (Stick & CURSOR_PRESS) break;
		
		
		DriverOLEDClearScreen();
    4122:	0e 94 56 06 	call	0xcac	; 0xcac <DriverOLEDClearScreen>
		
		DriverOLEDPrintSmText(0,"Mem free:",0);
    4126:	40 e0       	ldi	r20, 0x00	; 0
    4128:	66 e0       	ldi	r22, 0x06	; 6
    412a:	73 e2       	ldi	r23, 0x23	; 35
    412c:	80 e0       	ldi	r24, 0x00	; 0
    412e:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
		sprintf (s,"%6u/%6u",xPortGetFreeHeapSize(),configTOTAL_HEAP_SIZE);
    4132:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <xPortGetFreeHeapSize>
    4136:	20 e4       	ldi	r18, 0x40	; 64
    4138:	2f 93       	push	r18
    413a:	1f 92       	push	r1
    413c:	9f 93       	push	r25
    413e:	8f 93       	push	r24
    4140:	3f 92       	push	r3
    4142:	2f 92       	push	r2
    4144:	1f 93       	push	r17
    4146:	0f 93       	push	r16
    4148:	0e 94 1e 2b 	call	0x563c	; 0x563c <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    414c:	40 e0       	ldi	r20, 0x00	; 0
    414e:	b8 01       	movw	r22, r16
    4150:	81 e0       	ldi	r24, 0x01	; 1
    4152:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
		
		
		NumTasks=uxTaskGetSystemState(TaskStatusArray,6,&TotalRunTime);
    4156:	ae 01       	movw	r20, r28
    4158:	4f 56       	subi	r20, 0x6F	; 111
    415a:	5f 4f       	sbci	r21, 0xFF	; 255
    415c:	66 e0       	ldi	r22, 0x06	; 6
    415e:	ce 01       	movw	r24, r28
    4160:	01 96       	adiw	r24, 0x01	; 1
    4162:	0e 94 39 1c 	call	0x3872	; 0x3872 <uxTaskGetSystemState>
		sprintf (s,"Number of tasks:%d",NumTasks);
    4166:	1f 92       	push	r1
    4168:	8f 93       	push	r24
    416a:	88 e1       	ldi	r24, 0x18	; 24
    416c:	93 e2       	ldi	r25, 0x23	; 35
    416e:	9f 93       	push	r25
    4170:	8f 93       	push	r24
    4172:	1f 93       	push	r17
    4174:	0f 93       	push	r16
    4176:	0e 94 1e 2b 	call	0x563c	; 0x563c <sprintf>
		DriverOLEDPrintSmText(2,s,0);
    417a:	40 e0       	ldi	r20, 0x00	; 0
    417c:	b8 01       	movw	r22, r16
    417e:	82 e0       	ldi	r24, 0x02	; 2
    4180:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
		
		//Calculate system load
		vTaskGetTaskInfo(xTaskGetIdleTaskHandle(),&IdleTaskStatus,pdFALSE,eInvalid);
    4184:	0e 94 7f 18 	call	0x30fe	; 0x30fe <xTaskGetIdleTaskHandle>
    4188:	25 e0       	ldi	r18, 0x05	; 5
    418a:	40 e0       	ldi	r20, 0x00	; 0
    418c:	be 01       	movw	r22, r28
    418e:	6f 57       	subi	r22, 0x7F	; 127
    4190:	7f 4f       	sbci	r23, 0xFF	; 255
    4192:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <vTaskGetInfo>
		IdleTime=IdleTaskStatus.ulRunTimeCounter;
    4196:	c7 57       	subi	r28, 0x77	; 119
    4198:	df 4f       	sbci	r29, 0xFF	; 255
    419a:	c8 80       	ld	r12, Y
    419c:	d9 80       	ldd	r13, Y+1	; 0x01
    419e:	ea 80       	ldd	r14, Y+2	; 0x02
    41a0:	fb 80       	ldd	r15, Y+3	; 0x03
    41a2:	c9 58       	subi	r28, 0x89	; 137
    41a4:	d0 40       	sbci	r29, 0x00	; 0
		Load=(1-((float) (IdleTime-OldIdleTime)/ (float)(TotalRunTime-OldTotalRunTime)))*100;
		sprintf(s,"CPU Load:%2.2f",Load);
    41a6:	c7 01       	movw	r24, r14
    41a8:	b6 01       	movw	r22, r12
    41aa:	64 19       	sub	r22, r4
    41ac:	75 09       	sbc	r23, r5
    41ae:	86 09       	sbc	r24, r6
    41b0:	97 09       	sbc	r25, r7
    41b2:	0e 94 e9 24 	call	0x49d2	; 0x49d2 <__floatunsisf>
    41b6:	2b 01       	movw	r4, r22
    41b8:	3c 01       	movw	r6, r24
    41ba:	cf 56       	subi	r28, 0x6F	; 111
    41bc:	df 4f       	sbci	r29, 0xFF	; 255
    41be:	88 81       	ld	r24, Y
    41c0:	99 81       	ldd	r25, Y+1	; 0x01
    41c2:	aa 81       	ldd	r26, Y+2	; 0x02
    41c4:	bb 81       	ldd	r27, Y+3	; 0x03
    41c6:	c1 59       	subi	r28, 0x91	; 145
    41c8:	d0 40       	sbci	r29, 0x00	; 0
    41ca:	bc 01       	movw	r22, r24
    41cc:	cd 01       	movw	r24, r26
    41ce:	68 19       	sub	r22, r8
    41d0:	79 09       	sbc	r23, r9
    41d2:	8a 09       	sbc	r24, r10
    41d4:	9b 09       	sbc	r25, r11
    41d6:	0e 94 e9 24 	call	0x49d2	; 0x49d2 <__floatunsisf>
    41da:	9b 01       	movw	r18, r22
    41dc:	ac 01       	movw	r20, r24
    41de:	c3 01       	movw	r24, r6
    41e0:	b2 01       	movw	r22, r4
    41e2:	0e 94 41 24 	call	0x4882	; 0x4882 <__divsf3>
    41e6:	9b 01       	movw	r18, r22
    41e8:	ac 01       	movw	r20, r24
    41ea:	60 e0       	ldi	r22, 0x00	; 0
    41ec:	70 e0       	ldi	r23, 0x00	; 0
    41ee:	80 e8       	ldi	r24, 0x80	; 128
    41f0:	9f e3       	ldi	r25, 0x3F	; 63
    41f2:	0e 94 cf 23 	call	0x479e	; 0x479e <__subsf3>
    41f6:	20 e0       	ldi	r18, 0x00	; 0
    41f8:	30 e0       	ldi	r19, 0x00	; 0
    41fa:	48 ec       	ldi	r20, 0xC8	; 200
    41fc:	52 e4       	ldi	r21, 0x42	; 66
    41fe:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <__mulsf3>
    4202:	9f 93       	push	r25
    4204:	8f 93       	push	r24
    4206:	7f 93       	push	r23
    4208:	6f 93       	push	r22
    420a:	8b e2       	ldi	r24, 0x2B	; 43
    420c:	93 e2       	ldi	r25, 0x23	; 35
    420e:	9f 93       	push	r25
    4210:	8f 93       	push	r24
    4212:	1f 93       	push	r17
    4214:	0f 93       	push	r16
    4216:	0e 94 1e 2b 	call	0x563c	; 0x563c <sprintf>
		DriverOLEDPrintSmText(3,s,0);
    421a:	40 e0       	ldi	r20, 0x00	; 0
    421c:	b8 01       	movw	r22, r16
    421e:	83 e0       	ldi	r24, 0x03	; 3
    4220:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
		
		DriverOLEDUpdate();
    4224:	0e 94 14 06 	call	0xc28	; 0xc28 <DriverOLEDUpdate>
		OldIdleTime=IdleTime;
		OldTotalRunTime=TotalRunTime;
    4228:	cf 56       	subi	r28, 0x6F	; 111
    422a:	df 4f       	sbci	r29, 0xFF	; 255
    422c:	88 80       	ld	r8, Y
    422e:	99 80       	ldd	r9, Y+1	; 0x01
    4230:	aa 80       	ldd	r10, Y+2	; 0x02
    4232:	bb 80       	ldd	r11, Y+3	; 0x03
    4234:	c1 59       	subi	r28, 0x91	; 145
    4236:	d0 40       	sbci	r29, 0x00	; 0
		vTaskDelay(300);
    4238:	8c e2       	ldi	r24, 0x2C	; 44
    423a:	91 e0       	ldi	r25, 0x01	; 1
    423c:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <vTaskDelay>
		
	}
    4240:	cd bf       	out	0x3d, r28	; 61
    4242:	de bf       	out	0x3e, r29	; 62
		Load=(1-((float) (IdleTime-OldIdleTime)/ (float)(TotalRunTime-OldTotalRunTime)))*100;
		sprintf(s,"CPU Load:%2.2f",Load);
		DriverOLEDPrintSmText(3,s,0);
		
		DriverOLEDUpdate();
		OldIdleTime=IdleTime;
    4244:	26 01       	movw	r4, r12
    4246:	37 01       	movw	r6, r14
	uint32_t OldTotalRunTime=0,OldIdleTime=0;
	
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorstickGet();
    4248:	0e 94 1b 03 	call	0x636	; 0x636 <DriverCursorstickGet>
		if (Stick & CURSOR_PRESS) break;
    424c:	84 ff       	sbrs	r24, 4
    424e:	69 cf       	rjmp	.-302    	; 0x4122 <PageCPUStatus+0x54>
		OldTotalRunTime=TotalRunTime;
		vTaskDelay(300);
		
	}
	
}
    4250:	cc 56       	subi	r28, 0x6C	; 108
    4252:	df 4f       	sbci	r29, 0xFF	; 255
    4254:	cd bf       	out	0x3d, r28	; 61
    4256:	de bf       	out	0x3e, r29	; 62
    4258:	df 91       	pop	r29
    425a:	cf 91       	pop	r28
    425c:	1f 91       	pop	r17
    425e:	0f 91       	pop	r16
    4260:	ff 90       	pop	r15
    4262:	ef 90       	pop	r14
    4264:	df 90       	pop	r13
    4266:	cf 90       	pop	r12
    4268:	bf 90       	pop	r11
    426a:	af 90       	pop	r10
    426c:	9f 90       	pop	r9
    426e:	8f 90       	pop	r8
    4270:	7f 90       	pop	r7
    4272:	6f 90       	pop	r6
    4274:	5f 90       	pop	r5
    4276:	4f 90       	pop	r4
    4278:	3f 90       	pop	r3
    427a:	2f 90       	pop	r2
    427c:	08 95       	ret

0000427e <PageMotorSpeed>:

void PageMotorSpeed()
{
    427e:	2f 92       	push	r2
    4280:	3f 92       	push	r3
    4282:	4f 92       	push	r4
    4284:	5f 92       	push	r5
    4286:	6f 92       	push	r6
    4288:	7f 92       	push	r7
    428a:	8f 92       	push	r8
    428c:	9f 92       	push	r9
    428e:	af 92       	push	r10
    4290:	bf 92       	push	r11
    4292:	cf 92       	push	r12
    4294:	df 92       	push	r13
    4296:	ef 92       	push	r14
    4298:	ff 92       	push	r15
    429a:	0f 93       	push	r16
    429c:	1f 93       	push	r17
    429e:	cf 93       	push	r28
    42a0:	df 93       	push	r29
    42a2:	cd b7       	in	r28, 0x3d	; 61
    42a4:	de b7       	in	r29, 0x3e	; 62
    42a6:	a1 97       	sbiw	r28, 0x21	; 33
    42a8:	cd bf       	out	0x3d, r28	; 61
    42aa:	de bf       	out	0x3e, r29	; 62
	char s[32];
	
	EncoderStruct EncoderInfo;
	
			
	vTaskDelay(300);
    42ac:	8c e2       	ldi	r24, 0x2C	; 44
    42ae:	91 e0       	ldi	r25, 0x01	; 1
    42b0:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <vTaskDelay>
}

void PageMotorSpeed()
{
	uint8_t Stick;
	int16_t Speed1=600,Speed2=600;
    42b4:	88 e5       	ldi	r24, 0x58	; 88
    42b6:	c8 2e       	mov	r12, r24
    42b8:	82 e0       	ldi	r24, 0x02	; 2
    42ba:	d8 2e       	mov	r13, r24
    42bc:	98 e5       	ldi	r25, 0x58	; 88
    42be:	e9 2e       	mov	r14, r25
    42c0:	92 e0       	ldi	r25, 0x02	; 2
    42c2:	f9 2e       	mov	r15, r25
    42c4:	8e 01       	movw	r16, r28
    42c6:	0f 5f       	subi	r16, 0xFF	; 255
    42c8:	1f 4f       	sbci	r17, 0xFF	; 255
		Stick=DriverCursorstickGet();

		
		DriverOLEDClearScreen();
		
		sprintf(s,"  S1:%d",Speed1);
    42ca:	2a e3       	ldi	r18, 0x3A	; 58
    42cc:	82 2e       	mov	r8, r18
    42ce:	23 e2       	ldi	r18, 0x23	; 35
    42d0:	92 2e       	mov	r9, r18
		DriverOLEDPrintSmText(0,s,0);
		sprintf(s,"  S2:%d",Speed2);
    42d2:	32 e4       	ldi	r19, 0x42	; 66
    42d4:	a3 2e       	mov	r10, r19
    42d6:	33 e2       	ldi	r19, 0x23	; 35
    42d8:	b3 2e       	mov	r11, r19
		DriverOLEDPrintSmText(1,s,0);
		sprintf (s,"  M1:%d",EncoderInfo.Speed1);
		DriverOLEDPrintSmText(2,s,0);
		sprintf (s,"  M2:%d",EncoderInfo.Speed2);
    42da:	42 e5       	ldi	r20, 0x52	; 82
    42dc:	24 2e       	mov	r2, r20
    42de:	43 e2       	ldi	r20, 0x23	; 35
    42e0:	34 2e       	mov	r3, r20
    42e2:	0a c0       	rjmp	.+20     	; 0x42f8 <PageMotorSpeed+0x7a>
		{
			MotorSpeedSet(0,0);
			vTaskDelay(300);
			return;
		}	
		MotorSpeedSet(Speed1,Speed2);
    42e4:	b6 01       	movw	r22, r12
    42e6:	c7 01       	movw	r24, r14
    42e8:	0e 94 1a 20 	call	0x4034	; 0x4034 <MotorSpeedSet>
		
		
		DriverOLEDUpdate();
    42ec:	0e 94 14 06 	call	0xc28	; 0xc28 <DriverOLEDUpdate>

		vTaskDelay(300);
    42f0:	8c e2       	ldi	r24, 0x2C	; 44
    42f2:	91 e0       	ldi	r25, 0x01	; 1
    42f4:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <vTaskDelay>
	
			
	vTaskDelay(300);
	while (1)
	{
		EncoderInfo=DriverMotorGetEncoder();	
    42f8:	0e 94 0d 04 	call	0x81a	; 0x81a <DriverMotorGetEncoder>
    42fc:	46 2e       	mov	r4, r22
    42fe:	79 a3       	std	Y+33, r23	; 0x21
    4300:	68 2e       	mov	r6, r24
    4302:	59 2e       	mov	r5, r25
		Stick=DriverCursorstickGet();
    4304:	0e 94 1b 03 	call	0x636	; 0x636 <DriverCursorstickGet>
    4308:	78 2e       	mov	r7, r24

		
		DriverOLEDClearScreen();
    430a:	0e 94 56 06 	call	0xcac	; 0xcac <DriverOLEDClearScreen>
		
		sprintf(s,"  S1:%d",Speed1);
    430e:	ff 92       	push	r15
    4310:	ef 92       	push	r14
    4312:	9f 92       	push	r9
    4314:	8f 92       	push	r8
    4316:	1f 93       	push	r17
    4318:	0f 93       	push	r16
    431a:	0e 94 1e 2b 	call	0x563c	; 0x563c <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    431e:	40 e0       	ldi	r20, 0x00	; 0
    4320:	b8 01       	movw	r22, r16
    4322:	80 e0       	ldi	r24, 0x00	; 0
    4324:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
		sprintf(s,"  S2:%d",Speed2);
    4328:	df 92       	push	r13
    432a:	cf 92       	push	r12
    432c:	bf 92       	push	r11
    432e:	af 92       	push	r10
    4330:	1f 93       	push	r17
    4332:	0f 93       	push	r16
    4334:	0e 94 1e 2b 	call	0x563c	; 0x563c <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    4338:	40 e0       	ldi	r20, 0x00	; 0
    433a:	b8 01       	movw	r22, r16
    433c:	81 e0       	ldi	r24, 0x01	; 1
    433e:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
		sprintf (s,"  M1:%d",EncoderInfo.Speed1);
    4342:	29 a1       	ldd	r18, Y+33	; 0x21
    4344:	2f 93       	push	r18
    4346:	4f 92       	push	r4
    4348:	8a e4       	ldi	r24, 0x4A	; 74
    434a:	93 e2       	ldi	r25, 0x23	; 35
    434c:	9f 93       	push	r25
    434e:	8f 93       	push	r24
    4350:	1f 93       	push	r17
    4352:	0f 93       	push	r16
    4354:	0e 94 1e 2b 	call	0x563c	; 0x563c <sprintf>
		DriverOLEDPrintSmText(2,s,0);
    4358:	40 e0       	ldi	r20, 0x00	; 0
    435a:	b8 01       	movw	r22, r16
    435c:	82 e0       	ldi	r24, 0x02	; 2
    435e:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
		sprintf (s,"  M2:%d",EncoderInfo.Speed2);
    4362:	5f 92       	push	r5
    4364:	6f 92       	push	r6
    4366:	3f 92       	push	r3
    4368:	2f 92       	push	r2
    436a:	1f 93       	push	r17
    436c:	0f 93       	push	r16
    436e:	0e 94 1e 2b 	call	0x563c	; 0x563c <sprintf>
		DriverOLEDPrintSmText(3,s,0);
    4372:	40 e0       	ldi	r20, 0x00	; 0
    4374:	b8 01       	movw	r22, r16
    4376:	83 e0       	ldi	r24, 0x03	; 3
    4378:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
				
		if (Stick & CURSOR_UP) Speed1+=100;
    437c:	cd bf       	out	0x3d, r28	; 61
    437e:	de bf       	out	0x3e, r29	; 62
    4380:	70 fe       	sbrs	r7, 0
    4382:	03 c0       	rjmp	.+6      	; 0x438a <PageMotorSpeed+0x10c>
    4384:	94 e6       	ldi	r25, 0x64	; 100
    4386:	e9 0e       	add	r14, r25
    4388:	f1 1c       	adc	r15, r1
		if (Stick & CURSOR_DOWN) Speed1-=100;
    438a:	72 fe       	sbrs	r7, 2
    438c:	03 c0       	rjmp	.+6      	; 0x4394 <PageMotorSpeed+0x116>
    438e:	24 e6       	ldi	r18, 0x64	; 100
    4390:	e2 1a       	sub	r14, r18
    4392:	f1 08       	sbc	r15, r1
		if (Stick & CURSOR_RIGHT) Speed2+=100;
    4394:	73 fe       	sbrs	r7, 3
    4396:	03 c0       	rjmp	.+6      	; 0x439e <PageMotorSpeed+0x120>
    4398:	84 e6       	ldi	r24, 0x64	; 100
    439a:	c8 0e       	add	r12, r24
    439c:	d1 1c       	adc	r13, r1
		if (Stick & CURSOR_LEFT) Speed2-=100;	
    439e:	71 fe       	sbrs	r7, 1
    43a0:	03 c0       	rjmp	.+6      	; 0x43a8 <PageMotorSpeed+0x12a>
    43a2:	94 e6       	ldi	r25, 0x64	; 100
    43a4:	c9 1a       	sub	r12, r25
    43a6:	d1 08       	sbc	r13, r1
		if (Stick & CURSOR_PRESS)
    43a8:	74 fe       	sbrs	r7, 4
    43aa:	9c cf       	rjmp	.-200    	; 0x42e4 <PageMotorSpeed+0x66>
		{
			MotorSpeedSet(0,0);
    43ac:	60 e0       	ldi	r22, 0x00	; 0
    43ae:	70 e0       	ldi	r23, 0x00	; 0
    43b0:	80 e0       	ldi	r24, 0x00	; 0
    43b2:	90 e0       	ldi	r25, 0x00	; 0
    43b4:	0e 94 1a 20 	call	0x4034	; 0x4034 <MotorSpeedSet>
			vTaskDelay(300);
    43b8:	8c e2       	ldi	r24, 0x2C	; 44
    43ba:	91 e0       	ldi	r25, 0x01	; 1
    43bc:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <vTaskDelay>

		vTaskDelay(300);
		
	}
	
}
    43c0:	a1 96       	adiw	r28, 0x21	; 33
    43c2:	cd bf       	out	0x3d, r28	; 61
    43c4:	de bf       	out	0x3e, r29	; 62
    43c6:	df 91       	pop	r29
    43c8:	cf 91       	pop	r28
    43ca:	1f 91       	pop	r17
    43cc:	0f 91       	pop	r16
    43ce:	ff 90       	pop	r15
    43d0:	ef 90       	pop	r14
    43d2:	df 90       	pop	r13
    43d4:	cf 90       	pop	r12
    43d6:	bf 90       	pop	r11
    43d8:	af 90       	pop	r10
    43da:	9f 90       	pop	r9
    43dc:	8f 90       	pop	r8
    43de:	7f 90       	pop	r7
    43e0:	6f 90       	pop	r6
    43e2:	5f 90       	pop	r5
    43e4:	4f 90       	pop	r4
    43e6:	3f 90       	pop	r3
    43e8:	2f 90       	pop	r2
    43ea:	08 95       	ret

000043ec <PageADPS9960>:

void PageADPS9960()
{
    43ec:	7f 92       	push	r7
    43ee:	8f 92       	push	r8
    43f0:	9f 92       	push	r9
    43f2:	af 92       	push	r10
    43f4:	bf 92       	push	r11
    43f6:	cf 92       	push	r12
    43f8:	df 92       	push	r13
    43fa:	ef 92       	push	r14
    43fc:	ff 92       	push	r15
    43fe:	0f 93       	push	r16
    4400:	1f 93       	push	r17
    4402:	cf 93       	push	r28
    4404:	df 93       	push	r29
    4406:	cd b7       	in	r28, 0x3d	; 61
    4408:	de b7       	in	r29, 0x3e	; 62
    440a:	a8 97       	sbiw	r28, 0x28	; 40
    440c:	cd bf       	out	0x3d, r28	; 61
    440e:	de bf       	out	0x3e, r29	; 62
	uint8_t Stick;
	uint16_t C,R,G,B;
	char s[32];
	
	DriverLedSet(0b0010);
    4410:	82 e0       	ldi	r24, 0x02	; 2
    4412:	0e 94 2f 03 	call	0x65e	; 0x65e <DriverLedSet>
	vTaskDelay(300);
    4416:	8c e2       	ldi	r24, 0x2C	; 44
    4418:	91 e0       	ldi	r25, 0x01	; 1
    441a:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <vTaskDelay>
    441e:	8e 01       	movw	r16, r28
    4420:	0f 5f       	subi	r16, 0xFF	; 255
    4422:	1f 4f       	sbci	r17, 0xFF	; 255
		
		DriverOLEDClearScreen();
		
		DriverAdps9960Get(&C,&R,&G,&B);
		
		sprintf(s,"C:%u",C);
    4424:	8a e5       	ldi	r24, 0x5A	; 90
    4426:	88 2e       	mov	r8, r24
    4428:	83 e2       	ldi	r24, 0x23	; 35
    442a:	98 2e       	mov	r9, r24
		DriverOLEDPrintSmText(0,s,0);

		sprintf(s,"R:%u",R);
    442c:	9f e5       	ldi	r25, 0x5F	; 95
    442e:	a9 2e       	mov	r10, r25
    4430:	93 e2       	ldi	r25, 0x23	; 35
    4432:	b9 2e       	mov	r11, r25
		DriverOLEDPrintSmText(1,s,0);
		
		sprintf(s,"G:%u",G);
    4434:	24 e6       	ldi	r18, 0x64	; 100
    4436:	c2 2e       	mov	r12, r18
    4438:	23 e2       	ldi	r18, 0x23	; 35
    443a:	d2 2e       	mov	r13, r18
		DriverOLEDPrintSmText(2,s,0);
		
		sprintf(s,"B:%u",B);
    443c:	39 e6       	ldi	r19, 0x69	; 105
    443e:	e3 2e       	mov	r14, r19
    4440:	33 e2       	ldi	r19, 0x23	; 35
    4442:	f3 2e       	mov	r15, r19
    4444:	06 c0       	rjmp	.+12     	; 0x4452 <PageADPS9960+0x66>
			vTaskDelay(300);
			DriverLedClear(0b0010);
			return;
		}
	
		DriverOLEDUpdate();
    4446:	0e 94 14 06 	call	0xc28	; 0xc28 <DriverOLEDUpdate>

		vTaskDelay(300);
    444a:	8c e2       	ldi	r24, 0x2C	; 44
    444c:	91 e0       	ldi	r25, 0x01	; 1
    444e:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <vTaskDelay>
	
	DriverLedSet(0b0010);
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorstickGet();
    4452:	0e 94 1b 03 	call	0x636	; 0x636 <DriverCursorstickGet>
    4456:	78 2e       	mov	r7, r24
		
		
		DriverOLEDClearScreen();
    4458:	0e 94 56 06 	call	0xcac	; 0xcac <DriverOLEDClearScreen>
		
		DriverAdps9960Get(&C,&R,&G,&B);
    445c:	9e 01       	movw	r18, r28
    445e:	2f 5d       	subi	r18, 0xDF	; 223
    4460:	3f 4f       	sbci	r19, 0xFF	; 255
    4462:	ae 01       	movw	r20, r28
    4464:	4d 5d       	subi	r20, 0xDD	; 221
    4466:	5f 4f       	sbci	r21, 0xFF	; 255
    4468:	be 01       	movw	r22, r28
    446a:	6b 5d       	subi	r22, 0xDB	; 219
    446c:	7f 4f       	sbci	r23, 0xFF	; 255
    446e:	ce 01       	movw	r24, r28
    4470:	87 96       	adiw	r24, 0x27	; 39
    4472:	0e 94 a7 02 	call	0x54e	; 0x54e <DriverAdps9960Get>
		
		sprintf(s,"C:%u",C);
    4476:	88 a5       	ldd	r24, Y+40	; 0x28
    4478:	8f 93       	push	r24
    447a:	8f a1       	ldd	r24, Y+39	; 0x27
    447c:	8f 93       	push	r24
    447e:	9f 92       	push	r9
    4480:	8f 92       	push	r8
    4482:	1f 93       	push	r17
    4484:	0f 93       	push	r16
    4486:	0e 94 1e 2b 	call	0x563c	; 0x563c <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    448a:	40 e0       	ldi	r20, 0x00	; 0
    448c:	b8 01       	movw	r22, r16
    448e:	80 e0       	ldi	r24, 0x00	; 0
    4490:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>

		sprintf(s,"R:%u",R);
    4494:	8e a1       	ldd	r24, Y+38	; 0x26
    4496:	8f 93       	push	r24
    4498:	8d a1       	ldd	r24, Y+37	; 0x25
    449a:	8f 93       	push	r24
    449c:	bf 92       	push	r11
    449e:	af 92       	push	r10
    44a0:	1f 93       	push	r17
    44a2:	0f 93       	push	r16
    44a4:	0e 94 1e 2b 	call	0x563c	; 0x563c <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    44a8:	40 e0       	ldi	r20, 0x00	; 0
    44aa:	b8 01       	movw	r22, r16
    44ac:	81 e0       	ldi	r24, 0x01	; 1
    44ae:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
		
		sprintf(s,"G:%u",G);
    44b2:	8c a1       	ldd	r24, Y+36	; 0x24
    44b4:	8f 93       	push	r24
    44b6:	8b a1       	ldd	r24, Y+35	; 0x23
    44b8:	8f 93       	push	r24
    44ba:	df 92       	push	r13
    44bc:	cf 92       	push	r12
    44be:	1f 93       	push	r17
    44c0:	0f 93       	push	r16
    44c2:	0e 94 1e 2b 	call	0x563c	; 0x563c <sprintf>
		DriverOLEDPrintSmText(2,s,0);
    44c6:	40 e0       	ldi	r20, 0x00	; 0
    44c8:	b8 01       	movw	r22, r16
    44ca:	82 e0       	ldi	r24, 0x02	; 2
    44cc:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
		
		sprintf(s,"B:%u",B);
    44d0:	8a a1       	ldd	r24, Y+34	; 0x22
    44d2:	8f 93       	push	r24
    44d4:	89 a1       	ldd	r24, Y+33	; 0x21
    44d6:	8f 93       	push	r24
    44d8:	ff 92       	push	r15
    44da:	ef 92       	push	r14
    44dc:	1f 93       	push	r17
    44de:	0f 93       	push	r16
    44e0:	0e 94 1e 2b 	call	0x563c	; 0x563c <sprintf>
		DriverOLEDPrintSmText(3,s,0);
    44e4:	40 e0       	ldi	r20, 0x00	; 0
    44e6:	b8 01       	movw	r22, r16
    44e8:	83 e0       	ldi	r24, 0x03	; 3
    44ea:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    44ee:	cd bf       	out	0x3d, r28	; 61
    44f0:	de bf       	out	0x3e, r29	; 62
    44f2:	74 fe       	sbrs	r7, 4
    44f4:	a8 cf       	rjmp	.-176    	; 0x4446 <PageADPS9960+0x5a>
		{
			vTaskDelay(300);
    44f6:	8c e2       	ldi	r24, 0x2C	; 44
    44f8:	91 e0       	ldi	r25, 0x01	; 1
    44fa:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <vTaskDelay>
			DriverLedClear(0b0010);
    44fe:	82 e0       	ldi	r24, 0x02	; 2
    4500:	0e 94 3f 03 	call	0x67e	; 0x67e <DriverLedClear>
		DriverOLEDUpdate();

		vTaskDelay(300);
		
	}	
}
    4504:	a8 96       	adiw	r28, 0x28	; 40
    4506:	cd bf       	out	0x3d, r28	; 61
    4508:	de bf       	out	0x3e, r29	; 62
    450a:	df 91       	pop	r29
    450c:	cf 91       	pop	r28
    450e:	1f 91       	pop	r17
    4510:	0f 91       	pop	r16
    4512:	ff 90       	pop	r15
    4514:	ef 90       	pop	r14
    4516:	df 90       	pop	r13
    4518:	cf 90       	pop	r12
    451a:	bf 90       	pop	r11
    451c:	af 90       	pop	r10
    451e:	9f 90       	pop	r9
    4520:	8f 90       	pop	r8
    4522:	7f 90       	pop	r7
    4524:	08 95       	ret

00004526 <PageADC>:

void PageADC()
{
    4526:	2f 92       	push	r2
    4528:	3f 92       	push	r3
    452a:	4f 92       	push	r4
    452c:	5f 92       	push	r5
    452e:	6f 92       	push	r6
    4530:	7f 92       	push	r7
    4532:	8f 92       	push	r8
    4534:	9f 92       	push	r9
    4536:	af 92       	push	r10
    4538:	bf 92       	push	r11
    453a:	cf 92       	push	r12
    453c:	df 92       	push	r13
    453e:	ef 92       	push	r14
    4540:	ff 92       	push	r15
    4542:	0f 93       	push	r16
    4544:	1f 93       	push	r17
    4546:	cf 93       	push	r28
    4548:	df 93       	push	r29
    454a:	cd b7       	in	r28, 0x3d	; 61
    454c:	de b7       	in	r29, 0x3e	; 62
    454e:	a9 97       	sbiw	r28, 0x29	; 41
    4550:	cd bf       	out	0x3d, r28	; 61
    4552:	de bf       	out	0x3e, r29	; 62
	uint8_t Stick;
	char s[32];
	ADCStruct ADCData;

	vTaskDelay(300);
    4554:	8c e2       	ldi	r24, 0x2C	; 44
    4556:	91 e0       	ldi	r25, 0x01	; 1
    4558:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <vTaskDelay>
    455c:	8e 01       	movw	r16, r28
    455e:	0f 5f       	subi	r16, 0xFF	; 255
    4560:	1f 4f       	sbci	r17, 0xFF	; 255
		
		DriverOLEDClearScreen();
		ADCData=GetADCData();
		

		sprintf(s,"PHOTO1:%d",ADCData.PhotoL);
    4562:	8e e6       	ldi	r24, 0x6E	; 110
    4564:	88 2e       	mov	r8, r24
    4566:	83 e2       	ldi	r24, 0x23	; 35
    4568:	98 2e       	mov	r9, r24
		DriverOLEDPrintSmText(0,s,0);

		sprintf(s,"PHOTO2:%d",ADCData.PhotoM);
    456a:	98 e7       	ldi	r25, 0x78	; 120
    456c:	a9 2e       	mov	r10, r25
    456e:	93 e2       	ldi	r25, 0x23	; 35
    4570:	b9 2e       	mov	r11, r25
		DriverOLEDPrintSmText(1,s,0);
		
		sprintf(s,"PHOTO3:%d",ADCData.PhotoR);
    4572:	22 e8       	ldi	r18, 0x82	; 130
    4574:	62 2e       	mov	r6, r18
    4576:	23 e2       	ldi	r18, 0x23	; 35
    4578:	72 2e       	mov	r7, r18
		DriverOLEDPrintSmText(2,s,0);
		
		sprintf(s,"POT:%d",ADCData.Potmeter);
    457a:	3c e8       	ldi	r19, 0x8C	; 140
    457c:	43 2e       	mov	r4, r19
    457e:	33 e2       	ldi	r19, 0x23	; 35
    4580:	53 2e       	mov	r5, r19
		DriverOLEDPrintSmText(3,s,0);
		
		sprintf(s,"DIFF:%d",ADCData.PhotoL-ADCData.PhotoR);	
    4582:	43 e9       	ldi	r20, 0x93	; 147
    4584:	24 2e       	mov	r2, r20
    4586:	43 e2       	ldi	r20, 0x23	; 35
    4588:	34 2e       	mov	r3, r20
    458a:	06 c0       	rjmp	.+12     	; 0x4598 <PageADC+0x72>
		{
			vTaskDelay(300);
			return;
		}
		
		DriverOLEDUpdate();
    458c:	0e 94 14 06 	call	0xc28	; 0xc28 <DriverOLEDUpdate>
		
		
		vTaskDelay(300);
    4590:	8c e2       	ldi	r24, 0x2C	; 44
    4592:	91 e0       	ldi	r25, 0x01	; 1
    4594:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <vTaskDelay>
	ADCStruct ADCData;

	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorstickGet();
    4598:	0e 94 1b 03 	call	0x636	; 0x636 <DriverCursorstickGet>
    459c:	89 a7       	std	Y+41, r24	; 0x29
		
		
		DriverOLEDClearScreen();
    459e:	0e 94 56 06 	call	0xcac	; 0xcac <DriverOLEDClearScreen>
		ADCData=GetADCData();
    45a2:	0e 94 e8 1d 	call	0x3bd0	; 0x3bd0 <GetADCData>
    45a6:	29 a3       	std	Y+33, r18	; 0x21
    45a8:	3a a3       	std	Y+34, r19	; 0x22
    45aa:	4b a3       	std	Y+35, r20	; 0x23
    45ac:	5c a3       	std	Y+36, r21	; 0x24
    45ae:	6d a3       	std	Y+37, r22	; 0x25
    45b0:	7e a3       	std	Y+38, r23	; 0x26
    45b2:	8f a3       	std	Y+39, r24	; 0x27
    45b4:	98 a7       	std	Y+40, r25	; 0x28
    45b6:	e9 a0       	ldd	r14, Y+33	; 0x21
    45b8:	fa a0       	ldd	r15, Y+34	; 0x22
    45ba:	cd a0       	ldd	r12, Y+37	; 0x25
    45bc:	de a0       	ldd	r13, Y+38	; 0x26
		

		sprintf(s,"PHOTO1:%d",ADCData.PhotoL);
    45be:	ff 92       	push	r15
    45c0:	ef 92       	push	r14
    45c2:	9f 92       	push	r9
    45c4:	8f 92       	push	r8
    45c6:	1f 93       	push	r17
    45c8:	0f 93       	push	r16
    45ca:	0e 94 1e 2b 	call	0x563c	; 0x563c <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    45ce:	40 e0       	ldi	r20, 0x00	; 0
    45d0:	b8 01       	movw	r22, r16
    45d2:	80 e0       	ldi	r24, 0x00	; 0
    45d4:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>

		sprintf(s,"PHOTO2:%d",ADCData.PhotoM);
    45d8:	8c a1       	ldd	r24, Y+36	; 0x24
    45da:	8f 93       	push	r24
    45dc:	8b a1       	ldd	r24, Y+35	; 0x23
    45de:	8f 93       	push	r24
    45e0:	bf 92       	push	r11
    45e2:	af 92       	push	r10
    45e4:	1f 93       	push	r17
    45e6:	0f 93       	push	r16
    45e8:	0e 94 1e 2b 	call	0x563c	; 0x563c <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    45ec:	40 e0       	ldi	r20, 0x00	; 0
    45ee:	b8 01       	movw	r22, r16
    45f0:	81 e0       	ldi	r24, 0x01	; 1
    45f2:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
		
		sprintf(s,"PHOTO3:%d",ADCData.PhotoR);
    45f6:	df 92       	push	r13
    45f8:	cf 92       	push	r12
    45fa:	7f 92       	push	r7
    45fc:	6f 92       	push	r6
    45fe:	1f 93       	push	r17
    4600:	0f 93       	push	r16
    4602:	0e 94 1e 2b 	call	0x563c	; 0x563c <sprintf>
		DriverOLEDPrintSmText(2,s,0);
    4606:	40 e0       	ldi	r20, 0x00	; 0
    4608:	b8 01       	movw	r22, r16
    460a:	82 e0       	ldi	r24, 0x02	; 2
    460c:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
		
		sprintf(s,"POT:%d",ADCData.Potmeter);
    4610:	88 a5       	ldd	r24, Y+40	; 0x28
    4612:	8f 93       	push	r24
    4614:	8f a1       	ldd	r24, Y+39	; 0x27
    4616:	8f 93       	push	r24
    4618:	5f 92       	push	r5
    461a:	4f 92       	push	r4
    461c:	1f 93       	push	r17
    461e:	0f 93       	push	r16
    4620:	0e 94 1e 2b 	call	0x563c	; 0x563c <sprintf>
		DriverOLEDPrintSmText(3,s,0);
    4624:	40 e0       	ldi	r20, 0x00	; 0
    4626:	b8 01       	movw	r22, r16
    4628:	83 e0       	ldi	r24, 0x03	; 3
    462a:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
		
		sprintf(s,"DIFF:%d",ADCData.PhotoL-ADCData.PhotoR);	
    462e:	ec 18       	sub	r14, r12
    4630:	fd 08       	sbc	r15, r13
    4632:	ff 92       	push	r15
    4634:	ef 92       	push	r14
    4636:	3f 92       	push	r3
    4638:	2f 92       	push	r2
    463a:	1f 93       	push	r17
    463c:	0f 93       	push	r16
    463e:	0e 94 1e 2b 	call	0x563c	; 0x563c <sprintf>
		DriverOLEDPrintSmText(5,s,0);
    4642:	40 e0       	ldi	r20, 0x00	; 0
    4644:	b8 01       	movw	r22, r16
    4646:	85 e0       	ldi	r24, 0x05	; 5
    4648:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    464c:	cd bf       	out	0x3d, r28	; 61
    464e:	de bf       	out	0x3e, r29	; 62
    4650:	99 a5       	ldd	r25, Y+41	; 0x29
    4652:	94 ff       	sbrs	r25, 4
    4654:	9b cf       	rjmp	.-202    	; 0x458c <PageADC+0x66>
		{
			vTaskDelay(300);
    4656:	8c e2       	ldi	r24, 0x2C	; 44
    4658:	91 e0       	ldi	r25, 0x01	; 1
    465a:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <vTaskDelay>
		
		
		vTaskDelay(300);
		
	}
}
    465e:	a9 96       	adiw	r28, 0x29	; 41
    4660:	cd bf       	out	0x3d, r28	; 61
    4662:	de bf       	out	0x3e, r29	; 62
    4664:	df 91       	pop	r29
    4666:	cf 91       	pop	r28
    4668:	1f 91       	pop	r17
    466a:	0f 91       	pop	r16
    466c:	ff 90       	pop	r15
    466e:	ef 90       	pop	r14
    4670:	df 90       	pop	r13
    4672:	cf 90       	pop	r12
    4674:	bf 90       	pop	r11
    4676:	af 90       	pop	r10
    4678:	9f 90       	pop	r9
    467a:	8f 90       	pop	r8
    467c:	7f 90       	pop	r7
    467e:	6f 90       	pop	r6
    4680:	5f 90       	pop	r5
    4682:	4f 90       	pop	r4
    4684:	3f 90       	pop	r3
    4686:	2f 90       	pop	r2
    4688:	08 95       	ret

0000468a <PageLineFollow>:

void PageLineFollow()
{
    468a:	cf 93       	push	r28
		uint8_t Stick;
		char s[32];

		StartLineFollower(300.0);
    468c:	60 e0       	ldi	r22, 0x00	; 0
    468e:	70 e0       	ldi	r23, 0x00	; 0
    4690:	86 e9       	ldi	r24, 0x96	; 150
    4692:	93 e4       	ldi	r25, 0x43	; 67
    4694:	0e 94 d1 1e 	call	0x3da2	; 0x3da2 <StartLineFollower>
		vTaskDelay(300);
    4698:	8c e2       	ldi	r24, 0x2C	; 44
    469a:	91 e0       	ldi	r25, 0x01	; 1
    469c:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <vTaskDelay>
    46a0:	06 c0       	rjmp	.+12     	; 0x46ae <PageLineFollow+0x24>
				StopLineFollower();
				vTaskDelay(300);
				return;
			}
			
			DriverOLEDUpdate();
    46a2:	0e 94 14 06 	call	0xc28	; 0xc28 <DriverOLEDUpdate>
			
			
			vTaskDelay(300);
    46a6:	8c e2       	ldi	r24, 0x2C	; 44
    46a8:	91 e0       	ldi	r25, 0x01	; 1
    46aa:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <vTaskDelay>

		StartLineFollower(300.0);
		vTaskDelay(300);
		while (1)
		{
			Stick=DriverCursorstickGet();
    46ae:	0e 94 1b 03 	call	0x636	; 0x636 <DriverCursorstickGet>
    46b2:	c8 2f       	mov	r28, r24
			
			
			DriverOLEDClearScreen();
    46b4:	0e 94 56 06 	call	0xcac	; 0xcac <DriverOLEDClearScreen>
			

			DriverOLEDPrintSmText(0,"Line follower active",0);
    46b8:	40 e0       	ldi	r20, 0x00	; 0
    46ba:	6b e9       	ldi	r22, 0x9B	; 155
    46bc:	73 e2       	ldi	r23, 0x23	; 35
    46be:	80 e0       	ldi	r24, 0x00	; 0
    46c0:	0e 94 2f 08 	call	0x105e	; 0x105e <DriverOLEDPrintSmText>
			
			if (Stick & CURSOR_UP);
			if (Stick & CURSOR_DOWN);
			if (Stick & CURSOR_RIGHT);
			if (Stick & CURSOR_LEFT);
			if (Stick & CURSOR_PRESS)
    46c4:	c4 ff       	sbrs	r28, 4
    46c6:	ed cf       	rjmp	.-38     	; 0x46a2 <PageLineFollow+0x18>
			{
				StopLineFollower();
    46c8:	0e 94 e4 1e 	call	0x3dc8	; 0x3dc8 <StopLineFollower>
				vTaskDelay(300);
    46cc:	8c e2       	ldi	r24, 0x2C	; 44
    46ce:	91 e0       	ldi	r25, 0x01	; 1
			
			vTaskDelay(300);
			
		}
	
    46d0:	cf 91       	pop	r28
			if (Stick & CURSOR_RIGHT);
			if (Stick & CURSOR_LEFT);
			if (Stick & CURSOR_PRESS)
			{
				StopLineFollower();
				vTaskDelay(300);
    46d2:	0c 94 50 1a 	jmp	0x34a0	; 0x34a0 <vTaskDelay>

000046d6 <WorkerOLEDMenu>:
}

void WorkerOLEDMenu(void *pvParameters)
{
	uint8_t Stick;
	DriverOLEDInit(2);
    46d6:	82 e0       	ldi	r24, 0x02	; 2
    46d8:	0e 94 94 08 	call	0x1128	; 0x1128 <DriverOLEDInit>
	DriverAdps9960Init();
    46dc:	0e 94 5f 02 	call	0x4be	; 0x4be <DriverAdps9960Init>
    46e0:	1d c0       	rjmp	.+58     	; 0x471c <WorkerOLEDMenu+0x46>
}


void DownMenu()
{
	if (SelItem<NUM_LINES-1) SelItem++;
    46e2:	60 91 98 68 	lds	r22, 0x6898	; 0x806898 <SelItem>
    46e6:	67 30       	cpi	r22, 0x07	; 7
    46e8:	18 f4       	brcc	.+6      	; 0x46f0 <WorkerOLEDMenu+0x1a>
    46ea:	6f 5f       	subi	r22, 0xFF	; 255
    46ec:	60 93 98 68 	sts	0x6898, r22	; 0x806898 <SelItem>
	if (SelItem>=TopItem+DISPLAYED_LINES) TopItem++;
    46f0:	20 91 99 68 	lds	r18, 0x6899	; 0x806899 <TopItem>
    46f4:	82 2f       	mov	r24, r18
    46f6:	90 e0       	ldi	r25, 0x00	; 0
    46f8:	70 e0       	ldi	r23, 0x00	; 0
    46fa:	ac 01       	movw	r20, r24
    46fc:	4b 5f       	subi	r20, 0xFB	; 251
    46fe:	5f 4f       	sbci	r21, 0xFF	; 255
    4700:	46 17       	cp	r20, r22
    4702:	57 07       	cpc	r21, r23
    4704:	2c f4       	brge	.+10     	; 0x4710 <WorkerOLEDMenu+0x3a>
    4706:	2f 5f       	subi	r18, 0xFF	; 255
    4708:	20 93 99 68 	sts	0x6899, r18	; 0x806899 <TopItem>
    470c:	82 2f       	mov	r24, r18
    470e:	90 e0       	ldi	r25, 0x00	; 0
			else if (SelItem==3) PageADC();
			else if (SelItem==4) PageLineFollow();
			vTaskDelay(300);	
		}
		
		DrawMenu(TopItem,SelItem);
    4710:	0e 94 3e 20 	call	0x407c	; 0x407c <DrawMenu>
		vTaskDelay(100); //Periodic worker function; 100 ms
    4714:	84 e6       	ldi	r24, 0x64	; 100
    4716:	90 e0       	ldi	r25, 0x00	; 0
    4718:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <vTaskDelay>
	DriverOLEDInit(2);
	DriverAdps9960Init();
	
	while(1)
	{
		Stick=DriverCursorstickGet();
    471c:	0e 94 1b 03 	call	0x636	; 0x636 <DriverCursorstickGet>
		if (Stick & CURSOR_DOWN) DownMenu();
    4720:	82 fd       	sbrc	r24, 2
    4722:	df cf       	rjmp	.-66     	; 0x46e2 <WorkerOLEDMenu+0xc>
		else if (Stick & CURSOR_UP) UpMenu();
    4724:	80 ff       	sbrs	r24, 0
    4726:	0e c0       	rjmp	.+28     	; 0x4744 <WorkerOLEDMenu+0x6e>
	if (SelItem>=TopItem+DISPLAYED_LINES) TopItem++;
}

void UpMenu()
{
	if (SelItem>0) SelItem--;
    4728:	60 91 98 68 	lds	r22, 0x6898	; 0x806898 <SelItem>
    472c:	66 23       	and	r22, r22
    472e:	19 f0       	breq	.+6      	; 0x4736 <WorkerOLEDMenu+0x60>
    4730:	61 50       	subi	r22, 0x01	; 1
    4732:	60 93 98 68 	sts	0x6898, r22	; 0x806898 <SelItem>
	if (SelItem<TopItem) TopItem=SelItem;
    4736:	80 91 99 68 	lds	r24, 0x6899	; 0x806899 <TopItem>
    473a:	68 17       	cp	r22, r24
    473c:	e0 f0       	brcs	.+56     	; 0x4776 <WorkerOLEDMenu+0xa0>
    473e:	70 e0       	ldi	r23, 0x00	; 0
    4740:	90 e0       	ldi	r25, 0x00	; 0
    4742:	e6 cf       	rjmp	.-52     	; 0x4710 <WorkerOLEDMenu+0x3a>
	while(1)
	{
		Stick=DriverCursorstickGet();
		if (Stick & CURSOR_DOWN) DownMenu();
		else if (Stick & CURSOR_UP) UpMenu();
		else if (Stick & CURSOR_PRESS)
    4744:	84 ff       	sbrs	r24, 4
    4746:	10 c0       	rjmp	.+32     	; 0x4768 <WorkerOLEDMenu+0x92>
		{
			if (SelItem==0) PageCPUStatus();
    4748:	80 91 98 68 	lds	r24, 0x6898	; 0x806898 <SelItem>
    474c:	88 23       	and	r24, r24
    474e:	c1 f0       	breq	.+48     	; 0x4780 <WorkerOLEDMenu+0xaa>
			else if (SelItem==1) PageMotorSpeed();
    4750:	81 30       	cpi	r24, 0x01	; 1
    4752:	c9 f0       	breq	.+50     	; 0x4786 <WorkerOLEDMenu+0xb0>
			else if (SelItem==2) PageADPS9960();
    4754:	82 30       	cpi	r24, 0x02	; 2
    4756:	d1 f0       	breq	.+52     	; 0x478c <WorkerOLEDMenu+0xb6>
			else if (SelItem==3) PageADC();
    4758:	83 30       	cpi	r24, 0x03	; 3
    475a:	d9 f0       	breq	.+54     	; 0x4792 <WorkerOLEDMenu+0xbc>
			else if (SelItem==4) PageLineFollow();
    475c:	84 30       	cpi	r24, 0x04	; 4
    475e:	e1 f0       	breq	.+56     	; 0x4798 <WorkerOLEDMenu+0xc2>
			vTaskDelay(300);	
    4760:	8c e2       	ldi	r24, 0x2C	; 44
    4762:	91 e0       	ldi	r25, 0x01	; 1
    4764:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <vTaskDelay>
    4768:	60 91 98 68 	lds	r22, 0x6898	; 0x806898 <SelItem>
    476c:	70 e0       	ldi	r23, 0x00	; 0
    476e:	80 91 99 68 	lds	r24, 0x6899	; 0x806899 <TopItem>
    4772:	90 e0       	ldi	r25, 0x00	; 0
    4774:	cd cf       	rjmp	.-102    	; 0x4710 <WorkerOLEDMenu+0x3a>
}

void UpMenu()
{
	if (SelItem>0) SelItem--;
	if (SelItem<TopItem) TopItem=SelItem;
    4776:	60 93 99 68 	sts	0x6899, r22	; 0x806899 <TopItem>
    477a:	70 e0       	ldi	r23, 0x00	; 0
    477c:	cb 01       	movw	r24, r22
    477e:	c8 cf       	rjmp	.-112    	; 0x4710 <WorkerOLEDMenu+0x3a>
		Stick=DriverCursorstickGet();
		if (Stick & CURSOR_DOWN) DownMenu();
		else if (Stick & CURSOR_UP) UpMenu();
		else if (Stick & CURSOR_PRESS)
		{
			if (SelItem==0) PageCPUStatus();
    4780:	0e 94 67 20 	call	0x40ce	; 0x40ce <PageCPUStatus>
    4784:	ed cf       	rjmp	.-38     	; 0x4760 <WorkerOLEDMenu+0x8a>
			else if (SelItem==1) PageMotorSpeed();
    4786:	0e 94 3f 21 	call	0x427e	; 0x427e <PageMotorSpeed>
    478a:	ea cf       	rjmp	.-44     	; 0x4760 <WorkerOLEDMenu+0x8a>
			else if (SelItem==2) PageADPS9960();
    478c:	0e 94 f6 21 	call	0x43ec	; 0x43ec <PageADPS9960>
    4790:	e7 cf       	rjmp	.-50     	; 0x4760 <WorkerOLEDMenu+0x8a>
			else if (SelItem==3) PageADC();
    4792:	0e 94 93 22 	call	0x4526	; 0x4526 <PageADC>
    4796:	e4 cf       	rjmp	.-56     	; 0x4760 <WorkerOLEDMenu+0x8a>
			else if (SelItem==4) PageLineFollow();
    4798:	0e 94 45 23 	call	0x468a	; 0x468a <PageLineFollow>
    479c:	e1 cf       	rjmp	.-62     	; 0x4760 <WorkerOLEDMenu+0x8a>

0000479e <__subsf3>:
    479e:	50 58       	subi	r21, 0x80	; 128

000047a0 <__addsf3>:
    47a0:	bb 27       	eor	r27, r27
    47a2:	aa 27       	eor	r26, r26
    47a4:	0e 94 e7 23 	call	0x47ce	; 0x47ce <__addsf3x>
    47a8:	0c 94 61 25 	jmp	0x4ac2	; 0x4ac2 <__fp_round>
    47ac:	0e 94 53 25 	call	0x4aa6	; 0x4aa6 <__fp_pscA>
    47b0:	38 f0       	brcs	.+14     	; 0x47c0 <__addsf3+0x20>
    47b2:	0e 94 5a 25 	call	0x4ab4	; 0x4ab4 <__fp_pscB>
    47b6:	20 f0       	brcs	.+8      	; 0x47c0 <__addsf3+0x20>
    47b8:	39 f4       	brne	.+14     	; 0x47c8 <__addsf3+0x28>
    47ba:	9f 3f       	cpi	r25, 0xFF	; 255
    47bc:	19 f4       	brne	.+6      	; 0x47c4 <__addsf3+0x24>
    47be:	26 f4       	brtc	.+8      	; 0x47c8 <__addsf3+0x28>
    47c0:	0c 94 50 25 	jmp	0x4aa0	; 0x4aa0 <__fp_nan>
    47c4:	0e f4       	brtc	.+2      	; 0x47c8 <__addsf3+0x28>
    47c6:	e0 95       	com	r30
    47c8:	e7 fb       	bst	r30, 7
    47ca:	0c 94 4a 25 	jmp	0x4a94	; 0x4a94 <__fp_inf>

000047ce <__addsf3x>:
    47ce:	e9 2f       	mov	r30, r25
    47d0:	0e 94 72 25 	call	0x4ae4	; 0x4ae4 <__fp_split3>
    47d4:	58 f3       	brcs	.-42     	; 0x47ac <__addsf3+0xc>
    47d6:	ba 17       	cp	r27, r26
    47d8:	62 07       	cpc	r22, r18
    47da:	73 07       	cpc	r23, r19
    47dc:	84 07       	cpc	r24, r20
    47de:	95 07       	cpc	r25, r21
    47e0:	20 f0       	brcs	.+8      	; 0x47ea <__addsf3x+0x1c>
    47e2:	79 f4       	brne	.+30     	; 0x4802 <__addsf3x+0x34>
    47e4:	a6 f5       	brtc	.+104    	; 0x484e <__addsf3x+0x80>
    47e6:	0c 94 94 25 	jmp	0x4b28	; 0x4b28 <__fp_zero>
    47ea:	0e f4       	brtc	.+2      	; 0x47ee <__addsf3x+0x20>
    47ec:	e0 95       	com	r30
    47ee:	0b 2e       	mov	r0, r27
    47f0:	ba 2f       	mov	r27, r26
    47f2:	a0 2d       	mov	r26, r0
    47f4:	0b 01       	movw	r0, r22
    47f6:	b9 01       	movw	r22, r18
    47f8:	90 01       	movw	r18, r0
    47fa:	0c 01       	movw	r0, r24
    47fc:	ca 01       	movw	r24, r20
    47fe:	a0 01       	movw	r20, r0
    4800:	11 24       	eor	r1, r1
    4802:	ff 27       	eor	r31, r31
    4804:	59 1b       	sub	r21, r25
    4806:	99 f0       	breq	.+38     	; 0x482e <__addsf3x+0x60>
    4808:	59 3f       	cpi	r21, 0xF9	; 249
    480a:	50 f4       	brcc	.+20     	; 0x4820 <__addsf3x+0x52>
    480c:	50 3e       	cpi	r21, 0xE0	; 224
    480e:	68 f1       	brcs	.+90     	; 0x486a <__addsf3x+0x9c>
    4810:	1a 16       	cp	r1, r26
    4812:	f0 40       	sbci	r31, 0x00	; 0
    4814:	a2 2f       	mov	r26, r18
    4816:	23 2f       	mov	r18, r19
    4818:	34 2f       	mov	r19, r20
    481a:	44 27       	eor	r20, r20
    481c:	58 5f       	subi	r21, 0xF8	; 248
    481e:	f3 cf       	rjmp	.-26     	; 0x4806 <__addsf3x+0x38>
    4820:	46 95       	lsr	r20
    4822:	37 95       	ror	r19
    4824:	27 95       	ror	r18
    4826:	a7 95       	ror	r26
    4828:	f0 40       	sbci	r31, 0x00	; 0
    482a:	53 95       	inc	r21
    482c:	c9 f7       	brne	.-14     	; 0x4820 <__addsf3x+0x52>
    482e:	7e f4       	brtc	.+30     	; 0x484e <__addsf3x+0x80>
    4830:	1f 16       	cp	r1, r31
    4832:	ba 0b       	sbc	r27, r26
    4834:	62 0b       	sbc	r22, r18
    4836:	73 0b       	sbc	r23, r19
    4838:	84 0b       	sbc	r24, r20
    483a:	ba f0       	brmi	.+46     	; 0x486a <__addsf3x+0x9c>
    483c:	91 50       	subi	r25, 0x01	; 1
    483e:	a1 f0       	breq	.+40     	; 0x4868 <__addsf3x+0x9a>
    4840:	ff 0f       	add	r31, r31
    4842:	bb 1f       	adc	r27, r27
    4844:	66 1f       	adc	r22, r22
    4846:	77 1f       	adc	r23, r23
    4848:	88 1f       	adc	r24, r24
    484a:	c2 f7       	brpl	.-16     	; 0x483c <__addsf3x+0x6e>
    484c:	0e c0       	rjmp	.+28     	; 0x486a <__addsf3x+0x9c>
    484e:	ba 0f       	add	r27, r26
    4850:	62 1f       	adc	r22, r18
    4852:	73 1f       	adc	r23, r19
    4854:	84 1f       	adc	r24, r20
    4856:	48 f4       	brcc	.+18     	; 0x486a <__addsf3x+0x9c>
    4858:	87 95       	ror	r24
    485a:	77 95       	ror	r23
    485c:	67 95       	ror	r22
    485e:	b7 95       	ror	r27
    4860:	f7 95       	ror	r31
    4862:	9e 3f       	cpi	r25, 0xFE	; 254
    4864:	08 f0       	brcs	.+2      	; 0x4868 <__addsf3x+0x9a>
    4866:	b0 cf       	rjmp	.-160    	; 0x47c8 <__addsf3+0x28>
    4868:	93 95       	inc	r25
    486a:	88 0f       	add	r24, r24
    486c:	08 f0       	brcs	.+2      	; 0x4870 <__addsf3x+0xa2>
    486e:	99 27       	eor	r25, r25
    4870:	ee 0f       	add	r30, r30
    4872:	97 95       	ror	r25
    4874:	87 95       	ror	r24
    4876:	08 95       	ret

00004878 <__cmpsf2>:
    4878:	0e 94 26 25 	call	0x4a4c	; 0x4a4c <__fp_cmp>
    487c:	08 f4       	brcc	.+2      	; 0x4880 <__cmpsf2+0x8>
    487e:	81 e0       	ldi	r24, 0x01	; 1
    4880:	08 95       	ret

00004882 <__divsf3>:
    4882:	0e 94 55 24 	call	0x48aa	; 0x48aa <__divsf3x>
    4886:	0c 94 61 25 	jmp	0x4ac2	; 0x4ac2 <__fp_round>
    488a:	0e 94 5a 25 	call	0x4ab4	; 0x4ab4 <__fp_pscB>
    488e:	58 f0       	brcs	.+22     	; 0x48a6 <__divsf3+0x24>
    4890:	0e 94 53 25 	call	0x4aa6	; 0x4aa6 <__fp_pscA>
    4894:	40 f0       	brcs	.+16     	; 0x48a6 <__divsf3+0x24>
    4896:	29 f4       	brne	.+10     	; 0x48a2 <__divsf3+0x20>
    4898:	5f 3f       	cpi	r21, 0xFF	; 255
    489a:	29 f0       	breq	.+10     	; 0x48a6 <__divsf3+0x24>
    489c:	0c 94 4a 25 	jmp	0x4a94	; 0x4a94 <__fp_inf>
    48a0:	51 11       	cpse	r21, r1
    48a2:	0c 94 95 25 	jmp	0x4b2a	; 0x4b2a <__fp_szero>
    48a6:	0c 94 50 25 	jmp	0x4aa0	; 0x4aa0 <__fp_nan>

000048aa <__divsf3x>:
    48aa:	0e 94 72 25 	call	0x4ae4	; 0x4ae4 <__fp_split3>
    48ae:	68 f3       	brcs	.-38     	; 0x488a <__divsf3+0x8>

000048b0 <__divsf3_pse>:
    48b0:	99 23       	and	r25, r25
    48b2:	b1 f3       	breq	.-20     	; 0x48a0 <__divsf3+0x1e>
    48b4:	55 23       	and	r21, r21
    48b6:	91 f3       	breq	.-28     	; 0x489c <__divsf3+0x1a>
    48b8:	95 1b       	sub	r25, r21
    48ba:	55 0b       	sbc	r21, r21
    48bc:	bb 27       	eor	r27, r27
    48be:	aa 27       	eor	r26, r26
    48c0:	62 17       	cp	r22, r18
    48c2:	73 07       	cpc	r23, r19
    48c4:	84 07       	cpc	r24, r20
    48c6:	38 f0       	brcs	.+14     	; 0x48d6 <__divsf3_pse+0x26>
    48c8:	9f 5f       	subi	r25, 0xFF	; 255
    48ca:	5f 4f       	sbci	r21, 0xFF	; 255
    48cc:	22 0f       	add	r18, r18
    48ce:	33 1f       	adc	r19, r19
    48d0:	44 1f       	adc	r20, r20
    48d2:	aa 1f       	adc	r26, r26
    48d4:	a9 f3       	breq	.-22     	; 0x48c0 <__divsf3_pse+0x10>
    48d6:	35 d0       	rcall	.+106    	; 0x4942 <__divsf3_pse+0x92>
    48d8:	0e 2e       	mov	r0, r30
    48da:	3a f0       	brmi	.+14     	; 0x48ea <__divsf3_pse+0x3a>
    48dc:	e0 e8       	ldi	r30, 0x80	; 128
    48de:	32 d0       	rcall	.+100    	; 0x4944 <__divsf3_pse+0x94>
    48e0:	91 50       	subi	r25, 0x01	; 1
    48e2:	50 40       	sbci	r21, 0x00	; 0
    48e4:	e6 95       	lsr	r30
    48e6:	00 1c       	adc	r0, r0
    48e8:	ca f7       	brpl	.-14     	; 0x48dc <__divsf3_pse+0x2c>
    48ea:	2b d0       	rcall	.+86     	; 0x4942 <__divsf3_pse+0x92>
    48ec:	fe 2f       	mov	r31, r30
    48ee:	29 d0       	rcall	.+82     	; 0x4942 <__divsf3_pse+0x92>
    48f0:	66 0f       	add	r22, r22
    48f2:	77 1f       	adc	r23, r23
    48f4:	88 1f       	adc	r24, r24
    48f6:	bb 1f       	adc	r27, r27
    48f8:	26 17       	cp	r18, r22
    48fa:	37 07       	cpc	r19, r23
    48fc:	48 07       	cpc	r20, r24
    48fe:	ab 07       	cpc	r26, r27
    4900:	b0 e8       	ldi	r27, 0x80	; 128
    4902:	09 f0       	breq	.+2      	; 0x4906 <__divsf3_pse+0x56>
    4904:	bb 0b       	sbc	r27, r27
    4906:	80 2d       	mov	r24, r0
    4908:	bf 01       	movw	r22, r30
    490a:	ff 27       	eor	r31, r31
    490c:	93 58       	subi	r25, 0x83	; 131
    490e:	5f 4f       	sbci	r21, 0xFF	; 255
    4910:	3a f0       	brmi	.+14     	; 0x4920 <__divsf3_pse+0x70>
    4912:	9e 3f       	cpi	r25, 0xFE	; 254
    4914:	51 05       	cpc	r21, r1
    4916:	78 f0       	brcs	.+30     	; 0x4936 <__divsf3_pse+0x86>
    4918:	0c 94 4a 25 	jmp	0x4a94	; 0x4a94 <__fp_inf>
    491c:	0c 94 95 25 	jmp	0x4b2a	; 0x4b2a <__fp_szero>
    4920:	5f 3f       	cpi	r21, 0xFF	; 255
    4922:	e4 f3       	brlt	.-8      	; 0x491c <__divsf3_pse+0x6c>
    4924:	98 3e       	cpi	r25, 0xE8	; 232
    4926:	d4 f3       	brlt	.-12     	; 0x491c <__divsf3_pse+0x6c>
    4928:	86 95       	lsr	r24
    492a:	77 95       	ror	r23
    492c:	67 95       	ror	r22
    492e:	b7 95       	ror	r27
    4930:	f7 95       	ror	r31
    4932:	9f 5f       	subi	r25, 0xFF	; 255
    4934:	c9 f7       	brne	.-14     	; 0x4928 <__divsf3_pse+0x78>
    4936:	88 0f       	add	r24, r24
    4938:	91 1d       	adc	r25, r1
    493a:	96 95       	lsr	r25
    493c:	87 95       	ror	r24
    493e:	97 f9       	bld	r25, 7
    4940:	08 95       	ret
    4942:	e1 e0       	ldi	r30, 0x01	; 1
    4944:	66 0f       	add	r22, r22
    4946:	77 1f       	adc	r23, r23
    4948:	88 1f       	adc	r24, r24
    494a:	bb 1f       	adc	r27, r27
    494c:	62 17       	cp	r22, r18
    494e:	73 07       	cpc	r23, r19
    4950:	84 07       	cpc	r24, r20
    4952:	ba 07       	cpc	r27, r26
    4954:	20 f0       	brcs	.+8      	; 0x495e <__divsf3_pse+0xae>
    4956:	62 1b       	sub	r22, r18
    4958:	73 0b       	sbc	r23, r19
    495a:	84 0b       	sbc	r24, r20
    495c:	ba 0b       	sbc	r27, r26
    495e:	ee 1f       	adc	r30, r30
    4960:	88 f7       	brcc	.-30     	; 0x4944 <__divsf3_pse+0x94>
    4962:	e0 95       	com	r30
    4964:	08 95       	ret

00004966 <__fixsfsi>:
    4966:	0e 94 ba 24 	call	0x4974	; 0x4974 <__fixunssfsi>
    496a:	68 94       	set
    496c:	b1 11       	cpse	r27, r1
    496e:	0c 94 95 25 	jmp	0x4b2a	; 0x4b2a <__fp_szero>
    4972:	08 95       	ret

00004974 <__fixunssfsi>:
    4974:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <__fp_splitA>
    4978:	88 f0       	brcs	.+34     	; 0x499c <__fixunssfsi+0x28>
    497a:	9f 57       	subi	r25, 0x7F	; 127
    497c:	98 f0       	brcs	.+38     	; 0x49a4 <__fixunssfsi+0x30>
    497e:	b9 2f       	mov	r27, r25
    4980:	99 27       	eor	r25, r25
    4982:	b7 51       	subi	r27, 0x17	; 23
    4984:	b0 f0       	brcs	.+44     	; 0x49b2 <__fixunssfsi+0x3e>
    4986:	e1 f0       	breq	.+56     	; 0x49c0 <__fixunssfsi+0x4c>
    4988:	66 0f       	add	r22, r22
    498a:	77 1f       	adc	r23, r23
    498c:	88 1f       	adc	r24, r24
    498e:	99 1f       	adc	r25, r25
    4990:	1a f0       	brmi	.+6      	; 0x4998 <__fixunssfsi+0x24>
    4992:	ba 95       	dec	r27
    4994:	c9 f7       	brne	.-14     	; 0x4988 <__fixunssfsi+0x14>
    4996:	14 c0       	rjmp	.+40     	; 0x49c0 <__fixunssfsi+0x4c>
    4998:	b1 30       	cpi	r27, 0x01	; 1
    499a:	91 f0       	breq	.+36     	; 0x49c0 <__fixunssfsi+0x4c>
    499c:	0e 94 94 25 	call	0x4b28	; 0x4b28 <__fp_zero>
    49a0:	b1 e0       	ldi	r27, 0x01	; 1
    49a2:	08 95       	ret
    49a4:	0c 94 94 25 	jmp	0x4b28	; 0x4b28 <__fp_zero>
    49a8:	67 2f       	mov	r22, r23
    49aa:	78 2f       	mov	r23, r24
    49ac:	88 27       	eor	r24, r24
    49ae:	b8 5f       	subi	r27, 0xF8	; 248
    49b0:	39 f0       	breq	.+14     	; 0x49c0 <__fixunssfsi+0x4c>
    49b2:	b9 3f       	cpi	r27, 0xF9	; 249
    49b4:	cc f3       	brlt	.-14     	; 0x49a8 <__fixunssfsi+0x34>
    49b6:	86 95       	lsr	r24
    49b8:	77 95       	ror	r23
    49ba:	67 95       	ror	r22
    49bc:	b3 95       	inc	r27
    49be:	d9 f7       	brne	.-10     	; 0x49b6 <__fixunssfsi+0x42>
    49c0:	3e f4       	brtc	.+14     	; 0x49d0 <__fixunssfsi+0x5c>
    49c2:	90 95       	com	r25
    49c4:	80 95       	com	r24
    49c6:	70 95       	com	r23
    49c8:	61 95       	neg	r22
    49ca:	7f 4f       	sbci	r23, 0xFF	; 255
    49cc:	8f 4f       	sbci	r24, 0xFF	; 255
    49ce:	9f 4f       	sbci	r25, 0xFF	; 255
    49d0:	08 95       	ret

000049d2 <__floatunsisf>:
    49d2:	e8 94       	clt
    49d4:	09 c0       	rjmp	.+18     	; 0x49e8 <__floatsisf+0x12>

000049d6 <__floatsisf>:
    49d6:	97 fb       	bst	r25, 7
    49d8:	3e f4       	brtc	.+14     	; 0x49e8 <__floatsisf+0x12>
    49da:	90 95       	com	r25
    49dc:	80 95       	com	r24
    49de:	70 95       	com	r23
    49e0:	61 95       	neg	r22
    49e2:	7f 4f       	sbci	r23, 0xFF	; 255
    49e4:	8f 4f       	sbci	r24, 0xFF	; 255
    49e6:	9f 4f       	sbci	r25, 0xFF	; 255
    49e8:	99 23       	and	r25, r25
    49ea:	a9 f0       	breq	.+42     	; 0x4a16 <__floatsisf+0x40>
    49ec:	f9 2f       	mov	r31, r25
    49ee:	96 e9       	ldi	r25, 0x96	; 150
    49f0:	bb 27       	eor	r27, r27
    49f2:	93 95       	inc	r25
    49f4:	f6 95       	lsr	r31
    49f6:	87 95       	ror	r24
    49f8:	77 95       	ror	r23
    49fa:	67 95       	ror	r22
    49fc:	b7 95       	ror	r27
    49fe:	f1 11       	cpse	r31, r1
    4a00:	f8 cf       	rjmp	.-16     	; 0x49f2 <__floatsisf+0x1c>
    4a02:	fa f4       	brpl	.+62     	; 0x4a42 <__floatsisf+0x6c>
    4a04:	bb 0f       	add	r27, r27
    4a06:	11 f4       	brne	.+4      	; 0x4a0c <__floatsisf+0x36>
    4a08:	60 ff       	sbrs	r22, 0
    4a0a:	1b c0       	rjmp	.+54     	; 0x4a42 <__floatsisf+0x6c>
    4a0c:	6f 5f       	subi	r22, 0xFF	; 255
    4a0e:	7f 4f       	sbci	r23, 0xFF	; 255
    4a10:	8f 4f       	sbci	r24, 0xFF	; 255
    4a12:	9f 4f       	sbci	r25, 0xFF	; 255
    4a14:	16 c0       	rjmp	.+44     	; 0x4a42 <__floatsisf+0x6c>
    4a16:	88 23       	and	r24, r24
    4a18:	11 f0       	breq	.+4      	; 0x4a1e <__floatsisf+0x48>
    4a1a:	96 e9       	ldi	r25, 0x96	; 150
    4a1c:	11 c0       	rjmp	.+34     	; 0x4a40 <__floatsisf+0x6a>
    4a1e:	77 23       	and	r23, r23
    4a20:	21 f0       	breq	.+8      	; 0x4a2a <__floatsisf+0x54>
    4a22:	9e e8       	ldi	r25, 0x8E	; 142
    4a24:	87 2f       	mov	r24, r23
    4a26:	76 2f       	mov	r23, r22
    4a28:	05 c0       	rjmp	.+10     	; 0x4a34 <__floatsisf+0x5e>
    4a2a:	66 23       	and	r22, r22
    4a2c:	71 f0       	breq	.+28     	; 0x4a4a <__floatsisf+0x74>
    4a2e:	96 e8       	ldi	r25, 0x86	; 134
    4a30:	86 2f       	mov	r24, r22
    4a32:	70 e0       	ldi	r23, 0x00	; 0
    4a34:	60 e0       	ldi	r22, 0x00	; 0
    4a36:	2a f0       	brmi	.+10     	; 0x4a42 <__floatsisf+0x6c>
    4a38:	9a 95       	dec	r25
    4a3a:	66 0f       	add	r22, r22
    4a3c:	77 1f       	adc	r23, r23
    4a3e:	88 1f       	adc	r24, r24
    4a40:	da f7       	brpl	.-10     	; 0x4a38 <__floatsisf+0x62>
    4a42:	88 0f       	add	r24, r24
    4a44:	96 95       	lsr	r25
    4a46:	87 95       	ror	r24
    4a48:	97 f9       	bld	r25, 7
    4a4a:	08 95       	ret

00004a4c <__fp_cmp>:
    4a4c:	99 0f       	add	r25, r25
    4a4e:	00 08       	sbc	r0, r0
    4a50:	55 0f       	add	r21, r21
    4a52:	aa 0b       	sbc	r26, r26
    4a54:	e0 e8       	ldi	r30, 0x80	; 128
    4a56:	fe ef       	ldi	r31, 0xFE	; 254
    4a58:	16 16       	cp	r1, r22
    4a5a:	17 06       	cpc	r1, r23
    4a5c:	e8 07       	cpc	r30, r24
    4a5e:	f9 07       	cpc	r31, r25
    4a60:	c0 f0       	brcs	.+48     	; 0x4a92 <__fp_cmp+0x46>
    4a62:	12 16       	cp	r1, r18
    4a64:	13 06       	cpc	r1, r19
    4a66:	e4 07       	cpc	r30, r20
    4a68:	f5 07       	cpc	r31, r21
    4a6a:	98 f0       	brcs	.+38     	; 0x4a92 <__fp_cmp+0x46>
    4a6c:	62 1b       	sub	r22, r18
    4a6e:	73 0b       	sbc	r23, r19
    4a70:	84 0b       	sbc	r24, r20
    4a72:	95 0b       	sbc	r25, r21
    4a74:	39 f4       	brne	.+14     	; 0x4a84 <__fp_cmp+0x38>
    4a76:	0a 26       	eor	r0, r26
    4a78:	61 f0       	breq	.+24     	; 0x4a92 <__fp_cmp+0x46>
    4a7a:	23 2b       	or	r18, r19
    4a7c:	24 2b       	or	r18, r20
    4a7e:	25 2b       	or	r18, r21
    4a80:	21 f4       	brne	.+8      	; 0x4a8a <__fp_cmp+0x3e>
    4a82:	08 95       	ret
    4a84:	0a 26       	eor	r0, r26
    4a86:	09 f4       	brne	.+2      	; 0x4a8a <__fp_cmp+0x3e>
    4a88:	a1 40       	sbci	r26, 0x01	; 1
    4a8a:	a6 95       	lsr	r26
    4a8c:	8f ef       	ldi	r24, 0xFF	; 255
    4a8e:	81 1d       	adc	r24, r1
    4a90:	81 1d       	adc	r24, r1
    4a92:	08 95       	ret

00004a94 <__fp_inf>:
    4a94:	97 f9       	bld	r25, 7
    4a96:	9f 67       	ori	r25, 0x7F	; 127
    4a98:	80 e8       	ldi	r24, 0x80	; 128
    4a9a:	70 e0       	ldi	r23, 0x00	; 0
    4a9c:	60 e0       	ldi	r22, 0x00	; 0
    4a9e:	08 95       	ret

00004aa0 <__fp_nan>:
    4aa0:	9f ef       	ldi	r25, 0xFF	; 255
    4aa2:	80 ec       	ldi	r24, 0xC0	; 192
    4aa4:	08 95       	ret

00004aa6 <__fp_pscA>:
    4aa6:	00 24       	eor	r0, r0
    4aa8:	0a 94       	dec	r0
    4aaa:	16 16       	cp	r1, r22
    4aac:	17 06       	cpc	r1, r23
    4aae:	18 06       	cpc	r1, r24
    4ab0:	09 06       	cpc	r0, r25
    4ab2:	08 95       	ret

00004ab4 <__fp_pscB>:
    4ab4:	00 24       	eor	r0, r0
    4ab6:	0a 94       	dec	r0
    4ab8:	12 16       	cp	r1, r18
    4aba:	13 06       	cpc	r1, r19
    4abc:	14 06       	cpc	r1, r20
    4abe:	05 06       	cpc	r0, r21
    4ac0:	08 95       	ret

00004ac2 <__fp_round>:
    4ac2:	09 2e       	mov	r0, r25
    4ac4:	03 94       	inc	r0
    4ac6:	00 0c       	add	r0, r0
    4ac8:	11 f4       	brne	.+4      	; 0x4ace <__fp_round+0xc>
    4aca:	88 23       	and	r24, r24
    4acc:	52 f0       	brmi	.+20     	; 0x4ae2 <__fp_round+0x20>
    4ace:	bb 0f       	add	r27, r27
    4ad0:	40 f4       	brcc	.+16     	; 0x4ae2 <__fp_round+0x20>
    4ad2:	bf 2b       	or	r27, r31
    4ad4:	11 f4       	brne	.+4      	; 0x4ada <__fp_round+0x18>
    4ad6:	60 ff       	sbrs	r22, 0
    4ad8:	04 c0       	rjmp	.+8      	; 0x4ae2 <__fp_round+0x20>
    4ada:	6f 5f       	subi	r22, 0xFF	; 255
    4adc:	7f 4f       	sbci	r23, 0xFF	; 255
    4ade:	8f 4f       	sbci	r24, 0xFF	; 255
    4ae0:	9f 4f       	sbci	r25, 0xFF	; 255
    4ae2:	08 95       	ret

00004ae4 <__fp_split3>:
    4ae4:	57 fd       	sbrc	r21, 7
    4ae6:	90 58       	subi	r25, 0x80	; 128
    4ae8:	44 0f       	add	r20, r20
    4aea:	55 1f       	adc	r21, r21
    4aec:	59 f0       	breq	.+22     	; 0x4b04 <__fp_splitA+0x10>
    4aee:	5f 3f       	cpi	r21, 0xFF	; 255
    4af0:	71 f0       	breq	.+28     	; 0x4b0e <__fp_splitA+0x1a>
    4af2:	47 95       	ror	r20

00004af4 <__fp_splitA>:
    4af4:	88 0f       	add	r24, r24
    4af6:	97 fb       	bst	r25, 7
    4af8:	99 1f       	adc	r25, r25
    4afa:	61 f0       	breq	.+24     	; 0x4b14 <__fp_splitA+0x20>
    4afc:	9f 3f       	cpi	r25, 0xFF	; 255
    4afe:	79 f0       	breq	.+30     	; 0x4b1e <__fp_splitA+0x2a>
    4b00:	87 95       	ror	r24
    4b02:	08 95       	ret
    4b04:	12 16       	cp	r1, r18
    4b06:	13 06       	cpc	r1, r19
    4b08:	14 06       	cpc	r1, r20
    4b0a:	55 1f       	adc	r21, r21
    4b0c:	f2 cf       	rjmp	.-28     	; 0x4af2 <__fp_split3+0xe>
    4b0e:	46 95       	lsr	r20
    4b10:	f1 df       	rcall	.-30     	; 0x4af4 <__fp_splitA>
    4b12:	08 c0       	rjmp	.+16     	; 0x4b24 <__fp_splitA+0x30>
    4b14:	16 16       	cp	r1, r22
    4b16:	17 06       	cpc	r1, r23
    4b18:	18 06       	cpc	r1, r24
    4b1a:	99 1f       	adc	r25, r25
    4b1c:	f1 cf       	rjmp	.-30     	; 0x4b00 <__fp_splitA+0xc>
    4b1e:	86 95       	lsr	r24
    4b20:	71 05       	cpc	r23, r1
    4b22:	61 05       	cpc	r22, r1
    4b24:	08 94       	sec
    4b26:	08 95       	ret

00004b28 <__fp_zero>:
    4b28:	e8 94       	clt

00004b2a <__fp_szero>:
    4b2a:	bb 27       	eor	r27, r27
    4b2c:	66 27       	eor	r22, r22
    4b2e:	77 27       	eor	r23, r23
    4b30:	cb 01       	movw	r24, r22
    4b32:	97 f9       	bld	r25, 7
    4b34:	08 95       	ret

00004b36 <__mulsf3>:
    4b36:	0e 94 ae 25 	call	0x4b5c	; 0x4b5c <__mulsf3x>
    4b3a:	0c 94 61 25 	jmp	0x4ac2	; 0x4ac2 <__fp_round>
    4b3e:	0e 94 53 25 	call	0x4aa6	; 0x4aa6 <__fp_pscA>
    4b42:	38 f0       	brcs	.+14     	; 0x4b52 <__mulsf3+0x1c>
    4b44:	0e 94 5a 25 	call	0x4ab4	; 0x4ab4 <__fp_pscB>
    4b48:	20 f0       	brcs	.+8      	; 0x4b52 <__mulsf3+0x1c>
    4b4a:	95 23       	and	r25, r21
    4b4c:	11 f0       	breq	.+4      	; 0x4b52 <__mulsf3+0x1c>
    4b4e:	0c 94 4a 25 	jmp	0x4a94	; 0x4a94 <__fp_inf>
    4b52:	0c 94 50 25 	jmp	0x4aa0	; 0x4aa0 <__fp_nan>
    4b56:	11 24       	eor	r1, r1
    4b58:	0c 94 95 25 	jmp	0x4b2a	; 0x4b2a <__fp_szero>

00004b5c <__mulsf3x>:
    4b5c:	0e 94 72 25 	call	0x4ae4	; 0x4ae4 <__fp_split3>
    4b60:	70 f3       	brcs	.-36     	; 0x4b3e <__mulsf3+0x8>

00004b62 <__mulsf3_pse>:
    4b62:	95 9f       	mul	r25, r21
    4b64:	c1 f3       	breq	.-16     	; 0x4b56 <__mulsf3+0x20>
    4b66:	95 0f       	add	r25, r21
    4b68:	50 e0       	ldi	r21, 0x00	; 0
    4b6a:	55 1f       	adc	r21, r21
    4b6c:	62 9f       	mul	r22, r18
    4b6e:	f0 01       	movw	r30, r0
    4b70:	72 9f       	mul	r23, r18
    4b72:	bb 27       	eor	r27, r27
    4b74:	f0 0d       	add	r31, r0
    4b76:	b1 1d       	adc	r27, r1
    4b78:	63 9f       	mul	r22, r19
    4b7a:	aa 27       	eor	r26, r26
    4b7c:	f0 0d       	add	r31, r0
    4b7e:	b1 1d       	adc	r27, r1
    4b80:	aa 1f       	adc	r26, r26
    4b82:	64 9f       	mul	r22, r20
    4b84:	66 27       	eor	r22, r22
    4b86:	b0 0d       	add	r27, r0
    4b88:	a1 1d       	adc	r26, r1
    4b8a:	66 1f       	adc	r22, r22
    4b8c:	82 9f       	mul	r24, r18
    4b8e:	22 27       	eor	r18, r18
    4b90:	b0 0d       	add	r27, r0
    4b92:	a1 1d       	adc	r26, r1
    4b94:	62 1f       	adc	r22, r18
    4b96:	73 9f       	mul	r23, r19
    4b98:	b0 0d       	add	r27, r0
    4b9a:	a1 1d       	adc	r26, r1
    4b9c:	62 1f       	adc	r22, r18
    4b9e:	83 9f       	mul	r24, r19
    4ba0:	a0 0d       	add	r26, r0
    4ba2:	61 1d       	adc	r22, r1
    4ba4:	22 1f       	adc	r18, r18
    4ba6:	74 9f       	mul	r23, r20
    4ba8:	33 27       	eor	r19, r19
    4baa:	a0 0d       	add	r26, r0
    4bac:	61 1d       	adc	r22, r1
    4bae:	23 1f       	adc	r18, r19
    4bb0:	84 9f       	mul	r24, r20
    4bb2:	60 0d       	add	r22, r0
    4bb4:	21 1d       	adc	r18, r1
    4bb6:	82 2f       	mov	r24, r18
    4bb8:	76 2f       	mov	r23, r22
    4bba:	6a 2f       	mov	r22, r26
    4bbc:	11 24       	eor	r1, r1
    4bbe:	9f 57       	subi	r25, 0x7F	; 127
    4bc0:	50 40       	sbci	r21, 0x00	; 0
    4bc2:	9a f0       	brmi	.+38     	; 0x4bea <__mulsf3_pse+0x88>
    4bc4:	f1 f0       	breq	.+60     	; 0x4c02 <__mulsf3_pse+0xa0>
    4bc6:	88 23       	and	r24, r24
    4bc8:	4a f0       	brmi	.+18     	; 0x4bdc <__mulsf3_pse+0x7a>
    4bca:	ee 0f       	add	r30, r30
    4bcc:	ff 1f       	adc	r31, r31
    4bce:	bb 1f       	adc	r27, r27
    4bd0:	66 1f       	adc	r22, r22
    4bd2:	77 1f       	adc	r23, r23
    4bd4:	88 1f       	adc	r24, r24
    4bd6:	91 50       	subi	r25, 0x01	; 1
    4bd8:	50 40       	sbci	r21, 0x00	; 0
    4bda:	a9 f7       	brne	.-22     	; 0x4bc6 <__mulsf3_pse+0x64>
    4bdc:	9e 3f       	cpi	r25, 0xFE	; 254
    4bde:	51 05       	cpc	r21, r1
    4be0:	80 f0       	brcs	.+32     	; 0x4c02 <__mulsf3_pse+0xa0>
    4be2:	0c 94 4a 25 	jmp	0x4a94	; 0x4a94 <__fp_inf>
    4be6:	0c 94 95 25 	jmp	0x4b2a	; 0x4b2a <__fp_szero>
    4bea:	5f 3f       	cpi	r21, 0xFF	; 255
    4bec:	e4 f3       	brlt	.-8      	; 0x4be6 <__mulsf3_pse+0x84>
    4bee:	98 3e       	cpi	r25, 0xE8	; 232
    4bf0:	d4 f3       	brlt	.-12     	; 0x4be6 <__mulsf3_pse+0x84>
    4bf2:	86 95       	lsr	r24
    4bf4:	77 95       	ror	r23
    4bf6:	67 95       	ror	r22
    4bf8:	b7 95       	ror	r27
    4bfa:	f7 95       	ror	r31
    4bfc:	e7 95       	ror	r30
    4bfe:	9f 5f       	subi	r25, 0xFF	; 255
    4c00:	c1 f7       	brne	.-16     	; 0x4bf2 <__mulsf3_pse+0x90>
    4c02:	fe 2b       	or	r31, r30
    4c04:	88 0f       	add	r24, r24
    4c06:	91 1d       	adc	r25, r1
    4c08:	96 95       	lsr	r25
    4c0a:	87 95       	ror	r24
    4c0c:	97 f9       	bld	r25, 7
    4c0e:	08 95       	ret

00004c10 <vfprintf>:
    4c10:	2f 92       	push	r2
    4c12:	3f 92       	push	r3
    4c14:	4f 92       	push	r4
    4c16:	5f 92       	push	r5
    4c18:	6f 92       	push	r6
    4c1a:	7f 92       	push	r7
    4c1c:	8f 92       	push	r8
    4c1e:	9f 92       	push	r9
    4c20:	af 92       	push	r10
    4c22:	bf 92       	push	r11
    4c24:	cf 92       	push	r12
    4c26:	df 92       	push	r13
    4c28:	ef 92       	push	r14
    4c2a:	ff 92       	push	r15
    4c2c:	0f 93       	push	r16
    4c2e:	1f 93       	push	r17
    4c30:	cf 93       	push	r28
    4c32:	df 93       	push	r29
    4c34:	cd b7       	in	r28, 0x3d	; 61
    4c36:	de b7       	in	r29, 0x3e	; 62
    4c38:	60 97       	sbiw	r28, 0x10	; 16
    4c3a:	cd bf       	out	0x3d, r28	; 61
    4c3c:	de bf       	out	0x3e, r29	; 62
    4c3e:	7c 01       	movw	r14, r24
    4c40:	1b 01       	movw	r2, r22
    4c42:	6a 01       	movw	r12, r20
    4c44:	fc 01       	movw	r30, r24
    4c46:	16 82       	std	Z+6, r1	; 0x06
    4c48:	17 82       	std	Z+7, r1	; 0x07
    4c4a:	83 81       	ldd	r24, Z+3	; 0x03
    4c4c:	81 ff       	sbrs	r24, 1
    4c4e:	44 c3       	rjmp	.+1672   	; 0x52d8 <vfprintf+0x6c8>
    4c50:	9e 01       	movw	r18, r28
    4c52:	2f 5f       	subi	r18, 0xFF	; 255
    4c54:	3f 4f       	sbci	r19, 0xFF	; 255
    4c56:	39 01       	movw	r6, r18
    4c58:	f7 01       	movw	r30, r14
    4c5a:	93 81       	ldd	r25, Z+3	; 0x03
    4c5c:	f1 01       	movw	r30, r2
    4c5e:	93 fd       	sbrc	r25, 3
    4c60:	85 91       	lpm	r24, Z+
    4c62:	93 ff       	sbrs	r25, 3
    4c64:	81 91       	ld	r24, Z+
    4c66:	1f 01       	movw	r2, r30
    4c68:	88 23       	and	r24, r24
    4c6a:	09 f4       	brne	.+2      	; 0x4c6e <vfprintf+0x5e>
    4c6c:	31 c3       	rjmp	.+1634   	; 0x52d0 <vfprintf+0x6c0>
    4c6e:	85 32       	cpi	r24, 0x25	; 37
    4c70:	39 f4       	brne	.+14     	; 0x4c80 <vfprintf+0x70>
    4c72:	93 fd       	sbrc	r25, 3
    4c74:	85 91       	lpm	r24, Z+
    4c76:	93 ff       	sbrs	r25, 3
    4c78:	81 91       	ld	r24, Z+
    4c7a:	1f 01       	movw	r2, r30
    4c7c:	85 32       	cpi	r24, 0x25	; 37
    4c7e:	39 f4       	brne	.+14     	; 0x4c8e <vfprintf+0x7e>
    4c80:	b7 01       	movw	r22, r14
    4c82:	90 e0       	ldi	r25, 0x00	; 0
    4c84:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    4c88:	56 01       	movw	r10, r12
    4c8a:	65 01       	movw	r12, r10
    4c8c:	e5 cf       	rjmp	.-54     	; 0x4c58 <vfprintf+0x48>
    4c8e:	10 e0       	ldi	r17, 0x00	; 0
    4c90:	51 2c       	mov	r5, r1
    4c92:	91 2c       	mov	r9, r1
    4c94:	ff e1       	ldi	r31, 0x1F	; 31
    4c96:	f9 15       	cp	r31, r9
    4c98:	d8 f0       	brcs	.+54     	; 0x4cd0 <vfprintf+0xc0>
    4c9a:	8b 32       	cpi	r24, 0x2B	; 43
    4c9c:	79 f0       	breq	.+30     	; 0x4cbc <vfprintf+0xac>
    4c9e:	38 f4       	brcc	.+14     	; 0x4cae <vfprintf+0x9e>
    4ca0:	80 32       	cpi	r24, 0x20	; 32
    4ca2:	79 f0       	breq	.+30     	; 0x4cc2 <vfprintf+0xb2>
    4ca4:	83 32       	cpi	r24, 0x23	; 35
    4ca6:	a1 f4       	brne	.+40     	; 0x4cd0 <vfprintf+0xc0>
    4ca8:	f9 2d       	mov	r31, r9
    4caa:	f0 61       	ori	r31, 0x10	; 16
    4cac:	2e c0       	rjmp	.+92     	; 0x4d0a <vfprintf+0xfa>
    4cae:	8d 32       	cpi	r24, 0x2D	; 45
    4cb0:	61 f0       	breq	.+24     	; 0x4cca <vfprintf+0xba>
    4cb2:	80 33       	cpi	r24, 0x30	; 48
    4cb4:	69 f4       	brne	.+26     	; 0x4cd0 <vfprintf+0xc0>
    4cb6:	29 2d       	mov	r18, r9
    4cb8:	21 60       	ori	r18, 0x01	; 1
    4cba:	2d c0       	rjmp	.+90     	; 0x4d16 <vfprintf+0x106>
    4cbc:	39 2d       	mov	r19, r9
    4cbe:	32 60       	ori	r19, 0x02	; 2
    4cc0:	93 2e       	mov	r9, r19
    4cc2:	89 2d       	mov	r24, r9
    4cc4:	84 60       	ori	r24, 0x04	; 4
    4cc6:	98 2e       	mov	r9, r24
    4cc8:	2a c0       	rjmp	.+84     	; 0x4d1e <vfprintf+0x10e>
    4cca:	e9 2d       	mov	r30, r9
    4ccc:	e8 60       	ori	r30, 0x08	; 8
    4cce:	15 c0       	rjmp	.+42     	; 0x4cfa <vfprintf+0xea>
    4cd0:	97 fc       	sbrc	r9, 7
    4cd2:	2d c0       	rjmp	.+90     	; 0x4d2e <vfprintf+0x11e>
    4cd4:	20 ed       	ldi	r18, 0xD0	; 208
    4cd6:	28 0f       	add	r18, r24
    4cd8:	2a 30       	cpi	r18, 0x0A	; 10
    4cda:	88 f4       	brcc	.+34     	; 0x4cfe <vfprintf+0xee>
    4cdc:	96 fe       	sbrs	r9, 6
    4cde:	06 c0       	rjmp	.+12     	; 0x4cec <vfprintf+0xdc>
    4ce0:	3a e0       	ldi	r19, 0x0A	; 10
    4ce2:	13 9f       	mul	r17, r19
    4ce4:	20 0d       	add	r18, r0
    4ce6:	11 24       	eor	r1, r1
    4ce8:	12 2f       	mov	r17, r18
    4cea:	19 c0       	rjmp	.+50     	; 0x4d1e <vfprintf+0x10e>
    4cec:	8a e0       	ldi	r24, 0x0A	; 10
    4cee:	58 9e       	mul	r5, r24
    4cf0:	20 0d       	add	r18, r0
    4cf2:	11 24       	eor	r1, r1
    4cf4:	52 2e       	mov	r5, r18
    4cf6:	e9 2d       	mov	r30, r9
    4cf8:	e0 62       	ori	r30, 0x20	; 32
    4cfa:	9e 2e       	mov	r9, r30
    4cfc:	10 c0       	rjmp	.+32     	; 0x4d1e <vfprintf+0x10e>
    4cfe:	8e 32       	cpi	r24, 0x2E	; 46
    4d00:	31 f4       	brne	.+12     	; 0x4d0e <vfprintf+0xfe>
    4d02:	96 fc       	sbrc	r9, 6
    4d04:	e5 c2       	rjmp	.+1482   	; 0x52d0 <vfprintf+0x6c0>
    4d06:	f9 2d       	mov	r31, r9
    4d08:	f0 64       	ori	r31, 0x40	; 64
    4d0a:	9f 2e       	mov	r9, r31
    4d0c:	08 c0       	rjmp	.+16     	; 0x4d1e <vfprintf+0x10e>
    4d0e:	8c 36       	cpi	r24, 0x6C	; 108
    4d10:	21 f4       	brne	.+8      	; 0x4d1a <vfprintf+0x10a>
    4d12:	29 2d       	mov	r18, r9
    4d14:	20 68       	ori	r18, 0x80	; 128
    4d16:	92 2e       	mov	r9, r18
    4d18:	02 c0       	rjmp	.+4      	; 0x4d1e <vfprintf+0x10e>
    4d1a:	88 36       	cpi	r24, 0x68	; 104
    4d1c:	41 f4       	brne	.+16     	; 0x4d2e <vfprintf+0x11e>
    4d1e:	f1 01       	movw	r30, r2
    4d20:	93 fd       	sbrc	r25, 3
    4d22:	85 91       	lpm	r24, Z+
    4d24:	93 ff       	sbrs	r25, 3
    4d26:	81 91       	ld	r24, Z+
    4d28:	1f 01       	movw	r2, r30
    4d2a:	81 11       	cpse	r24, r1
    4d2c:	b3 cf       	rjmp	.-154    	; 0x4c94 <vfprintf+0x84>
    4d2e:	9b eb       	ldi	r25, 0xBB	; 187
    4d30:	98 0f       	add	r25, r24
    4d32:	93 30       	cpi	r25, 0x03	; 3
    4d34:	20 f4       	brcc	.+8      	; 0x4d3e <vfprintf+0x12e>
    4d36:	99 2d       	mov	r25, r9
    4d38:	90 61       	ori	r25, 0x10	; 16
    4d3a:	80 5e       	subi	r24, 0xE0	; 224
    4d3c:	07 c0       	rjmp	.+14     	; 0x4d4c <vfprintf+0x13c>
    4d3e:	9b e9       	ldi	r25, 0x9B	; 155
    4d40:	98 0f       	add	r25, r24
    4d42:	93 30       	cpi	r25, 0x03	; 3
    4d44:	08 f0       	brcs	.+2      	; 0x4d48 <vfprintf+0x138>
    4d46:	66 c1       	rjmp	.+716    	; 0x5014 <vfprintf+0x404>
    4d48:	99 2d       	mov	r25, r9
    4d4a:	9f 7e       	andi	r25, 0xEF	; 239
    4d4c:	96 ff       	sbrs	r25, 6
    4d4e:	16 e0       	ldi	r17, 0x06	; 6
    4d50:	9f 73       	andi	r25, 0x3F	; 63
    4d52:	99 2e       	mov	r9, r25
    4d54:	85 36       	cpi	r24, 0x65	; 101
    4d56:	19 f4       	brne	.+6      	; 0x4d5e <vfprintf+0x14e>
    4d58:	90 64       	ori	r25, 0x40	; 64
    4d5a:	99 2e       	mov	r9, r25
    4d5c:	08 c0       	rjmp	.+16     	; 0x4d6e <vfprintf+0x15e>
    4d5e:	86 36       	cpi	r24, 0x66	; 102
    4d60:	21 f4       	brne	.+8      	; 0x4d6a <vfprintf+0x15a>
    4d62:	39 2f       	mov	r19, r25
    4d64:	30 68       	ori	r19, 0x80	; 128
    4d66:	93 2e       	mov	r9, r19
    4d68:	02 c0       	rjmp	.+4      	; 0x4d6e <vfprintf+0x15e>
    4d6a:	11 11       	cpse	r17, r1
    4d6c:	11 50       	subi	r17, 0x01	; 1
    4d6e:	97 fe       	sbrs	r9, 7
    4d70:	07 c0       	rjmp	.+14     	; 0x4d80 <vfprintf+0x170>
    4d72:	1c 33       	cpi	r17, 0x3C	; 60
    4d74:	50 f4       	brcc	.+20     	; 0x4d8a <vfprintf+0x17a>
    4d76:	44 24       	eor	r4, r4
    4d78:	43 94       	inc	r4
    4d7a:	41 0e       	add	r4, r17
    4d7c:	27 e0       	ldi	r18, 0x07	; 7
    4d7e:	0b c0       	rjmp	.+22     	; 0x4d96 <vfprintf+0x186>
    4d80:	18 30       	cpi	r17, 0x08	; 8
    4d82:	38 f0       	brcs	.+14     	; 0x4d92 <vfprintf+0x182>
    4d84:	27 e0       	ldi	r18, 0x07	; 7
    4d86:	17 e0       	ldi	r17, 0x07	; 7
    4d88:	05 c0       	rjmp	.+10     	; 0x4d94 <vfprintf+0x184>
    4d8a:	27 e0       	ldi	r18, 0x07	; 7
    4d8c:	9c e3       	ldi	r25, 0x3C	; 60
    4d8e:	49 2e       	mov	r4, r25
    4d90:	02 c0       	rjmp	.+4      	; 0x4d96 <vfprintf+0x186>
    4d92:	21 2f       	mov	r18, r17
    4d94:	41 2c       	mov	r4, r1
    4d96:	56 01       	movw	r10, r12
    4d98:	84 e0       	ldi	r24, 0x04	; 4
    4d9a:	a8 0e       	add	r10, r24
    4d9c:	b1 1c       	adc	r11, r1
    4d9e:	f6 01       	movw	r30, r12
    4da0:	60 81       	ld	r22, Z
    4da2:	71 81       	ldd	r23, Z+1	; 0x01
    4da4:	82 81       	ldd	r24, Z+2	; 0x02
    4da6:	93 81       	ldd	r25, Z+3	; 0x03
    4da8:	04 2d       	mov	r16, r4
    4daa:	a3 01       	movw	r20, r6
    4dac:	0e 94 ca 29 	call	0x5394	; 0x5394 <__ftoa_engine>
    4db0:	6c 01       	movw	r12, r24
    4db2:	f9 81       	ldd	r31, Y+1	; 0x01
    4db4:	fc 87       	std	Y+12, r31	; 0x0c
    4db6:	f0 ff       	sbrs	r31, 0
    4db8:	02 c0       	rjmp	.+4      	; 0x4dbe <vfprintf+0x1ae>
    4dba:	f3 ff       	sbrs	r31, 3
    4dbc:	06 c0       	rjmp	.+12     	; 0x4dca <vfprintf+0x1ba>
    4dbe:	91 fc       	sbrc	r9, 1
    4dc0:	06 c0       	rjmp	.+12     	; 0x4dce <vfprintf+0x1be>
    4dc2:	92 fe       	sbrs	r9, 2
    4dc4:	06 c0       	rjmp	.+12     	; 0x4dd2 <vfprintf+0x1c2>
    4dc6:	00 e2       	ldi	r16, 0x20	; 32
    4dc8:	05 c0       	rjmp	.+10     	; 0x4dd4 <vfprintf+0x1c4>
    4dca:	0d e2       	ldi	r16, 0x2D	; 45
    4dcc:	03 c0       	rjmp	.+6      	; 0x4dd4 <vfprintf+0x1c4>
    4dce:	0b e2       	ldi	r16, 0x2B	; 43
    4dd0:	01 c0       	rjmp	.+2      	; 0x4dd4 <vfprintf+0x1c4>
    4dd2:	00 e0       	ldi	r16, 0x00	; 0
    4dd4:	8c 85       	ldd	r24, Y+12	; 0x0c
    4dd6:	8c 70       	andi	r24, 0x0C	; 12
    4dd8:	19 f0       	breq	.+6      	; 0x4de0 <vfprintf+0x1d0>
    4dda:	01 11       	cpse	r16, r1
    4ddc:	5a c2       	rjmp	.+1204   	; 0x5292 <vfprintf+0x682>
    4dde:	9b c2       	rjmp	.+1334   	; 0x5316 <vfprintf+0x706>
    4de0:	97 fe       	sbrs	r9, 7
    4de2:	10 c0       	rjmp	.+32     	; 0x4e04 <vfprintf+0x1f4>
    4de4:	4c 0c       	add	r4, r12
    4de6:	fc 85       	ldd	r31, Y+12	; 0x0c
    4de8:	f4 ff       	sbrs	r31, 4
    4dea:	04 c0       	rjmp	.+8      	; 0x4df4 <vfprintf+0x1e4>
    4dec:	8a 81       	ldd	r24, Y+2	; 0x02
    4dee:	81 33       	cpi	r24, 0x31	; 49
    4df0:	09 f4       	brne	.+2      	; 0x4df4 <vfprintf+0x1e4>
    4df2:	4a 94       	dec	r4
    4df4:	14 14       	cp	r1, r4
    4df6:	74 f5       	brge	.+92     	; 0x4e54 <vfprintf+0x244>
    4df8:	28 e0       	ldi	r18, 0x08	; 8
    4dfa:	24 15       	cp	r18, r4
    4dfc:	78 f5       	brcc	.+94     	; 0x4e5c <vfprintf+0x24c>
    4dfe:	88 e0       	ldi	r24, 0x08	; 8
    4e00:	48 2e       	mov	r4, r24
    4e02:	2c c0       	rjmp	.+88     	; 0x4e5c <vfprintf+0x24c>
    4e04:	96 fc       	sbrc	r9, 6
    4e06:	2a c0       	rjmp	.+84     	; 0x4e5c <vfprintf+0x24c>
    4e08:	81 2f       	mov	r24, r17
    4e0a:	90 e0       	ldi	r25, 0x00	; 0
    4e0c:	8c 15       	cp	r24, r12
    4e0e:	9d 05       	cpc	r25, r13
    4e10:	9c f0       	brlt	.+38     	; 0x4e38 <vfprintf+0x228>
    4e12:	3c ef       	ldi	r19, 0xFC	; 252
    4e14:	c3 16       	cp	r12, r19
    4e16:	3f ef       	ldi	r19, 0xFF	; 255
    4e18:	d3 06       	cpc	r13, r19
    4e1a:	74 f0       	brlt	.+28     	; 0x4e38 <vfprintf+0x228>
    4e1c:	89 2d       	mov	r24, r9
    4e1e:	80 68       	ori	r24, 0x80	; 128
    4e20:	98 2e       	mov	r9, r24
    4e22:	0a c0       	rjmp	.+20     	; 0x4e38 <vfprintf+0x228>
    4e24:	e2 e0       	ldi	r30, 0x02	; 2
    4e26:	f0 e0       	ldi	r31, 0x00	; 0
    4e28:	ec 0f       	add	r30, r28
    4e2a:	fd 1f       	adc	r31, r29
    4e2c:	e1 0f       	add	r30, r17
    4e2e:	f1 1d       	adc	r31, r1
    4e30:	80 81       	ld	r24, Z
    4e32:	80 33       	cpi	r24, 0x30	; 48
    4e34:	19 f4       	brne	.+6      	; 0x4e3c <vfprintf+0x22c>
    4e36:	11 50       	subi	r17, 0x01	; 1
    4e38:	11 11       	cpse	r17, r1
    4e3a:	f4 cf       	rjmp	.-24     	; 0x4e24 <vfprintf+0x214>
    4e3c:	97 fe       	sbrs	r9, 7
    4e3e:	0e c0       	rjmp	.+28     	; 0x4e5c <vfprintf+0x24c>
    4e40:	44 24       	eor	r4, r4
    4e42:	43 94       	inc	r4
    4e44:	41 0e       	add	r4, r17
    4e46:	81 2f       	mov	r24, r17
    4e48:	90 e0       	ldi	r25, 0x00	; 0
    4e4a:	c8 16       	cp	r12, r24
    4e4c:	d9 06       	cpc	r13, r25
    4e4e:	2c f4       	brge	.+10     	; 0x4e5a <vfprintf+0x24a>
    4e50:	1c 19       	sub	r17, r12
    4e52:	04 c0       	rjmp	.+8      	; 0x4e5c <vfprintf+0x24c>
    4e54:	44 24       	eor	r4, r4
    4e56:	43 94       	inc	r4
    4e58:	01 c0       	rjmp	.+2      	; 0x4e5c <vfprintf+0x24c>
    4e5a:	10 e0       	ldi	r17, 0x00	; 0
    4e5c:	97 fe       	sbrs	r9, 7
    4e5e:	06 c0       	rjmp	.+12     	; 0x4e6c <vfprintf+0x25c>
    4e60:	1c 14       	cp	r1, r12
    4e62:	1d 04       	cpc	r1, r13
    4e64:	34 f4       	brge	.+12     	; 0x4e72 <vfprintf+0x262>
    4e66:	c6 01       	movw	r24, r12
    4e68:	01 96       	adiw	r24, 0x01	; 1
    4e6a:	05 c0       	rjmp	.+10     	; 0x4e76 <vfprintf+0x266>
    4e6c:	85 e0       	ldi	r24, 0x05	; 5
    4e6e:	90 e0       	ldi	r25, 0x00	; 0
    4e70:	02 c0       	rjmp	.+4      	; 0x4e76 <vfprintf+0x266>
    4e72:	81 e0       	ldi	r24, 0x01	; 1
    4e74:	90 e0       	ldi	r25, 0x00	; 0
    4e76:	01 11       	cpse	r16, r1
    4e78:	01 96       	adiw	r24, 0x01	; 1
    4e7a:	11 23       	and	r17, r17
    4e7c:	31 f0       	breq	.+12     	; 0x4e8a <vfprintf+0x27a>
    4e7e:	21 2f       	mov	r18, r17
    4e80:	30 e0       	ldi	r19, 0x00	; 0
    4e82:	2f 5f       	subi	r18, 0xFF	; 255
    4e84:	3f 4f       	sbci	r19, 0xFF	; 255
    4e86:	82 0f       	add	r24, r18
    4e88:	93 1f       	adc	r25, r19
    4e8a:	25 2d       	mov	r18, r5
    4e8c:	30 e0       	ldi	r19, 0x00	; 0
    4e8e:	82 17       	cp	r24, r18
    4e90:	93 07       	cpc	r25, r19
    4e92:	14 f4       	brge	.+4      	; 0x4e98 <vfprintf+0x288>
    4e94:	58 1a       	sub	r5, r24
    4e96:	01 c0       	rjmp	.+2      	; 0x4e9a <vfprintf+0x28a>
    4e98:	51 2c       	mov	r5, r1
    4e9a:	89 2d       	mov	r24, r9
    4e9c:	89 70       	andi	r24, 0x09	; 9
    4e9e:	49 f4       	brne	.+18     	; 0x4eb2 <vfprintf+0x2a2>
    4ea0:	55 20       	and	r5, r5
    4ea2:	39 f0       	breq	.+14     	; 0x4eb2 <vfprintf+0x2a2>
    4ea4:	b7 01       	movw	r22, r14
    4ea6:	80 e2       	ldi	r24, 0x20	; 32
    4ea8:	90 e0       	ldi	r25, 0x00	; 0
    4eaa:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    4eae:	5a 94       	dec	r5
    4eb0:	f7 cf       	rjmp	.-18     	; 0x4ea0 <vfprintf+0x290>
    4eb2:	00 23       	and	r16, r16
    4eb4:	29 f0       	breq	.+10     	; 0x4ec0 <vfprintf+0x2b0>
    4eb6:	b7 01       	movw	r22, r14
    4eb8:	80 2f       	mov	r24, r16
    4eba:	90 e0       	ldi	r25, 0x00	; 0
    4ebc:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    4ec0:	93 fc       	sbrc	r9, 3
    4ec2:	09 c0       	rjmp	.+18     	; 0x4ed6 <vfprintf+0x2c6>
    4ec4:	55 20       	and	r5, r5
    4ec6:	39 f0       	breq	.+14     	; 0x4ed6 <vfprintf+0x2c6>
    4ec8:	b7 01       	movw	r22, r14
    4eca:	80 e3       	ldi	r24, 0x30	; 48
    4ecc:	90 e0       	ldi	r25, 0x00	; 0
    4ece:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    4ed2:	5a 94       	dec	r5
    4ed4:	f7 cf       	rjmp	.-18     	; 0x4ec4 <vfprintf+0x2b4>
    4ed6:	97 fe       	sbrs	r9, 7
    4ed8:	4c c0       	rjmp	.+152    	; 0x4f72 <vfprintf+0x362>
    4eda:	46 01       	movw	r8, r12
    4edc:	d7 fe       	sbrs	r13, 7
    4ede:	02 c0       	rjmp	.+4      	; 0x4ee4 <vfprintf+0x2d4>
    4ee0:	81 2c       	mov	r8, r1
    4ee2:	91 2c       	mov	r9, r1
    4ee4:	c6 01       	movw	r24, r12
    4ee6:	88 19       	sub	r24, r8
    4ee8:	99 09       	sbc	r25, r9
    4eea:	f3 01       	movw	r30, r6
    4eec:	e8 0f       	add	r30, r24
    4eee:	f9 1f       	adc	r31, r25
    4ef0:	ed 87       	std	Y+13, r30	; 0x0d
    4ef2:	fe 87       	std	Y+14, r31	; 0x0e
    4ef4:	96 01       	movw	r18, r12
    4ef6:	24 19       	sub	r18, r4
    4ef8:	31 09       	sbc	r19, r1
    4efa:	2f 87       	std	Y+15, r18	; 0x0f
    4efc:	38 8b       	std	Y+16, r19	; 0x10
    4efe:	01 2f       	mov	r16, r17
    4f00:	10 e0       	ldi	r17, 0x00	; 0
    4f02:	11 95       	neg	r17
    4f04:	01 95       	neg	r16
    4f06:	11 09       	sbc	r17, r1
    4f08:	3f ef       	ldi	r19, 0xFF	; 255
    4f0a:	83 16       	cp	r8, r19
    4f0c:	93 06       	cpc	r9, r19
    4f0e:	29 f4       	brne	.+10     	; 0x4f1a <vfprintf+0x30a>
    4f10:	b7 01       	movw	r22, r14
    4f12:	8e e2       	ldi	r24, 0x2E	; 46
    4f14:	90 e0       	ldi	r25, 0x00	; 0
    4f16:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    4f1a:	c8 14       	cp	r12, r8
    4f1c:	d9 04       	cpc	r13, r9
    4f1e:	4c f0       	brlt	.+18     	; 0x4f32 <vfprintf+0x322>
    4f20:	8f 85       	ldd	r24, Y+15	; 0x0f
    4f22:	98 89       	ldd	r25, Y+16	; 0x10
    4f24:	88 15       	cp	r24, r8
    4f26:	99 05       	cpc	r25, r9
    4f28:	24 f4       	brge	.+8      	; 0x4f32 <vfprintf+0x322>
    4f2a:	ed 85       	ldd	r30, Y+13	; 0x0d
    4f2c:	fe 85       	ldd	r31, Y+14	; 0x0e
    4f2e:	81 81       	ldd	r24, Z+1	; 0x01
    4f30:	01 c0       	rjmp	.+2      	; 0x4f34 <vfprintf+0x324>
    4f32:	80 e3       	ldi	r24, 0x30	; 48
    4f34:	f1 e0       	ldi	r31, 0x01	; 1
    4f36:	8f 1a       	sub	r8, r31
    4f38:	91 08       	sbc	r9, r1
    4f3a:	2d 85       	ldd	r18, Y+13	; 0x0d
    4f3c:	3e 85       	ldd	r19, Y+14	; 0x0e
    4f3e:	2f 5f       	subi	r18, 0xFF	; 255
    4f40:	3f 4f       	sbci	r19, 0xFF	; 255
    4f42:	2d 87       	std	Y+13, r18	; 0x0d
    4f44:	3e 87       	std	Y+14, r19	; 0x0e
    4f46:	80 16       	cp	r8, r16
    4f48:	91 06       	cpc	r9, r17
    4f4a:	2c f0       	brlt	.+10     	; 0x4f56 <vfprintf+0x346>
    4f4c:	b7 01       	movw	r22, r14
    4f4e:	90 e0       	ldi	r25, 0x00	; 0
    4f50:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    4f54:	d9 cf       	rjmp	.-78     	; 0x4f08 <vfprintf+0x2f8>
    4f56:	c8 14       	cp	r12, r8
    4f58:	d9 04       	cpc	r13, r9
    4f5a:	41 f4       	brne	.+16     	; 0x4f6c <vfprintf+0x35c>
    4f5c:	9a 81       	ldd	r25, Y+2	; 0x02
    4f5e:	96 33       	cpi	r25, 0x36	; 54
    4f60:	20 f4       	brcc	.+8      	; 0x4f6a <vfprintf+0x35a>
    4f62:	95 33       	cpi	r25, 0x35	; 53
    4f64:	19 f4       	brne	.+6      	; 0x4f6c <vfprintf+0x35c>
    4f66:	3c 85       	ldd	r19, Y+12	; 0x0c
    4f68:	34 ff       	sbrs	r19, 4
    4f6a:	81 e3       	ldi	r24, 0x31	; 49
    4f6c:	b7 01       	movw	r22, r14
    4f6e:	90 e0       	ldi	r25, 0x00	; 0
    4f70:	4e c0       	rjmp	.+156    	; 0x500e <vfprintf+0x3fe>
    4f72:	8a 81       	ldd	r24, Y+2	; 0x02
    4f74:	81 33       	cpi	r24, 0x31	; 49
    4f76:	19 f0       	breq	.+6      	; 0x4f7e <vfprintf+0x36e>
    4f78:	9c 85       	ldd	r25, Y+12	; 0x0c
    4f7a:	9f 7e       	andi	r25, 0xEF	; 239
    4f7c:	9c 87       	std	Y+12, r25	; 0x0c
    4f7e:	b7 01       	movw	r22, r14
    4f80:	90 e0       	ldi	r25, 0x00	; 0
    4f82:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    4f86:	11 11       	cpse	r17, r1
    4f88:	05 c0       	rjmp	.+10     	; 0x4f94 <vfprintf+0x384>
    4f8a:	94 fc       	sbrc	r9, 4
    4f8c:	18 c0       	rjmp	.+48     	; 0x4fbe <vfprintf+0x3ae>
    4f8e:	85 e6       	ldi	r24, 0x65	; 101
    4f90:	90 e0       	ldi	r25, 0x00	; 0
    4f92:	17 c0       	rjmp	.+46     	; 0x4fc2 <vfprintf+0x3b2>
    4f94:	b7 01       	movw	r22, r14
    4f96:	8e e2       	ldi	r24, 0x2E	; 46
    4f98:	90 e0       	ldi	r25, 0x00	; 0
    4f9a:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    4f9e:	1e 5f       	subi	r17, 0xFE	; 254
    4fa0:	82 e0       	ldi	r24, 0x02	; 2
    4fa2:	01 e0       	ldi	r16, 0x01	; 1
    4fa4:	08 0f       	add	r16, r24
    4fa6:	f3 01       	movw	r30, r6
    4fa8:	e8 0f       	add	r30, r24
    4faa:	f1 1d       	adc	r31, r1
    4fac:	80 81       	ld	r24, Z
    4fae:	b7 01       	movw	r22, r14
    4fb0:	90 e0       	ldi	r25, 0x00	; 0
    4fb2:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    4fb6:	80 2f       	mov	r24, r16
    4fb8:	01 13       	cpse	r16, r17
    4fba:	f3 cf       	rjmp	.-26     	; 0x4fa2 <vfprintf+0x392>
    4fbc:	e6 cf       	rjmp	.-52     	; 0x4f8a <vfprintf+0x37a>
    4fbe:	85 e4       	ldi	r24, 0x45	; 69
    4fc0:	90 e0       	ldi	r25, 0x00	; 0
    4fc2:	b7 01       	movw	r22, r14
    4fc4:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    4fc8:	d7 fc       	sbrc	r13, 7
    4fca:	06 c0       	rjmp	.+12     	; 0x4fd8 <vfprintf+0x3c8>
    4fcc:	c1 14       	cp	r12, r1
    4fce:	d1 04       	cpc	r13, r1
    4fd0:	41 f4       	brne	.+16     	; 0x4fe2 <vfprintf+0x3d2>
    4fd2:	ec 85       	ldd	r30, Y+12	; 0x0c
    4fd4:	e4 ff       	sbrs	r30, 4
    4fd6:	05 c0       	rjmp	.+10     	; 0x4fe2 <vfprintf+0x3d2>
    4fd8:	d1 94       	neg	r13
    4fda:	c1 94       	neg	r12
    4fdc:	d1 08       	sbc	r13, r1
    4fde:	8d e2       	ldi	r24, 0x2D	; 45
    4fe0:	01 c0       	rjmp	.+2      	; 0x4fe4 <vfprintf+0x3d4>
    4fe2:	8b e2       	ldi	r24, 0x2B	; 43
    4fe4:	b7 01       	movw	r22, r14
    4fe6:	90 e0       	ldi	r25, 0x00	; 0
    4fe8:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    4fec:	80 e3       	ldi	r24, 0x30	; 48
    4fee:	2a e0       	ldi	r18, 0x0A	; 10
    4ff0:	c2 16       	cp	r12, r18
    4ff2:	d1 04       	cpc	r13, r1
    4ff4:	2c f0       	brlt	.+10     	; 0x5000 <vfprintf+0x3f0>
    4ff6:	8f 5f       	subi	r24, 0xFF	; 255
    4ff8:	fa e0       	ldi	r31, 0x0A	; 10
    4ffa:	cf 1a       	sub	r12, r31
    4ffc:	d1 08       	sbc	r13, r1
    4ffe:	f7 cf       	rjmp	.-18     	; 0x4fee <vfprintf+0x3de>
    5000:	b7 01       	movw	r22, r14
    5002:	90 e0       	ldi	r25, 0x00	; 0
    5004:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    5008:	b7 01       	movw	r22, r14
    500a:	c6 01       	movw	r24, r12
    500c:	c0 96       	adiw	r24, 0x30	; 48
    500e:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    5012:	54 c1       	rjmp	.+680    	; 0x52bc <vfprintf+0x6ac>
    5014:	83 36       	cpi	r24, 0x63	; 99
    5016:	31 f0       	breq	.+12     	; 0x5024 <vfprintf+0x414>
    5018:	83 37       	cpi	r24, 0x73	; 115
    501a:	79 f0       	breq	.+30     	; 0x503a <vfprintf+0x42a>
    501c:	83 35       	cpi	r24, 0x53	; 83
    501e:	09 f0       	breq	.+2      	; 0x5022 <vfprintf+0x412>
    5020:	56 c0       	rjmp	.+172    	; 0x50ce <vfprintf+0x4be>
    5022:	20 c0       	rjmp	.+64     	; 0x5064 <vfprintf+0x454>
    5024:	56 01       	movw	r10, r12
    5026:	32 e0       	ldi	r19, 0x02	; 2
    5028:	a3 0e       	add	r10, r19
    502a:	b1 1c       	adc	r11, r1
    502c:	f6 01       	movw	r30, r12
    502e:	80 81       	ld	r24, Z
    5030:	89 83       	std	Y+1, r24	; 0x01
    5032:	01 e0       	ldi	r16, 0x01	; 1
    5034:	10 e0       	ldi	r17, 0x00	; 0
    5036:	63 01       	movw	r12, r6
    5038:	12 c0       	rjmp	.+36     	; 0x505e <vfprintf+0x44e>
    503a:	56 01       	movw	r10, r12
    503c:	f2 e0       	ldi	r31, 0x02	; 2
    503e:	af 0e       	add	r10, r31
    5040:	b1 1c       	adc	r11, r1
    5042:	f6 01       	movw	r30, r12
    5044:	c0 80       	ld	r12, Z
    5046:	d1 80       	ldd	r13, Z+1	; 0x01
    5048:	96 fe       	sbrs	r9, 6
    504a:	03 c0       	rjmp	.+6      	; 0x5052 <vfprintf+0x442>
    504c:	61 2f       	mov	r22, r17
    504e:	70 e0       	ldi	r23, 0x00	; 0
    5050:	02 c0       	rjmp	.+4      	; 0x5056 <vfprintf+0x446>
    5052:	6f ef       	ldi	r22, 0xFF	; 255
    5054:	7f ef       	ldi	r23, 0xFF	; 255
    5056:	c6 01       	movw	r24, r12
    5058:	0e 94 bd 2a 	call	0x557a	; 0x557a <strnlen>
    505c:	8c 01       	movw	r16, r24
    505e:	f9 2d       	mov	r31, r9
    5060:	ff 77       	andi	r31, 0x7F	; 127
    5062:	14 c0       	rjmp	.+40     	; 0x508c <vfprintf+0x47c>
    5064:	56 01       	movw	r10, r12
    5066:	22 e0       	ldi	r18, 0x02	; 2
    5068:	a2 0e       	add	r10, r18
    506a:	b1 1c       	adc	r11, r1
    506c:	f6 01       	movw	r30, r12
    506e:	c0 80       	ld	r12, Z
    5070:	d1 80       	ldd	r13, Z+1	; 0x01
    5072:	96 fe       	sbrs	r9, 6
    5074:	03 c0       	rjmp	.+6      	; 0x507c <vfprintf+0x46c>
    5076:	61 2f       	mov	r22, r17
    5078:	70 e0       	ldi	r23, 0x00	; 0
    507a:	02 c0       	rjmp	.+4      	; 0x5080 <vfprintf+0x470>
    507c:	6f ef       	ldi	r22, 0xFF	; 255
    507e:	7f ef       	ldi	r23, 0xFF	; 255
    5080:	c6 01       	movw	r24, r12
    5082:	0e 94 a2 2a 	call	0x5544	; 0x5544 <strnlen_P>
    5086:	8c 01       	movw	r16, r24
    5088:	f9 2d       	mov	r31, r9
    508a:	f0 68       	ori	r31, 0x80	; 128
    508c:	9f 2e       	mov	r9, r31
    508e:	f3 fd       	sbrc	r31, 3
    5090:	1a c0       	rjmp	.+52     	; 0x50c6 <vfprintf+0x4b6>
    5092:	85 2d       	mov	r24, r5
    5094:	90 e0       	ldi	r25, 0x00	; 0
    5096:	08 17       	cp	r16, r24
    5098:	19 07       	cpc	r17, r25
    509a:	a8 f4       	brcc	.+42     	; 0x50c6 <vfprintf+0x4b6>
    509c:	b7 01       	movw	r22, r14
    509e:	80 e2       	ldi	r24, 0x20	; 32
    50a0:	90 e0       	ldi	r25, 0x00	; 0
    50a2:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    50a6:	5a 94       	dec	r5
    50a8:	f4 cf       	rjmp	.-24     	; 0x5092 <vfprintf+0x482>
    50aa:	f6 01       	movw	r30, r12
    50ac:	97 fc       	sbrc	r9, 7
    50ae:	85 91       	lpm	r24, Z+
    50b0:	97 fe       	sbrs	r9, 7
    50b2:	81 91       	ld	r24, Z+
    50b4:	6f 01       	movw	r12, r30
    50b6:	b7 01       	movw	r22, r14
    50b8:	90 e0       	ldi	r25, 0x00	; 0
    50ba:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    50be:	51 10       	cpse	r5, r1
    50c0:	5a 94       	dec	r5
    50c2:	01 50       	subi	r16, 0x01	; 1
    50c4:	11 09       	sbc	r17, r1
    50c6:	01 15       	cp	r16, r1
    50c8:	11 05       	cpc	r17, r1
    50ca:	79 f7       	brne	.-34     	; 0x50aa <vfprintf+0x49a>
    50cc:	f7 c0       	rjmp	.+494    	; 0x52bc <vfprintf+0x6ac>
    50ce:	84 36       	cpi	r24, 0x64	; 100
    50d0:	11 f0       	breq	.+4      	; 0x50d6 <vfprintf+0x4c6>
    50d2:	89 36       	cpi	r24, 0x69	; 105
    50d4:	61 f5       	brne	.+88     	; 0x512e <vfprintf+0x51e>
    50d6:	56 01       	movw	r10, r12
    50d8:	97 fe       	sbrs	r9, 7
    50da:	09 c0       	rjmp	.+18     	; 0x50ee <vfprintf+0x4de>
    50dc:	24 e0       	ldi	r18, 0x04	; 4
    50de:	a2 0e       	add	r10, r18
    50e0:	b1 1c       	adc	r11, r1
    50e2:	f6 01       	movw	r30, r12
    50e4:	60 81       	ld	r22, Z
    50e6:	71 81       	ldd	r23, Z+1	; 0x01
    50e8:	82 81       	ldd	r24, Z+2	; 0x02
    50ea:	93 81       	ldd	r25, Z+3	; 0x03
    50ec:	0a c0       	rjmp	.+20     	; 0x5102 <vfprintf+0x4f2>
    50ee:	f2 e0       	ldi	r31, 0x02	; 2
    50f0:	af 0e       	add	r10, r31
    50f2:	b1 1c       	adc	r11, r1
    50f4:	f6 01       	movw	r30, r12
    50f6:	60 81       	ld	r22, Z
    50f8:	71 81       	ldd	r23, Z+1	; 0x01
    50fa:	07 2e       	mov	r0, r23
    50fc:	00 0c       	add	r0, r0
    50fe:	88 0b       	sbc	r24, r24
    5100:	99 0b       	sbc	r25, r25
    5102:	f9 2d       	mov	r31, r9
    5104:	ff 76       	andi	r31, 0x6F	; 111
    5106:	9f 2e       	mov	r9, r31
    5108:	97 ff       	sbrs	r25, 7
    510a:	09 c0       	rjmp	.+18     	; 0x511e <vfprintf+0x50e>
    510c:	90 95       	com	r25
    510e:	80 95       	com	r24
    5110:	70 95       	com	r23
    5112:	61 95       	neg	r22
    5114:	7f 4f       	sbci	r23, 0xFF	; 255
    5116:	8f 4f       	sbci	r24, 0xFF	; 255
    5118:	9f 4f       	sbci	r25, 0xFF	; 255
    511a:	f0 68       	ori	r31, 0x80	; 128
    511c:	9f 2e       	mov	r9, r31
    511e:	2a e0       	ldi	r18, 0x0A	; 10
    5120:	30 e0       	ldi	r19, 0x00	; 0
    5122:	a3 01       	movw	r20, r6
    5124:	0e 94 47 2b 	call	0x568e	; 0x568e <__ultoa_invert>
    5128:	c8 2e       	mov	r12, r24
    512a:	c6 18       	sub	r12, r6
    512c:	3f c0       	rjmp	.+126    	; 0x51ac <vfprintf+0x59c>
    512e:	09 2d       	mov	r16, r9
    5130:	85 37       	cpi	r24, 0x75	; 117
    5132:	21 f4       	brne	.+8      	; 0x513c <vfprintf+0x52c>
    5134:	0f 7e       	andi	r16, 0xEF	; 239
    5136:	2a e0       	ldi	r18, 0x0A	; 10
    5138:	30 e0       	ldi	r19, 0x00	; 0
    513a:	1d c0       	rjmp	.+58     	; 0x5176 <vfprintf+0x566>
    513c:	09 7f       	andi	r16, 0xF9	; 249
    513e:	8f 36       	cpi	r24, 0x6F	; 111
    5140:	91 f0       	breq	.+36     	; 0x5166 <vfprintf+0x556>
    5142:	18 f4       	brcc	.+6      	; 0x514a <vfprintf+0x53a>
    5144:	88 35       	cpi	r24, 0x58	; 88
    5146:	59 f0       	breq	.+22     	; 0x515e <vfprintf+0x54e>
    5148:	c3 c0       	rjmp	.+390    	; 0x52d0 <vfprintf+0x6c0>
    514a:	80 37       	cpi	r24, 0x70	; 112
    514c:	19 f0       	breq	.+6      	; 0x5154 <vfprintf+0x544>
    514e:	88 37       	cpi	r24, 0x78	; 120
    5150:	11 f0       	breq	.+4      	; 0x5156 <vfprintf+0x546>
    5152:	be c0       	rjmp	.+380    	; 0x52d0 <vfprintf+0x6c0>
    5154:	00 61       	ori	r16, 0x10	; 16
    5156:	04 ff       	sbrs	r16, 4
    5158:	09 c0       	rjmp	.+18     	; 0x516c <vfprintf+0x55c>
    515a:	04 60       	ori	r16, 0x04	; 4
    515c:	07 c0       	rjmp	.+14     	; 0x516c <vfprintf+0x55c>
    515e:	94 fe       	sbrs	r9, 4
    5160:	08 c0       	rjmp	.+16     	; 0x5172 <vfprintf+0x562>
    5162:	06 60       	ori	r16, 0x06	; 6
    5164:	06 c0       	rjmp	.+12     	; 0x5172 <vfprintf+0x562>
    5166:	28 e0       	ldi	r18, 0x08	; 8
    5168:	30 e0       	ldi	r19, 0x00	; 0
    516a:	05 c0       	rjmp	.+10     	; 0x5176 <vfprintf+0x566>
    516c:	20 e1       	ldi	r18, 0x10	; 16
    516e:	30 e0       	ldi	r19, 0x00	; 0
    5170:	02 c0       	rjmp	.+4      	; 0x5176 <vfprintf+0x566>
    5172:	20 e1       	ldi	r18, 0x10	; 16
    5174:	32 e0       	ldi	r19, 0x02	; 2
    5176:	56 01       	movw	r10, r12
    5178:	07 ff       	sbrs	r16, 7
    517a:	09 c0       	rjmp	.+18     	; 0x518e <vfprintf+0x57e>
    517c:	84 e0       	ldi	r24, 0x04	; 4
    517e:	a8 0e       	add	r10, r24
    5180:	b1 1c       	adc	r11, r1
    5182:	f6 01       	movw	r30, r12
    5184:	60 81       	ld	r22, Z
    5186:	71 81       	ldd	r23, Z+1	; 0x01
    5188:	82 81       	ldd	r24, Z+2	; 0x02
    518a:	93 81       	ldd	r25, Z+3	; 0x03
    518c:	08 c0       	rjmp	.+16     	; 0x519e <vfprintf+0x58e>
    518e:	f2 e0       	ldi	r31, 0x02	; 2
    5190:	af 0e       	add	r10, r31
    5192:	b1 1c       	adc	r11, r1
    5194:	f6 01       	movw	r30, r12
    5196:	60 81       	ld	r22, Z
    5198:	71 81       	ldd	r23, Z+1	; 0x01
    519a:	80 e0       	ldi	r24, 0x00	; 0
    519c:	90 e0       	ldi	r25, 0x00	; 0
    519e:	a3 01       	movw	r20, r6
    51a0:	0e 94 47 2b 	call	0x568e	; 0x568e <__ultoa_invert>
    51a4:	c8 2e       	mov	r12, r24
    51a6:	c6 18       	sub	r12, r6
    51a8:	0f 77       	andi	r16, 0x7F	; 127
    51aa:	90 2e       	mov	r9, r16
    51ac:	96 fe       	sbrs	r9, 6
    51ae:	0b c0       	rjmp	.+22     	; 0x51c6 <vfprintf+0x5b6>
    51b0:	09 2d       	mov	r16, r9
    51b2:	0e 7f       	andi	r16, 0xFE	; 254
    51b4:	c1 16       	cp	r12, r17
    51b6:	50 f4       	brcc	.+20     	; 0x51cc <vfprintf+0x5bc>
    51b8:	94 fe       	sbrs	r9, 4
    51ba:	0a c0       	rjmp	.+20     	; 0x51d0 <vfprintf+0x5c0>
    51bc:	92 fc       	sbrc	r9, 2
    51be:	08 c0       	rjmp	.+16     	; 0x51d0 <vfprintf+0x5c0>
    51c0:	09 2d       	mov	r16, r9
    51c2:	0e 7e       	andi	r16, 0xEE	; 238
    51c4:	05 c0       	rjmp	.+10     	; 0x51d0 <vfprintf+0x5c0>
    51c6:	dc 2c       	mov	r13, r12
    51c8:	09 2d       	mov	r16, r9
    51ca:	03 c0       	rjmp	.+6      	; 0x51d2 <vfprintf+0x5c2>
    51cc:	dc 2c       	mov	r13, r12
    51ce:	01 c0       	rjmp	.+2      	; 0x51d2 <vfprintf+0x5c2>
    51d0:	d1 2e       	mov	r13, r17
    51d2:	04 ff       	sbrs	r16, 4
    51d4:	0d c0       	rjmp	.+26     	; 0x51f0 <vfprintf+0x5e0>
    51d6:	fe 01       	movw	r30, r28
    51d8:	ec 0d       	add	r30, r12
    51da:	f1 1d       	adc	r31, r1
    51dc:	80 81       	ld	r24, Z
    51de:	80 33       	cpi	r24, 0x30	; 48
    51e0:	11 f4       	brne	.+4      	; 0x51e6 <vfprintf+0x5d6>
    51e2:	09 7e       	andi	r16, 0xE9	; 233
    51e4:	09 c0       	rjmp	.+18     	; 0x51f8 <vfprintf+0x5e8>
    51e6:	02 ff       	sbrs	r16, 2
    51e8:	06 c0       	rjmp	.+12     	; 0x51f6 <vfprintf+0x5e6>
    51ea:	d3 94       	inc	r13
    51ec:	d3 94       	inc	r13
    51ee:	04 c0       	rjmp	.+8      	; 0x51f8 <vfprintf+0x5e8>
    51f0:	80 2f       	mov	r24, r16
    51f2:	86 78       	andi	r24, 0x86	; 134
    51f4:	09 f0       	breq	.+2      	; 0x51f8 <vfprintf+0x5e8>
    51f6:	d3 94       	inc	r13
    51f8:	03 fd       	sbrc	r16, 3
    51fa:	11 c0       	rjmp	.+34     	; 0x521e <vfprintf+0x60e>
    51fc:	00 ff       	sbrs	r16, 0
    51fe:	06 c0       	rjmp	.+12     	; 0x520c <vfprintf+0x5fc>
    5200:	1c 2d       	mov	r17, r12
    5202:	d5 14       	cp	r13, r5
    5204:	80 f4       	brcc	.+32     	; 0x5226 <vfprintf+0x616>
    5206:	15 0d       	add	r17, r5
    5208:	1d 19       	sub	r17, r13
    520a:	0d c0       	rjmp	.+26     	; 0x5226 <vfprintf+0x616>
    520c:	d5 14       	cp	r13, r5
    520e:	58 f4       	brcc	.+22     	; 0x5226 <vfprintf+0x616>
    5210:	b7 01       	movw	r22, r14
    5212:	80 e2       	ldi	r24, 0x20	; 32
    5214:	90 e0       	ldi	r25, 0x00	; 0
    5216:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    521a:	d3 94       	inc	r13
    521c:	f7 cf       	rjmp	.-18     	; 0x520c <vfprintf+0x5fc>
    521e:	d5 14       	cp	r13, r5
    5220:	10 f4       	brcc	.+4      	; 0x5226 <vfprintf+0x616>
    5222:	5d 18       	sub	r5, r13
    5224:	01 c0       	rjmp	.+2      	; 0x5228 <vfprintf+0x618>
    5226:	51 2c       	mov	r5, r1
    5228:	04 ff       	sbrs	r16, 4
    522a:	10 c0       	rjmp	.+32     	; 0x524c <vfprintf+0x63c>
    522c:	b7 01       	movw	r22, r14
    522e:	80 e3       	ldi	r24, 0x30	; 48
    5230:	90 e0       	ldi	r25, 0x00	; 0
    5232:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    5236:	02 ff       	sbrs	r16, 2
    5238:	17 c0       	rjmp	.+46     	; 0x5268 <vfprintf+0x658>
    523a:	01 fd       	sbrc	r16, 1
    523c:	03 c0       	rjmp	.+6      	; 0x5244 <vfprintf+0x634>
    523e:	88 e7       	ldi	r24, 0x78	; 120
    5240:	90 e0       	ldi	r25, 0x00	; 0
    5242:	02 c0       	rjmp	.+4      	; 0x5248 <vfprintf+0x638>
    5244:	88 e5       	ldi	r24, 0x58	; 88
    5246:	90 e0       	ldi	r25, 0x00	; 0
    5248:	b7 01       	movw	r22, r14
    524a:	0c c0       	rjmp	.+24     	; 0x5264 <vfprintf+0x654>
    524c:	80 2f       	mov	r24, r16
    524e:	86 78       	andi	r24, 0x86	; 134
    5250:	59 f0       	breq	.+22     	; 0x5268 <vfprintf+0x658>
    5252:	01 ff       	sbrs	r16, 1
    5254:	02 c0       	rjmp	.+4      	; 0x525a <vfprintf+0x64a>
    5256:	8b e2       	ldi	r24, 0x2B	; 43
    5258:	01 c0       	rjmp	.+2      	; 0x525c <vfprintf+0x64c>
    525a:	80 e2       	ldi	r24, 0x20	; 32
    525c:	07 fd       	sbrc	r16, 7
    525e:	8d e2       	ldi	r24, 0x2D	; 45
    5260:	b7 01       	movw	r22, r14
    5262:	90 e0       	ldi	r25, 0x00	; 0
    5264:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    5268:	c1 16       	cp	r12, r17
    526a:	38 f4       	brcc	.+14     	; 0x527a <vfprintf+0x66a>
    526c:	b7 01       	movw	r22, r14
    526e:	80 e3       	ldi	r24, 0x30	; 48
    5270:	90 e0       	ldi	r25, 0x00	; 0
    5272:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    5276:	11 50       	subi	r17, 0x01	; 1
    5278:	f7 cf       	rjmp	.-18     	; 0x5268 <vfprintf+0x658>
    527a:	ca 94       	dec	r12
    527c:	f3 01       	movw	r30, r6
    527e:	ec 0d       	add	r30, r12
    5280:	f1 1d       	adc	r31, r1
    5282:	80 81       	ld	r24, Z
    5284:	b7 01       	movw	r22, r14
    5286:	90 e0       	ldi	r25, 0x00	; 0
    5288:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    528c:	c1 10       	cpse	r12, r1
    528e:	f5 cf       	rjmp	.-22     	; 0x527a <vfprintf+0x66a>
    5290:	15 c0       	rjmp	.+42     	; 0x52bc <vfprintf+0x6ac>
    5292:	f4 e0       	ldi	r31, 0x04	; 4
    5294:	f5 15       	cp	r31, r5
    5296:	60 f5       	brcc	.+88     	; 0x52f0 <vfprintf+0x6e0>
    5298:	84 e0       	ldi	r24, 0x04	; 4
    529a:	58 1a       	sub	r5, r24
    529c:	93 fe       	sbrs	r9, 3
    529e:	1f c0       	rjmp	.+62     	; 0x52de <vfprintf+0x6ce>
    52a0:	01 11       	cpse	r16, r1
    52a2:	27 c0       	rjmp	.+78     	; 0x52f2 <vfprintf+0x6e2>
    52a4:	2c 85       	ldd	r18, Y+12	; 0x0c
    52a6:	23 ff       	sbrs	r18, 3
    52a8:	2a c0       	rjmp	.+84     	; 0x52fe <vfprintf+0x6ee>
    52aa:	08 e1       	ldi	r16, 0x18	; 24
    52ac:	12 e0       	ldi	r17, 0x02	; 2
    52ae:	39 2d       	mov	r19, r9
    52b0:	30 71       	andi	r19, 0x10	; 16
    52b2:	93 2e       	mov	r9, r19
    52b4:	f8 01       	movw	r30, r16
    52b6:	84 91       	lpm	r24, Z
    52b8:	81 11       	cpse	r24, r1
    52ba:	24 c0       	rjmp	.+72     	; 0x5304 <vfprintf+0x6f4>
    52bc:	55 20       	and	r5, r5
    52be:	09 f4       	brne	.+2      	; 0x52c2 <vfprintf+0x6b2>
    52c0:	e4 cc       	rjmp	.-1592   	; 0x4c8a <vfprintf+0x7a>
    52c2:	b7 01       	movw	r22, r14
    52c4:	80 e2       	ldi	r24, 0x20	; 32
    52c6:	90 e0       	ldi	r25, 0x00	; 0
    52c8:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    52cc:	5a 94       	dec	r5
    52ce:	f6 cf       	rjmp	.-20     	; 0x52bc <vfprintf+0x6ac>
    52d0:	f7 01       	movw	r30, r14
    52d2:	86 81       	ldd	r24, Z+6	; 0x06
    52d4:	97 81       	ldd	r25, Z+7	; 0x07
    52d6:	26 c0       	rjmp	.+76     	; 0x5324 <vfprintf+0x714>
    52d8:	8f ef       	ldi	r24, 0xFF	; 255
    52da:	9f ef       	ldi	r25, 0xFF	; 255
    52dc:	23 c0       	rjmp	.+70     	; 0x5324 <vfprintf+0x714>
    52de:	b7 01       	movw	r22, r14
    52e0:	80 e2       	ldi	r24, 0x20	; 32
    52e2:	90 e0       	ldi	r25, 0x00	; 0
    52e4:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    52e8:	5a 94       	dec	r5
    52ea:	51 10       	cpse	r5, r1
    52ec:	f8 cf       	rjmp	.-16     	; 0x52de <vfprintf+0x6ce>
    52ee:	d8 cf       	rjmp	.-80     	; 0x52a0 <vfprintf+0x690>
    52f0:	51 2c       	mov	r5, r1
    52f2:	b7 01       	movw	r22, r14
    52f4:	80 2f       	mov	r24, r16
    52f6:	90 e0       	ldi	r25, 0x00	; 0
    52f8:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    52fc:	d3 cf       	rjmp	.-90     	; 0x52a4 <vfprintf+0x694>
    52fe:	0c e1       	ldi	r16, 0x1C	; 28
    5300:	12 e0       	ldi	r17, 0x02	; 2
    5302:	d5 cf       	rjmp	.-86     	; 0x52ae <vfprintf+0x69e>
    5304:	91 10       	cpse	r9, r1
    5306:	80 52       	subi	r24, 0x20	; 32
    5308:	b7 01       	movw	r22, r14
    530a:	90 e0       	ldi	r25, 0x00	; 0
    530c:	0e 94 c8 2a 	call	0x5590	; 0x5590 <fputc>
    5310:	0f 5f       	subi	r16, 0xFF	; 255
    5312:	1f 4f       	sbci	r17, 0xFF	; 255
    5314:	cf cf       	rjmp	.-98     	; 0x52b4 <vfprintf+0x6a4>
    5316:	23 e0       	ldi	r18, 0x03	; 3
    5318:	25 15       	cp	r18, r5
    531a:	10 f4       	brcc	.+4      	; 0x5320 <vfprintf+0x710>
    531c:	83 e0       	ldi	r24, 0x03	; 3
    531e:	bd cf       	rjmp	.-134    	; 0x529a <vfprintf+0x68a>
    5320:	51 2c       	mov	r5, r1
    5322:	c0 cf       	rjmp	.-128    	; 0x52a4 <vfprintf+0x694>
    5324:	60 96       	adiw	r28, 0x10	; 16
    5326:	cd bf       	out	0x3d, r28	; 61
    5328:	de bf       	out	0x3e, r29	; 62
    532a:	df 91       	pop	r29
    532c:	cf 91       	pop	r28
    532e:	1f 91       	pop	r17
    5330:	0f 91       	pop	r16
    5332:	ff 90       	pop	r15
    5334:	ef 90       	pop	r14
    5336:	df 90       	pop	r13
    5338:	cf 90       	pop	r12
    533a:	bf 90       	pop	r11
    533c:	af 90       	pop	r10
    533e:	9f 90       	pop	r9
    5340:	8f 90       	pop	r8
    5342:	7f 90       	pop	r7
    5344:	6f 90       	pop	r6
    5346:	5f 90       	pop	r5
    5348:	4f 90       	pop	r4
    534a:	3f 90       	pop	r3
    534c:	2f 90       	pop	r2
    534e:	08 95       	ret

00005350 <__udivmodsi4>:
    5350:	a1 e2       	ldi	r26, 0x21	; 33
    5352:	1a 2e       	mov	r1, r26
    5354:	aa 1b       	sub	r26, r26
    5356:	bb 1b       	sub	r27, r27
    5358:	fd 01       	movw	r30, r26
    535a:	0d c0       	rjmp	.+26     	; 0x5376 <__udivmodsi4_ep>

0000535c <__udivmodsi4_loop>:
    535c:	aa 1f       	adc	r26, r26
    535e:	bb 1f       	adc	r27, r27
    5360:	ee 1f       	adc	r30, r30
    5362:	ff 1f       	adc	r31, r31
    5364:	a2 17       	cp	r26, r18
    5366:	b3 07       	cpc	r27, r19
    5368:	e4 07       	cpc	r30, r20
    536a:	f5 07       	cpc	r31, r21
    536c:	20 f0       	brcs	.+8      	; 0x5376 <__udivmodsi4_ep>
    536e:	a2 1b       	sub	r26, r18
    5370:	b3 0b       	sbc	r27, r19
    5372:	e4 0b       	sbc	r30, r20
    5374:	f5 0b       	sbc	r31, r21

00005376 <__udivmodsi4_ep>:
    5376:	66 1f       	adc	r22, r22
    5378:	77 1f       	adc	r23, r23
    537a:	88 1f       	adc	r24, r24
    537c:	99 1f       	adc	r25, r25
    537e:	1a 94       	dec	r1
    5380:	69 f7       	brne	.-38     	; 0x535c <__udivmodsi4_loop>
    5382:	60 95       	com	r22
    5384:	70 95       	com	r23
    5386:	80 95       	com	r24
    5388:	90 95       	com	r25
    538a:	9b 01       	movw	r18, r22
    538c:	ac 01       	movw	r20, r24
    538e:	bd 01       	movw	r22, r26
    5390:	cf 01       	movw	r24, r30
    5392:	08 95       	ret

00005394 <__ftoa_engine>:
    5394:	28 30       	cpi	r18, 0x08	; 8
    5396:	08 f0       	brcs	.+2      	; 0x539a <__ftoa_engine+0x6>
    5398:	27 e0       	ldi	r18, 0x07	; 7
    539a:	33 27       	eor	r19, r19
    539c:	da 01       	movw	r26, r20
    539e:	99 0f       	add	r25, r25
    53a0:	31 1d       	adc	r19, r1
    53a2:	87 fd       	sbrc	r24, 7
    53a4:	91 60       	ori	r25, 0x01	; 1
    53a6:	00 96       	adiw	r24, 0x00	; 0
    53a8:	61 05       	cpc	r22, r1
    53aa:	71 05       	cpc	r23, r1
    53ac:	39 f4       	brne	.+14     	; 0x53bc <__ftoa_engine+0x28>
    53ae:	32 60       	ori	r19, 0x02	; 2
    53b0:	2e 5f       	subi	r18, 0xFE	; 254
    53b2:	3d 93       	st	X+, r19
    53b4:	30 e3       	ldi	r19, 0x30	; 48
    53b6:	2a 95       	dec	r18
    53b8:	e1 f7       	brne	.-8      	; 0x53b2 <__ftoa_engine+0x1e>
    53ba:	08 95       	ret
    53bc:	9f 3f       	cpi	r25, 0xFF	; 255
    53be:	30 f0       	brcs	.+12     	; 0x53cc <__ftoa_engine+0x38>
    53c0:	80 38       	cpi	r24, 0x80	; 128
    53c2:	71 05       	cpc	r23, r1
    53c4:	61 05       	cpc	r22, r1
    53c6:	09 f0       	breq	.+2      	; 0x53ca <__ftoa_engine+0x36>
    53c8:	3c 5f       	subi	r19, 0xFC	; 252
    53ca:	3c 5f       	subi	r19, 0xFC	; 252
    53cc:	3d 93       	st	X+, r19
    53ce:	91 30       	cpi	r25, 0x01	; 1
    53d0:	08 f0       	brcs	.+2      	; 0x53d4 <__ftoa_engine+0x40>
    53d2:	80 68       	ori	r24, 0x80	; 128
    53d4:	91 1d       	adc	r25, r1
    53d6:	df 93       	push	r29
    53d8:	cf 93       	push	r28
    53da:	1f 93       	push	r17
    53dc:	0f 93       	push	r16
    53de:	ff 92       	push	r15
    53e0:	ef 92       	push	r14
    53e2:	19 2f       	mov	r17, r25
    53e4:	98 7f       	andi	r25, 0xF8	; 248
    53e6:	96 95       	lsr	r25
    53e8:	e9 2f       	mov	r30, r25
    53ea:	96 95       	lsr	r25
    53ec:	96 95       	lsr	r25
    53ee:	e9 0f       	add	r30, r25
    53f0:	ff 27       	eor	r31, r31
    53f2:	e6 58       	subi	r30, 0x86	; 134
    53f4:	fd 4f       	sbci	r31, 0xFD	; 253
    53f6:	99 27       	eor	r25, r25
    53f8:	33 27       	eor	r19, r19
    53fa:	ee 24       	eor	r14, r14
    53fc:	ff 24       	eor	r15, r15
    53fe:	a7 01       	movw	r20, r14
    5400:	e7 01       	movw	r28, r14
    5402:	05 90       	lpm	r0, Z+
    5404:	08 94       	sec
    5406:	07 94       	ror	r0
    5408:	28 f4       	brcc	.+10     	; 0x5414 <__ftoa_engine+0x80>
    540a:	36 0f       	add	r19, r22
    540c:	e7 1e       	adc	r14, r23
    540e:	f8 1e       	adc	r15, r24
    5410:	49 1f       	adc	r20, r25
    5412:	51 1d       	adc	r21, r1
    5414:	66 0f       	add	r22, r22
    5416:	77 1f       	adc	r23, r23
    5418:	88 1f       	adc	r24, r24
    541a:	99 1f       	adc	r25, r25
    541c:	06 94       	lsr	r0
    541e:	a1 f7       	brne	.-24     	; 0x5408 <__ftoa_engine+0x74>
    5420:	05 90       	lpm	r0, Z+
    5422:	07 94       	ror	r0
    5424:	28 f4       	brcc	.+10     	; 0x5430 <__ftoa_engine+0x9c>
    5426:	e7 0e       	add	r14, r23
    5428:	f8 1e       	adc	r15, r24
    542a:	49 1f       	adc	r20, r25
    542c:	56 1f       	adc	r21, r22
    542e:	c1 1d       	adc	r28, r1
    5430:	77 0f       	add	r23, r23
    5432:	88 1f       	adc	r24, r24
    5434:	99 1f       	adc	r25, r25
    5436:	66 1f       	adc	r22, r22
    5438:	06 94       	lsr	r0
    543a:	a1 f7       	brne	.-24     	; 0x5424 <__ftoa_engine+0x90>
    543c:	05 90       	lpm	r0, Z+
    543e:	07 94       	ror	r0
    5440:	28 f4       	brcc	.+10     	; 0x544c <__ftoa_engine+0xb8>
    5442:	f8 0e       	add	r15, r24
    5444:	49 1f       	adc	r20, r25
    5446:	56 1f       	adc	r21, r22
    5448:	c7 1f       	adc	r28, r23
    544a:	d1 1d       	adc	r29, r1
    544c:	88 0f       	add	r24, r24
    544e:	99 1f       	adc	r25, r25
    5450:	66 1f       	adc	r22, r22
    5452:	77 1f       	adc	r23, r23
    5454:	06 94       	lsr	r0
    5456:	a1 f7       	brne	.-24     	; 0x5440 <__ftoa_engine+0xac>
    5458:	05 90       	lpm	r0, Z+
    545a:	07 94       	ror	r0
    545c:	20 f4       	brcc	.+8      	; 0x5466 <__ftoa_engine+0xd2>
    545e:	49 0f       	add	r20, r25
    5460:	56 1f       	adc	r21, r22
    5462:	c7 1f       	adc	r28, r23
    5464:	d8 1f       	adc	r29, r24
    5466:	99 0f       	add	r25, r25
    5468:	66 1f       	adc	r22, r22
    546a:	77 1f       	adc	r23, r23
    546c:	88 1f       	adc	r24, r24
    546e:	06 94       	lsr	r0
    5470:	a9 f7       	brne	.-22     	; 0x545c <__ftoa_engine+0xc8>
    5472:	84 91       	lpm	r24, Z
    5474:	10 95       	com	r17
    5476:	17 70       	andi	r17, 0x07	; 7
    5478:	41 f0       	breq	.+16     	; 0x548a <__ftoa_engine+0xf6>
    547a:	d6 95       	lsr	r29
    547c:	c7 95       	ror	r28
    547e:	57 95       	ror	r21
    5480:	47 95       	ror	r20
    5482:	f7 94       	ror	r15
    5484:	e7 94       	ror	r14
    5486:	1a 95       	dec	r17
    5488:	c1 f7       	brne	.-16     	; 0x547a <__ftoa_engine+0xe6>
    548a:	e0 e2       	ldi	r30, 0x20	; 32
    548c:	f2 e0       	ldi	r31, 0x02	; 2
    548e:	68 94       	set
    5490:	15 90       	lpm	r1, Z+
    5492:	15 91       	lpm	r17, Z+
    5494:	35 91       	lpm	r19, Z+
    5496:	65 91       	lpm	r22, Z+
    5498:	95 91       	lpm	r25, Z+
    549a:	05 90       	lpm	r0, Z+
    549c:	7f e2       	ldi	r23, 0x2F	; 47
    549e:	73 95       	inc	r23
    54a0:	e1 18       	sub	r14, r1
    54a2:	f1 0a       	sbc	r15, r17
    54a4:	43 0b       	sbc	r20, r19
    54a6:	56 0b       	sbc	r21, r22
    54a8:	c9 0b       	sbc	r28, r25
    54aa:	d0 09       	sbc	r29, r0
    54ac:	c0 f7       	brcc	.-16     	; 0x549e <__ftoa_engine+0x10a>
    54ae:	e1 0c       	add	r14, r1
    54b0:	f1 1e       	adc	r15, r17
    54b2:	43 1f       	adc	r20, r19
    54b4:	56 1f       	adc	r21, r22
    54b6:	c9 1f       	adc	r28, r25
    54b8:	d0 1d       	adc	r29, r0
    54ba:	7e f4       	brtc	.+30     	; 0x54da <__ftoa_engine+0x146>
    54bc:	70 33       	cpi	r23, 0x30	; 48
    54be:	11 f4       	brne	.+4      	; 0x54c4 <__ftoa_engine+0x130>
    54c0:	8a 95       	dec	r24
    54c2:	e6 cf       	rjmp	.-52     	; 0x5490 <__ftoa_engine+0xfc>
    54c4:	e8 94       	clt
    54c6:	01 50       	subi	r16, 0x01	; 1
    54c8:	30 f0       	brcs	.+12     	; 0x54d6 <__ftoa_engine+0x142>
    54ca:	08 0f       	add	r16, r24
    54cc:	0a f4       	brpl	.+2      	; 0x54d0 <__ftoa_engine+0x13c>
    54ce:	00 27       	eor	r16, r16
    54d0:	02 17       	cp	r16, r18
    54d2:	08 f4       	brcc	.+2      	; 0x54d6 <__ftoa_engine+0x142>
    54d4:	20 2f       	mov	r18, r16
    54d6:	23 95       	inc	r18
    54d8:	02 2f       	mov	r16, r18
    54da:	7a 33       	cpi	r23, 0x3A	; 58
    54dc:	28 f0       	brcs	.+10     	; 0x54e8 <__ftoa_engine+0x154>
    54de:	79 e3       	ldi	r23, 0x39	; 57
    54e0:	7d 93       	st	X+, r23
    54e2:	2a 95       	dec	r18
    54e4:	e9 f7       	brne	.-6      	; 0x54e0 <__ftoa_engine+0x14c>
    54e6:	10 c0       	rjmp	.+32     	; 0x5508 <__ftoa_engine+0x174>
    54e8:	7d 93       	st	X+, r23
    54ea:	2a 95       	dec	r18
    54ec:	89 f6       	brne	.-94     	; 0x5490 <__ftoa_engine+0xfc>
    54ee:	06 94       	lsr	r0
    54f0:	97 95       	ror	r25
    54f2:	67 95       	ror	r22
    54f4:	37 95       	ror	r19
    54f6:	17 95       	ror	r17
    54f8:	17 94       	ror	r1
    54fa:	e1 18       	sub	r14, r1
    54fc:	f1 0a       	sbc	r15, r17
    54fe:	43 0b       	sbc	r20, r19
    5500:	56 0b       	sbc	r21, r22
    5502:	c9 0b       	sbc	r28, r25
    5504:	d0 09       	sbc	r29, r0
    5506:	98 f0       	brcs	.+38     	; 0x552e <__ftoa_engine+0x19a>
    5508:	23 95       	inc	r18
    550a:	7e 91       	ld	r23, -X
    550c:	73 95       	inc	r23
    550e:	7a 33       	cpi	r23, 0x3A	; 58
    5510:	08 f0       	brcs	.+2      	; 0x5514 <__ftoa_engine+0x180>
    5512:	70 e3       	ldi	r23, 0x30	; 48
    5514:	7c 93       	st	X, r23
    5516:	20 13       	cpse	r18, r16
    5518:	b8 f7       	brcc	.-18     	; 0x5508 <__ftoa_engine+0x174>
    551a:	7e 91       	ld	r23, -X
    551c:	70 61       	ori	r23, 0x10	; 16
    551e:	7d 93       	st	X+, r23
    5520:	30 f0       	brcs	.+12     	; 0x552e <__ftoa_engine+0x19a>
    5522:	83 95       	inc	r24
    5524:	71 e3       	ldi	r23, 0x31	; 49
    5526:	7d 93       	st	X+, r23
    5528:	70 e3       	ldi	r23, 0x30	; 48
    552a:	2a 95       	dec	r18
    552c:	e1 f7       	brne	.-8      	; 0x5526 <__ftoa_engine+0x192>
    552e:	11 24       	eor	r1, r1
    5530:	ef 90       	pop	r14
    5532:	ff 90       	pop	r15
    5534:	0f 91       	pop	r16
    5536:	1f 91       	pop	r17
    5538:	cf 91       	pop	r28
    553a:	df 91       	pop	r29
    553c:	99 27       	eor	r25, r25
    553e:	87 fd       	sbrc	r24, 7
    5540:	90 95       	com	r25
    5542:	08 95       	ret

00005544 <strnlen_P>:
    5544:	fc 01       	movw	r30, r24
    5546:	05 90       	lpm	r0, Z+
    5548:	61 50       	subi	r22, 0x01	; 1
    554a:	70 40       	sbci	r23, 0x00	; 0
    554c:	01 10       	cpse	r0, r1
    554e:	d8 f7       	brcc	.-10     	; 0x5546 <strnlen_P+0x2>
    5550:	80 95       	com	r24
    5552:	90 95       	com	r25
    5554:	8e 0f       	add	r24, r30
    5556:	9f 1f       	adc	r25, r31
    5558:	08 95       	ret

0000555a <memcpy>:
    555a:	fb 01       	movw	r30, r22
    555c:	dc 01       	movw	r26, r24
    555e:	02 c0       	rjmp	.+4      	; 0x5564 <memcpy+0xa>
    5560:	01 90       	ld	r0, Z+
    5562:	0d 92       	st	X+, r0
    5564:	41 50       	subi	r20, 0x01	; 1
    5566:	50 40       	sbci	r21, 0x00	; 0
    5568:	d8 f7       	brcc	.-10     	; 0x5560 <memcpy+0x6>
    556a:	08 95       	ret

0000556c <memset>:
    556c:	dc 01       	movw	r26, r24
    556e:	01 c0       	rjmp	.+2      	; 0x5572 <memset+0x6>
    5570:	6d 93       	st	X+, r22
    5572:	41 50       	subi	r20, 0x01	; 1
    5574:	50 40       	sbci	r21, 0x00	; 0
    5576:	e0 f7       	brcc	.-8      	; 0x5570 <memset+0x4>
    5578:	08 95       	ret

0000557a <strnlen>:
    557a:	fc 01       	movw	r30, r24
    557c:	61 50       	subi	r22, 0x01	; 1
    557e:	70 40       	sbci	r23, 0x00	; 0
    5580:	01 90       	ld	r0, Z+
    5582:	01 10       	cpse	r0, r1
    5584:	d8 f7       	brcc	.-10     	; 0x557c <strnlen+0x2>
    5586:	80 95       	com	r24
    5588:	90 95       	com	r25
    558a:	8e 0f       	add	r24, r30
    558c:	9f 1f       	adc	r25, r31
    558e:	08 95       	ret

00005590 <fputc>:
    5590:	0f 93       	push	r16
    5592:	1f 93       	push	r17
    5594:	cf 93       	push	r28
    5596:	df 93       	push	r29
    5598:	fb 01       	movw	r30, r22
    559a:	23 81       	ldd	r18, Z+3	; 0x03
    559c:	21 fd       	sbrc	r18, 1
    559e:	03 c0       	rjmp	.+6      	; 0x55a6 <fputc+0x16>
    55a0:	8f ef       	ldi	r24, 0xFF	; 255
    55a2:	9f ef       	ldi	r25, 0xFF	; 255
    55a4:	2c c0       	rjmp	.+88     	; 0x55fe <fputc+0x6e>
    55a6:	22 ff       	sbrs	r18, 2
    55a8:	16 c0       	rjmp	.+44     	; 0x55d6 <fputc+0x46>
    55aa:	46 81       	ldd	r20, Z+6	; 0x06
    55ac:	57 81       	ldd	r21, Z+7	; 0x07
    55ae:	24 81       	ldd	r18, Z+4	; 0x04
    55b0:	35 81       	ldd	r19, Z+5	; 0x05
    55b2:	42 17       	cp	r20, r18
    55b4:	53 07       	cpc	r21, r19
    55b6:	44 f4       	brge	.+16     	; 0x55c8 <fputc+0x38>
    55b8:	a0 81       	ld	r26, Z
    55ba:	b1 81       	ldd	r27, Z+1	; 0x01
    55bc:	9d 01       	movw	r18, r26
    55be:	2f 5f       	subi	r18, 0xFF	; 255
    55c0:	3f 4f       	sbci	r19, 0xFF	; 255
    55c2:	20 83       	st	Z, r18
    55c4:	31 83       	std	Z+1, r19	; 0x01
    55c6:	8c 93       	st	X, r24
    55c8:	26 81       	ldd	r18, Z+6	; 0x06
    55ca:	37 81       	ldd	r19, Z+7	; 0x07
    55cc:	2f 5f       	subi	r18, 0xFF	; 255
    55ce:	3f 4f       	sbci	r19, 0xFF	; 255
    55d0:	26 83       	std	Z+6, r18	; 0x06
    55d2:	37 83       	std	Z+7, r19	; 0x07
    55d4:	14 c0       	rjmp	.+40     	; 0x55fe <fputc+0x6e>
    55d6:	8b 01       	movw	r16, r22
    55d8:	ec 01       	movw	r28, r24
    55da:	fb 01       	movw	r30, r22
    55dc:	00 84       	ldd	r0, Z+8	; 0x08
    55de:	f1 85       	ldd	r31, Z+9	; 0x09
    55e0:	e0 2d       	mov	r30, r0
    55e2:	19 95       	eicall
    55e4:	89 2b       	or	r24, r25
    55e6:	e1 f6       	brne	.-72     	; 0x55a0 <fputc+0x10>
    55e8:	d8 01       	movw	r26, r16
    55ea:	16 96       	adiw	r26, 0x06	; 6
    55ec:	8d 91       	ld	r24, X+
    55ee:	9c 91       	ld	r25, X
    55f0:	17 97       	sbiw	r26, 0x07	; 7
    55f2:	01 96       	adiw	r24, 0x01	; 1
    55f4:	16 96       	adiw	r26, 0x06	; 6
    55f6:	8d 93       	st	X+, r24
    55f8:	9c 93       	st	X, r25
    55fa:	17 97       	sbiw	r26, 0x07	; 7
    55fc:	ce 01       	movw	r24, r28
    55fe:	df 91       	pop	r29
    5600:	cf 91       	pop	r28
    5602:	1f 91       	pop	r17
    5604:	0f 91       	pop	r16
    5606:	08 95       	ret

00005608 <printf>:
    5608:	cf 93       	push	r28
    560a:	df 93       	push	r29
    560c:	cd b7       	in	r28, 0x3d	; 61
    560e:	de b7       	in	r29, 0x3e	; 62
    5610:	ae 01       	movw	r20, r28
    5612:	4a 5f       	subi	r20, 0xFA	; 250
    5614:	5f 4f       	sbci	r21, 0xFF	; 255
    5616:	fa 01       	movw	r30, r20
    5618:	61 91       	ld	r22, Z+
    561a:	71 91       	ld	r23, Z+
    561c:	af 01       	movw	r20, r30
    561e:	80 91 b4 68 	lds	r24, 0x68B4	; 0x8068b4 <__iob+0x2>
    5622:	90 91 b5 68 	lds	r25, 0x68B5	; 0x8068b5 <__iob+0x3>
    5626:	0e 94 08 26 	call	0x4c10	; 0x4c10 <vfprintf>
    562a:	df 91       	pop	r29
    562c:	cf 91       	pop	r28
    562e:	08 95       	ret

00005630 <putchar>:
    5630:	60 91 b4 68 	lds	r22, 0x68B4	; 0x8068b4 <__iob+0x2>
    5634:	70 91 b5 68 	lds	r23, 0x68B5	; 0x8068b5 <__iob+0x3>
    5638:	0c 94 c8 2a 	jmp	0x5590	; 0x5590 <fputc>

0000563c <sprintf>:
    563c:	0f 93       	push	r16
    563e:	1f 93       	push	r17
    5640:	cf 93       	push	r28
    5642:	df 93       	push	r29
    5644:	cd b7       	in	r28, 0x3d	; 61
    5646:	de b7       	in	r29, 0x3e	; 62
    5648:	2e 97       	sbiw	r28, 0x0e	; 14
    564a:	cd bf       	out	0x3d, r28	; 61
    564c:	de bf       	out	0x3e, r29	; 62
    564e:	0e 89       	ldd	r16, Y+22	; 0x16
    5650:	1f 89       	ldd	r17, Y+23	; 0x17
    5652:	86 e0       	ldi	r24, 0x06	; 6
    5654:	8c 83       	std	Y+4, r24	; 0x04
    5656:	09 83       	std	Y+1, r16	; 0x01
    5658:	1a 83       	std	Y+2, r17	; 0x02
    565a:	8f ef       	ldi	r24, 0xFF	; 255
    565c:	9f e7       	ldi	r25, 0x7F	; 127
    565e:	8d 83       	std	Y+5, r24	; 0x05
    5660:	9e 83       	std	Y+6, r25	; 0x06
    5662:	ae 01       	movw	r20, r28
    5664:	46 5e       	subi	r20, 0xE6	; 230
    5666:	5f 4f       	sbci	r21, 0xFF	; 255
    5668:	68 8d       	ldd	r22, Y+24	; 0x18
    566a:	79 8d       	ldd	r23, Y+25	; 0x19
    566c:	ce 01       	movw	r24, r28
    566e:	01 96       	adiw	r24, 0x01	; 1
    5670:	0e 94 08 26 	call	0x4c10	; 0x4c10 <vfprintf>
    5674:	ef 81       	ldd	r30, Y+7	; 0x07
    5676:	f8 85       	ldd	r31, Y+8	; 0x08
    5678:	e0 0f       	add	r30, r16
    567a:	f1 1f       	adc	r31, r17
    567c:	10 82       	st	Z, r1
    567e:	2e 96       	adiw	r28, 0x0e	; 14
    5680:	cd bf       	out	0x3d, r28	; 61
    5682:	de bf       	out	0x3e, r29	; 62
    5684:	df 91       	pop	r29
    5686:	cf 91       	pop	r28
    5688:	1f 91       	pop	r17
    568a:	0f 91       	pop	r16
    568c:	08 95       	ret

0000568e <__ultoa_invert>:
    568e:	fa 01       	movw	r30, r20
    5690:	aa 27       	eor	r26, r26
    5692:	28 30       	cpi	r18, 0x08	; 8
    5694:	51 f1       	breq	.+84     	; 0x56ea <__ultoa_invert+0x5c>
    5696:	20 31       	cpi	r18, 0x10	; 16
    5698:	81 f1       	breq	.+96     	; 0x56fa <__ultoa_invert+0x6c>
    569a:	e8 94       	clt
    569c:	6f 93       	push	r22
    569e:	6e 7f       	andi	r22, 0xFE	; 254
    56a0:	6e 5f       	subi	r22, 0xFE	; 254
    56a2:	7f 4f       	sbci	r23, 0xFF	; 255
    56a4:	8f 4f       	sbci	r24, 0xFF	; 255
    56a6:	9f 4f       	sbci	r25, 0xFF	; 255
    56a8:	af 4f       	sbci	r26, 0xFF	; 255
    56aa:	b1 e0       	ldi	r27, 0x01	; 1
    56ac:	3e d0       	rcall	.+124    	; 0x572a <__ultoa_invert+0x9c>
    56ae:	b4 e0       	ldi	r27, 0x04	; 4
    56b0:	3c d0       	rcall	.+120    	; 0x572a <__ultoa_invert+0x9c>
    56b2:	67 0f       	add	r22, r23
    56b4:	78 1f       	adc	r23, r24
    56b6:	89 1f       	adc	r24, r25
    56b8:	9a 1f       	adc	r25, r26
    56ba:	a1 1d       	adc	r26, r1
    56bc:	68 0f       	add	r22, r24
    56be:	79 1f       	adc	r23, r25
    56c0:	8a 1f       	adc	r24, r26
    56c2:	91 1d       	adc	r25, r1
    56c4:	a1 1d       	adc	r26, r1
    56c6:	6a 0f       	add	r22, r26
    56c8:	71 1d       	adc	r23, r1
    56ca:	81 1d       	adc	r24, r1
    56cc:	91 1d       	adc	r25, r1
    56ce:	a1 1d       	adc	r26, r1
    56d0:	20 d0       	rcall	.+64     	; 0x5712 <__ultoa_invert+0x84>
    56d2:	09 f4       	brne	.+2      	; 0x56d6 <__ultoa_invert+0x48>
    56d4:	68 94       	set
    56d6:	3f 91       	pop	r19
    56d8:	2a e0       	ldi	r18, 0x0A	; 10
    56da:	26 9f       	mul	r18, r22
    56dc:	11 24       	eor	r1, r1
    56de:	30 19       	sub	r19, r0
    56e0:	30 5d       	subi	r19, 0xD0	; 208
    56e2:	31 93       	st	Z+, r19
    56e4:	de f6       	brtc	.-74     	; 0x569c <__ultoa_invert+0xe>
    56e6:	cf 01       	movw	r24, r30
    56e8:	08 95       	ret
    56ea:	46 2f       	mov	r20, r22
    56ec:	47 70       	andi	r20, 0x07	; 7
    56ee:	40 5d       	subi	r20, 0xD0	; 208
    56f0:	41 93       	st	Z+, r20
    56f2:	b3 e0       	ldi	r27, 0x03	; 3
    56f4:	0f d0       	rcall	.+30     	; 0x5714 <__ultoa_invert+0x86>
    56f6:	c9 f7       	brne	.-14     	; 0x56ea <__ultoa_invert+0x5c>
    56f8:	f6 cf       	rjmp	.-20     	; 0x56e6 <__ultoa_invert+0x58>
    56fa:	46 2f       	mov	r20, r22
    56fc:	4f 70       	andi	r20, 0x0F	; 15
    56fe:	40 5d       	subi	r20, 0xD0	; 208
    5700:	4a 33       	cpi	r20, 0x3A	; 58
    5702:	18 f0       	brcs	.+6      	; 0x570a <__ultoa_invert+0x7c>
    5704:	49 5d       	subi	r20, 0xD9	; 217
    5706:	31 fd       	sbrc	r19, 1
    5708:	40 52       	subi	r20, 0x20	; 32
    570a:	41 93       	st	Z+, r20
    570c:	02 d0       	rcall	.+4      	; 0x5712 <__ultoa_invert+0x84>
    570e:	a9 f7       	brne	.-22     	; 0x56fa <__ultoa_invert+0x6c>
    5710:	ea cf       	rjmp	.-44     	; 0x56e6 <__ultoa_invert+0x58>
    5712:	b4 e0       	ldi	r27, 0x04	; 4
    5714:	a6 95       	lsr	r26
    5716:	97 95       	ror	r25
    5718:	87 95       	ror	r24
    571a:	77 95       	ror	r23
    571c:	67 95       	ror	r22
    571e:	ba 95       	dec	r27
    5720:	c9 f7       	brne	.-14     	; 0x5714 <__ultoa_invert+0x86>
    5722:	00 97       	sbiw	r24, 0x00	; 0
    5724:	61 05       	cpc	r22, r1
    5726:	71 05       	cpc	r23, r1
    5728:	08 95       	ret
    572a:	9b 01       	movw	r18, r22
    572c:	ac 01       	movw	r20, r24
    572e:	0a 2e       	mov	r0, r26
    5730:	06 94       	lsr	r0
    5732:	57 95       	ror	r21
    5734:	47 95       	ror	r20
    5736:	37 95       	ror	r19
    5738:	27 95       	ror	r18
    573a:	ba 95       	dec	r27
    573c:	c9 f7       	brne	.-14     	; 0x5730 <__ultoa_invert+0xa2>
    573e:	62 0f       	add	r22, r18
    5740:	73 1f       	adc	r23, r19
    5742:	84 1f       	adc	r24, r20
    5744:	95 1f       	adc	r25, r21
    5746:	a0 1d       	adc	r26, r0
    5748:	08 95       	ret

0000574a <_exit>:
    574a:	f8 94       	cli

0000574c <__stop_program>:
    574c:	ff cf       	rjmp	.-2      	; 0x574c <__stop_program>
